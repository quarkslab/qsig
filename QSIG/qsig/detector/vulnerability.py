from __future__ import annotations
import logging
from typing import List, Any

import firmextractor

import qsig
from qsig.detector.detector import Detector


logger: logging.Logger = logging.getLogger(__name__)
"""Logger instance"""


class CVEDetector(Detector):
    """CVE Detector

    A CVE detector is the wrapper around a CVESignature.
    It contains for each FileSignature a FileMatcher.

    Args:
        signature: A CVESignature
        program_holder: Container to load programs
        kwargs: Additional optional arguments

    Attributes:
        signature: A CVESignature
        program_holder: Container to load programs
        file_matchers: A list of file matchers loaded from the CVE signature

    """

    def __init__(
        self,
        signature: qsig.sig.CVESignature,
        program_holder: qsig.program.ProgramLoader,
        **kwargs: Any,
    ):
        """Constructor"""
        self.signature: qsig.sig.CVESignature = signature

        self.accepted: List[qsig.detector.FileDetector] = []

        self.file_matchers = []
        for file_signature in self.signature.file_signatures:
            self.file_matchers.append(
                qsig.detector.FileDetector(
                    file_signature, program_holder, self, **kwargs
                )
            )

    @property
    def cve_id(self) -> str:
        """Get the CVE-id of the vulnerability"""
        return self.signature.cve_id

    def accept(
        self, binary_file: firmextractor.fs.ExecutableFile, force: bool = False
    ) -> bool:
        """Should this CVEMatcher be used to match for binary_file?

        Args:
            binary_file: An executable file to consider
            force: Optional. Override the decision

        Returns:
            True if any of the FileMatcher accepted the binary_file
        """

        self.accepted = []

        for file_matcher in self.file_matchers:
            if file_matcher.accept(binary_file) or force:
                self.accepted.append(file_matcher)

        return self.accepted != []

    def match(self, binary_file: firmextractor.fs.ExecutableFile) -> bool:
        """Performs the matching

        Args:
            binary_file: Binary file to consider

        Returns:
            boolean for success
        """
        results: List[bool] = []
        for file_matcher in self.accepted:
            results.append(file_matcher.match(binary_file))

        if any(results):
            logger.info("CVE Match for %s on %s", self.cve_id, binary_file.path)
            return True

        return False

    def chunk_index(self, chunk_matcher: qsig.detector.ChunkDetector) -> int:
        """Return the index of a chunk matcher.

        This number is accumulative, that means its unique through all the file
        detectors.

        Args:
            chunk_matcher: Chunk to retrieve index

        Returns:
            The index of the chunk
        """
        index: int = 0
        for file_detector in self.file_matchers:
            for chunk_detector in file_detector.chunk_matchers:
                if chunk_matcher == chunk_detector:
                    return index
                index += 1

        raise ValueError("Unable to find chunk_matcher")

    def __str__(self) -> str:
        """String representation
        TODO(dm) maybe rewrite this into something nicer
        """
        result = f"<CVEDetector for {self.signature.cve_id} using: "
        for fd in self.file_matchers:
            for line in str(fd).splitlines():
                result += "\n\t" + line
        result += "\n>"
        return result
