diff --git a/ocaml/src/Makefile b/ocaml/src/Makefile
index 4d32ad77..f9d07268 100644
--- a/ocaml/src/Makefile
+++ b/ocaml/src/Makefile
@@ -3,17 +3,9 @@ GITVERSION:=$(shell git describe --dirty)
 LIBDIR=$(DESTDIR)/$(PREFIX)/lib/
 BINDIR=$(DESTDIR)/$(PREFIX)/bin/
 
-CAMLC   ?=ocamlc
-CAMLOPT ?=ocamlopt
-CAMLLEX ?=ocamllex
-MENHIR  =menhir --explain
-CAMLDEP ?=ocamldep
-CAMLDOC ?=ocamldoc
-CAMLFIND ?=ocamlfind
-
-CPPO_VER=-V OCAML:$(shell $(CAMLC) -vnum)
+CPPO_VER=-V OCAML:$(shell ocamlc -vnum)
 CPPO="cppo $(CPPO_VER)"
-CAMLLIBDIR:=$(shell $(CAMLC) -where)
+CAMLLIBDIR:=$(shell ocamlc -where)
 
 
 ML=\
@@ -32,6 +24,7 @@ ML=\
   data-struct/asm.ml\
   utils/dump.ml\
   data-struct/mapped_mem.ml\
+  loaders/custom_section.ml\
   loaders/manual.ml\
   loaders/raw.ml\
   loaders/elf_core.ml\
@@ -45,7 +38,6 @@ ML=\
   disassembly/armv7Imports.ml\
   disassembly/armv8aImports.ml\
   disassembly/powerpcImports.ml\
-  disassembly/riscVImports.ml\
   frontend/lexer.ml\
   frontend/parser.ml\
   domains/env.ml\
@@ -63,11 +55,8 @@ ML=\
   disassembly/armv7.ml\
   disassembly/armv8A.ml\
   disassembly/powerpc.ml\
-  disassembly/risc_v.ml\
-  fixpoint/forward.ml\
-  fixpoint/backward.ml\
   fixpoint/interpreter.ml\
-  bincat_ver.ml\
+  bincat_ver.ml \
   main.ml
 
 MLI=\
@@ -79,7 +68,7 @@ MLI=\
   domains/domain.mli\
   disassembly/cfa.mli\
   disassembly/decoder.mli\
-
+  fixpoint/stubs.mli
 
 
 DEPS-armv8A := armv8A_ppx
@@ -100,10 +89,10 @@ DEPS-reduced_unrel_typenv_heap := npk/c2newspeak/typedC.cmi npk/newspeak/newspea
 OPTS-reduced_unrel_typenv_heap := -I npk/c2newspeak -I npk/newspeak
 
 
-EXTLIB := str unix graph zarith bigarray
-PACKAGES := ocamlgraph zarith
+EXTLIB := nums str unix graph zarith bigarray
+PACKAGES := ocamlgraph zarith num
 
-EXTLIBINCL := $(foreach P,$(PACKAGES), -I $(shell $(CAMLFIND) query $(P)))
+EXTLIBINCL := $(foreach P,$(PACKAGES), -I $(shell ocamlfind query $(P)))
 LIBINCL = $(EXTLIBINCL) -I data-struct -I domains -I utils -I disassembly -I frontend -I loaders -I fixpoint
 
 #  W58: no cmx file was found in path for module Z
@@ -112,6 +101,13 @@ LIBINCL = $(EXTLIBINCL) -I data-struct -I domains -I utils -I disassembly -I fro
 #  -> not really a pb
 CAMLOPTIONS = -g -w Ael -warn-error +a-3-7-50-42-44-58 -w -42 -w -58 -w -67
 
+CAMLC   =ocamlc
+CAMLOPT =ocamlopt
+CAMLLEX =ocamllex
+MENHIR  =menhir --explain
+CAMLDEP =ocamldep
+CAMLDOC =ocamldoc
+
 EXEOPT=bincat
 EXEBYTE=bincat.byte
 
@@ -165,7 +161,7 @@ all: $(LIBNAME) $(EXENAME)
 endif
 
 armv8A_ppx: disassembly/armv8A_ppx.ml
-	$(CAMLOPT) -pp $(CPPO) -warn-error -33-9-17 -I `$(CAMLFIND) query ppx_tools` -I +compiler-libs -o armv8A_ppx  str.cmxa ocamlcommon.cmxa ppx_tools.cmxa $+
+	$(CAMLOPT) -pp $(CPPO) -warn-error -33-9-17 -I `ocamlfind query ppx_tools` -I +compiler-libs -o armv8A_ppx  str.cmxa ocamlcommon.cmxa ppx_tools.cmxa $+
 
 $(LIBNAME): $(NPKLIB) $(OBJ)
 	rm -f $(BINCATOBJ)
diff --git a/ocaml/src/data-struct/asm.ml b/ocaml/src/data-struct/asm.ml
index d0ca4a01..4df1f2ee 100644
--- a/ocaml/src/data-struct/asm.ml
+++ b/ocaml/src/data-struct/asm.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2018 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -51,8 +51,6 @@ type cmp =
   | LT  (** strictly less than *)
   | GEQ (** greater than or equal to *)
   | GT  (** strictly greater than *)
-  | GES (** signed greater than or equal to *)
-  | LTS (** signed less than *)
 
   (** logical binary operators *)
 type logbinop =
@@ -122,7 +120,7 @@ and directive_t =
             tmin (n, bs) where n is an offset from memory [e].
             This offset is the minimal integer where (sz)[e] cmp terminator is true
         *)
-  | Handler of int * Address.t (** Handler(sig_nb, addr): handler of signal number _sig_nb_ is at address _addr_ *)
+
   | Stub of string * calling_convention_t (** Stub (f, args) is the stub of the function f with args as arguments *)
   | Skip of fun_t * calling_convention_t (** Skip (f, calling_conv) will skip the function _f_ but restablish the stack wrt the calling convention _calling_conv_ *)
 
@@ -172,8 +170,6 @@ let string_of_cmp c =
   | LT  -> "<"
   | GEQ -> ">="
   | GT  -> ">"
-  | LTS -> "<"
-  | GES -> ">="
 
 
 let string_of_logbinop o =
@@ -273,10 +269,6 @@ let string_of_directive d extended =
        Printf.sprintf "%s <- stub of %s" (string_of_lval cc.return extended) f
      else
        Printf.sprintf "stub of %s" f
-
-  | Handler (sig_nb, handler_addr) ->
-     Printf.sprintf "the handler of signal %d is set at address %s" sig_nb (Address.to_string handler_addr)
-    
   | Skip (f, cc) ->
      let fs = string_of_fun f in
      if extended then
diff --git a/ocaml/src/data-struct/data.ml b/ocaml/src/data-struct/data.ml
index add75761..f7a0d45d 100644
--- a/ocaml/src/data-struct/data.ml
+++ b/ocaml/src/data-struct/data.ml
@@ -176,8 +176,7 @@ struct
                n
              else
                Word.compare_value w1 w2
-        let to_string (r, w) = Printf.sprintf "%s%s" (string_of_region r) (Word.to_string w)
-                             
+
         let equal (r1, w1) (r2, w2) =
             if equal_region r1 r2 then Word.equal w1 w2
             else false
@@ -188,7 +187,7 @@ struct
               raise (Exceptions.Error "Tried to create negative address")
             else r, w
 
-
+        let to_string (r, w) = Printf.sprintf "%s%s" (string_of_region r) (Word.to_string w)
 
         (** returns the offset of the address *)
         let to_int (_, w) =  Word.to_int w
diff --git a/ocaml/src/data-struct/mapped_mem.ml b/ocaml/src/data-struct/mapped_mem.ml
index edc5f919..f4c95404 100644
--- a/ocaml/src/data-struct/mapped_mem.ml
+++ b/ocaml/src/data-struct/mapped_mem.ml
@@ -69,14 +69,54 @@ let is_in_section vaddr section =
   (Data.Address.compare vaddr section.virt_addr >= 0) &&
     (Data.Address.compare vaddr section.virt_addr_end < 0)
 
+let is_good_section section (taint_src: Taint.Src.t) : bool =
+  let taint_id = Taint.Src.src_id taint_src in
+  let section_name, section_id =
+    if taint_id >= Hashtbl.length Config.funSkipTbl then
+      "arg", taint_id - Hashtbl.length Config.funSkipTbl
+    else
+      "call", taint_id in
+  section.name = section_name ^ (string_of_int section_id)
+
+let find_section_from_taint (taint_src: Taint.SrcSet.t) : section_t =
+  let src = Taint.SrcSet.min_elt taint_src in
+  let mapped_mem = match !current_mapping with
+  | None -> L.abort (fun p -> p "File not mmapped")
+  | Some x -> x in
+  try
+    List.find (fun section_info -> is_good_section section_info src ) mapped_mem.sections
+  with
+    | Not_found -> raise(Exceptions.Error("Not found"))
+
+let is_good_name section (name: string): bool =
+  section.name = name
+
+let find_top_section (_) : section_t =
+  let mapped_mem = match !current_mapping with
+  | Some x -> x
+  | None -> raise (Exceptions.Too_many_concrete_elements "File not mapped")
+  in try
+    let section = List.find (fun section -> is_good_name section "topsection") mapped_mem.sections in
+    section
+  with Not_found ->
+    L.debug2(fun p -> p "Top section not found");
+    raise (Exceptions.Error("Top section not found"))
+
+let get_address_from_taint (taint_src : Taint.t) : Data.Address.t =
+  let section = match taint_src with
+    | Taint.S srcs -> find_section_from_taint srcs
+    | Taint.TOP -> find_top_section taint_src
+    | Taint.BOT | Taint.U -> raise (Exceptions.Too_many_concrete_elements "no taint")
+  in section.virt_addr
+
 (** find the first section in a section list that contains vaddr *)
 let find_section section_list vaddr =
   try
     List.find (fun section_info -> is_in_section vaddr section_info) section_list
-  with
-  | Not_found -> raise (Exceptions.Error
-                          (Printf.sprintf "No mapped section at vaddr=%s"
-                                          (Data.Address.to_string vaddr)))
+  with Not_found -> (
+      L.error(fun p -> p "No mapped section at vaddr=%s" (Data.Address.to_string vaddr));
+      raise (Exceptions.Error("No mapped section"))
+  )
 
 (** return Some byte from mapped mem at vaddr or None if it is out of the file and raises Not_found if not in any section*)
 let read mapped_mem vaddr =
@@ -87,36 +127,42 @@ let read mapped_mem vaddr =
   L.debug2 (fun p -> p "Section found [%s:%s], reading at paddr=%08x"
                        section.mapped_file_name section.name file_offset);
   (* check if we're out of the section's raw data *)
-  let byte = if file_offset >= (Z.to_int section.raw_addr_end) then
-      begin
-        L.debug2 (fun p -> p "paddr=%08x is out of the section on disk" (file_offset));
-        0
-      end
-    else
-      Bigarray.Array1.get section.mapped_file file_offset in
+  let byte =
+    if Str.string_match (Str.regexp "\\(arg[0-9]\\|call[0-9]\\|topsection\\)") section.name 0 then (
+        -1
+    ) else if file_offset >= (Z.to_int section.raw_addr_end) then (
+      L.debug2 (fun p -> p "paddr=%08x is out of the section on disk" (file_offset));
+      0
+    )
+    else Bigarray.Array1.get section.mapped_file file_offset
+    in
   L.debug(fun p -> p "read byte %02x" byte);
   Data.Word.of_int (Z.of_int byte) 8
 
 
 let string_from_addr mapped_mem vaddr len =
   L.debug2 (fun p -> p "Reading string at vaddr=%s len=%i" (Data.Address.to_string vaddr) len);
-  let sec = find_section mapped_mem.sections vaddr in
-  let raddr = Z.to_int (Z.add sec.raw_addr (Data.Address.sub vaddr sec.virt_addr)) in
-  L.debug2 (fun p -> p "Section found [%s:%s], reading at paddr=%08x"
-                       sec.mapped_file_name sec.name raddr);
-  if raddr >= (Z.to_int sec.raw_addr_end) then
-    begin
-      L.debug2 (fun p -> p "paddr=%08x is out of the section on disk" raddr);
-      None
-    end
-  else
-    let last_raddr = (min (raddr + len) (Z.to_int sec.raw_addr_end))-1 in
-    let addrs = Misc.seq raddr last_raddr in
-    let bytes = List.map
-      (fun addr -> Char.chr (Bigarray.Array1.get sec.mapped_file addr))
-      addrs in
-    L.debug (fun p -> p "read %i bytes at %s: [%s]"
-      len (Data.Address.to_string vaddr)
-      (String.concat " " (List.map (fun b -> Printf.sprintf "%02x" (Char.code b)) bytes)));
-    Some (Misc.string_of_chars bytes)
-
+  try
+    let sec = find_section mapped_mem.sections vaddr in
+    let raddr = Z.to_int (Z.add sec.raw_addr (Data.Address.sub vaddr sec.virt_addr)) in
+    L.debug2 (fun p -> p "Section found [%s:%s], reading at paddr=%08x"
+                        sec.mapped_file_name sec.name raddr);
+    if raddr >= (Z.to_int sec.raw_addr_end) then
+      begin
+        L.debug2 (fun p -> p "paddr=%08x is out of the section on disk" raddr);
+        None
+      end
+    else
+      let last_raddr = (min (raddr + len) (Z.to_int sec.raw_addr_end))-1 in
+      let addrs = Misc.seq raddr last_raddr in
+      try
+        let bytes = List.map
+          (fun addr -> Char.chr (Bigarray.Array1.get sec.mapped_file addr))
+          addrs in
+          L.debug (fun p -> p "read %i bytes at %s: [%s]" len (Data.Address.to_string vaddr)
+            (String.concat " " (List.map (fun b -> Printf.sprintf "%02x" (Char.code b)) bytes)));
+        Some (Misc.string_of_chars bytes)
+      with Invalid_argument msg -> L.error(fun p -> p "%s" msg); None
+    with
+       | Exceptions.Error msg -> L.error(fun p -> p "%s" msg); None
+       | _ -> L.error(fun p -> p "Unknown exceptions occured"); None
\ No newline at end of file
diff --git a/ocaml/src/data-struct/taint.ml b/ocaml/src/data-struct/taint.ml
index 06ee915d..e59b7c85 100644
--- a/ocaml/src/data-struct/taint.ml
+++ b/ocaml/src/data-struct/taint.ml
@@ -38,6 +38,9 @@ module Src =
       | Tainted of id_t (** surely tainted by the given source *)
       | Maybe of id_t (** maybe tainted by then given source *)
 
+    let src_id src : int =
+      match src with
+      | Tainted id | Maybe id -> id
 
     (* comparison between tainting sources. Returns
     - 0 is equal
@@ -80,12 +83,12 @@ let total_order t1 t2 =
      let n2 = SrcSet.cardinal src2 in
      let n = n1-n2 in
      if n <> 0 then n1
-     else SrcSet.compare src1 src2   
+     else SrcSet.compare src1 src2
   | BOT, _ -> -1
   | TOP, _ -> -1
   | U, _ -> -1
   | _, _ -> 1
-          
+
 let is_subset t1 t2 =
   match t1, t2 with
   | BOT, _
@@ -235,12 +238,12 @@ let to_z (t: t): Z.t =
 let to_string t =
   match t with
   | BOT -> "_"
-  | U -> ""
+  | U -> "U"
   | TOP -> "?"
   | S srcs ->
      SrcSet.fold (fun src acc -> (Src.to_string src)^", "^acc) srcs ""
 
-module Set = Set.Make (struct type aux_t = t type t = aux_t let compare = total_order end) 
+module Set = Set.Make (struct type aux_t = t type t = aux_t let compare = total_order end)
 
 let string_of_set s =
   let s' = Set.fold (fun s acc -> logor s acc) s U in
diff --git a/ocaml/src/disassembly/armv7.ml b/ocaml/src/disassembly/armv7.ml
index 3c3739d9..a62f4524 100644
--- a/ocaml/src/disassembly/armv7.ml
+++ b/ocaml/src/disassembly/armv7.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -170,7 +170,7 @@ struct
                        BBinOp(LogOr, BBinOp(LogAnd, n_is_set, v_is_clear),
                               BBinOp(LogAnd, n_is_clear, v_is_set)))
 
-    | _ -> L.abort (fun p -> p "Unexpected condiction code %x" cc)
+    | _ -> L.abort (fun p -> p "Unexpected condition code %x" cc)
 
 
   let op_add rd rn op2_stmt =
@@ -233,9 +233,8 @@ struct
       nflag_update_exp rd ]
 
 
-
   module Cfa = Cfa.Make(Domain)
-               
+
   module Imports = Armv7Imports.Make(Domain)(Stubs)
 
   type state = {
@@ -252,6 +251,13 @@ struct
     | MARK_ISN of Asm.stmt
     | MARK_FLAG of Asm.stmt
 
+  type shift_type_t =
+    | SRType_LSL
+    | SRType_LSR
+    | SRType_ASR
+    | SRType_RRX
+    | SRType_ROR
+
   let mark_as_isn l =
     List.map (fun i -> MARK_ISN i) l
 
@@ -270,16 +276,23 @@ struct
 
   (* fatal error reporting *)
   let error a msg =
-    L.abort (fun p -> p "at %s: %s" (Address.to_string a) msg)
+    L.error (fun p -> p "at %s: %s" (Address.to_string a) msg);
+    raise (Exceptions.Failed_decoding ((Printf.sprintf "ERROR: %s" (Address.to_string a)), 0))
 
-  let error_isn a isn msg =
-    L.abort (fun p -> p "at %s: isn=%08x %s" (Address.to_string a) isn msg)
+  let error_isn a (isn: int) ?(isn2) (msg: string) =
+    let isn = match isn2 with None -> isn | Some value -> (isn lsl 16 lor value) in
+    L.error (fun p -> p "at %s: isn=%08x %s" (Address.to_string a) isn msg);
+    raise (Exceptions.Failed_decoding ((Printf.sprintf "ERROR_ISN: %d" isn), isn))
 
-  let notimplemented_arm s isn mnemo = L.abort (fun p -> p "at %s: %s (%08x): ARM instruction not implemented yet"
-                                                 (Address.to_string s.a) mnemo isn)
+  let notimplemented_arm s isn mnemo =
+    L.error (fun p -> p "at %s: %s (%08x): ARM instruction not implemented yet"
+                                                 (Address.to_string s.a) mnemo isn);
+    raise (Exceptions.Failed_decoding ((Printf.sprintf "ARM: %s" mnemo), isn))
 
-  let notimplemented_thumb s isn mnemo = L.abort (fun p -> p "at %s: %s (%04x): thumb instruction not implemented yet"
-                                                 (Address.to_string s.a) mnemo isn)
+  let notimplemented_thumb s isn mnemo =
+    L.error (fun p -> p "at %s: %s (%04x): thumb instruction not implemented yet"
+                                                 (Address.to_string s.a) mnemo isn);
+    raise (Exceptions.Failed_decoding ((Printf.sprintf "THUMB: %s" mnemo), isn))
 
   let string_to_char_list str =
     let len = String.length str in
@@ -315,10 +328,12 @@ struct
 
   let return (s: state) (instruction: int) (stmts: Asm.stmt list): Cfa.State.t * Data.Address.t =
     let isn_size =
-      if s.thumbmode && ((((instruction lsr 11) land 0x3) = 0) ||
-                           (((instruction lsr 13) land 0x7) != 0b111))
-      then 2 (* Thumb 16 bits instruction *)
-      else 4 (* Arm or Thumb 32 bits instruction *) in
+      if s.thumbmode then (
+        if instruction > 0xFFFF then 4
+        else if ((((instruction lsr 11) land 0x3) = 0) || (((instruction lsr 13) land 0x7) != 0b111)) then 2
+        else 4
+      ) else 4
+    in
     s.b.Cfa.State.stmts <- stmts;
     s.b.Cfa.State.bytes <-
       if isn_size = 2 then
@@ -440,8 +455,8 @@ struct
     @ jmp_or_call_stmt
 
   let branch_exchange s instruction =
-    let zero = const 0 1 in
-    let one = const 1 1 in
+    let zero = const 0 32 in
+    let one = const 1 32 in
     let jreg = Lval(V(treg (instruction land 0xf))) in
     let bit1 = BinOp(And, jreg, one) in
     let target = BinOp(And, jreg, const 0xfffffffe 32) in
@@ -461,7 +476,6 @@ struct
     let sign = TernOp( Cmp (EQ, msb, const 0 32), const 0 32, sign_mask) in
     BinOp(Or, shifted, sign)
 
-
   let asr_stmt_exp exp shift_exp =
     let sign_mask = BinOp(Shl, const (-1) 32, BinOp(Sub, const 32 32, shift_exp)) in
     let shifted = BinOp(Shr, exp, shift_exp) in
@@ -495,106 +509,187 @@ struct
                        one33),
                   const 1 1, const 0 1))
 
+  let lsl_c register (amount: int) =
+    BinOp(Shl, Lval (V (treg register )), const amount 32),
+    Lval (V (preg register amount amount))
 
-  let single_data_transfer s instruction =
-    let rd = (instruction lsr 12) land 0xf in
-    let rn = (instruction lsr 16) land 0xf in
-    let ofs = if instruction land (1 lsl 25) = 0 then (* immediate value *)
-        const (instruction land 0xfff) 32
-      else
-        let rm = instruction land 0xf in
-        let shift_op = (instruction lsr 4) land 0xff in
-        if shift_op land 1 = 1 then error s.a "Shift register cannot be specified for single data transfer instructions"
-        else
-          let shift_type = (shift_op lsr 1) land 3 in
-          let shift_amount = (shift_op lsr 3) land 0x1f in
-          match  shift_type with
-          | 0b00 -> (* logical shift left *)
-             if shift_amount = 0 then
-              Lval (V (treg rm))
-            else
-              BinOp(Shl, Lval (V (treg rm)), const shift_amount 32)
-          | 0b01 -> (* logical shift right *)
-             let actual_shift = if shift_amount = 0 then 32 else shift_amount in
-             BinOp(Shl, Lval (V (treg rm)), const actual_shift 32)
-          | 0b10 -> (* asr *)
-             let actual_shift = if shift_amount = 0 then 32 else shift_amount in
-             asr_stmt (Lval (V (treg rm))) actual_shift
-          | 0b11 -> (* ror *)
-             let actual_shift = if shift_amount = 0 then 32 else shift_amount in
-             ror_stmt (Lval (V (treg rm))) actual_shift
-          | _ -> error s.a "unexpected shift type insingle data xfer" in
-    let updown = if (instruction land (1 lsl 23)) = 0 then Sub else Add in
-    let preindex = (instruction land (1 lsl 24)) <> 0 in
-    let writeback = (instruction land (1 lsl 21)) <> 0 in
-    let length, dst_or_src = if (instruction land (1 lsl 22)) = 0 then
-        32, (V (treg rd))
+  let lsr_c register (amount: int) =
+    BinOp(Shl, Lval (V (treg register )), const amount 32),
+    Lval( V( preg register (amount-1) (amount-1)))
+
+  let set_cflag_from_carry_out (carry_out: Asm.exp) : Asm.stmt =
+    Set( V (T cflag), carry_out)
+
+  let decode_shift_carry (register: int) (shift_type: shift_type_t) (shift_amount: int) (carry_in: Asm.exp) : Asm.exp * Asm.exp =
+    (* *)
+    match shift_type with
+    | SRType_LSL -> (* LSL *)
+      if shift_amount = 0 then
+        Lval (V (treg register)), carry_in
       else
-        8, (V (preg rd 0 7)) in
-    let src_or_dst = match preindex,writeback with
-      | true, false -> M (BinOp(updown, Lval (V (treg rn)), ofs), length)
-      | true, true
-      | false, false -> M (Lval (V (treg rn)), length) (* if post-indexing, write back is implied and W=0 *)
-      | false, true -> error s.a "Undefined combination (post indexing and W=1)" in
-    let stmts,update_pc = if (instruction land (1 lsl 20)) = 0 then (* store *)
-        [ Set (src_or_dst, Lval dst_or_src)], false
-      else (* load *)
-        if length = 32 then
-          [ Set (V (treg rd), Lval src_or_dst) ], rd = 15
-        else
-          [ Set (V (treg rd), UnOp(ZeroExt 32, Lval src_or_dst)) ], rd = 15 in
-    let write_back_stmt = Set (V (treg rn), BinOp(updown, Lval (V (treg rn)), ofs)) in
-    let stmts' =
-      if preindex then
-        if writeback then
-          write_back_stmt :: stmts
+        lsl_c register shift_amount (* LSL_C *)
+    | SRType_LSR -> (* LSR *)
+        lsr_c register shift_amount
+    | SRType_ASR -> (* ASR *)
+      let carry_out = Lval( V( preg register (shift_amount-1) (shift_amount-1))) in
+      (asr_stmt (Lval (V (treg register))) shift_amount), carry_out
+    | SRType_ROR -> (* ROR *)
+      let div = shift_amount / 32 in
+      let stmts, _ =
+        if div = 0 then
+          lsr_c register shift_amount
         else
-          stmts
+          lsl_c register (shift_amount - div)
+        in
+      stmts, Lval( V( preg register 31 31))
+    | SRType_RRX -> (* RRX *)
+      let stmts = BinOp(Or,
+            BinOp(Shl, carry_in, const 31 32),
+            BinOp(And,
+                  Lval (V (treg register)),
+                  const (0x7fffffff) 32))
+      in
+      stmts, Lval( V( preg register 0 0))
+
+  let decode_imm_shift (shift: int) (shift_amount: int) : shift_type_t * int =
+    (* DecodeImmShift *)
+    let actual_shift = if shift_amount = 0 then 32 else shift_amount in
+    match shift with
+    | 0b00 -> SRType_LSL, shift_amount
+    | 0b01 -> SRType_LSR, actual_shift
+    | 0b10 -> SRType_ASR, actual_shift
+    | 0b11 -> (if shift_amount = 0 then SRType_RRX, 1 else SRType_ROR, shift_amount)
+    | _ -> L.abort(fun p -> p "Unknown shift (imm)")
+
+  let decode_reg_shift (shift: int) : shift_type_t =
+    (* DecodeRegShift *)
+    match shift with
+    | 0b00 -> SRType_LSL
+    | 0b01 -> SRType_LSR
+    | 0b10 -> SRType_ASR
+    | 0b11 -> SRType_ROR
+    | _ -> L.abort(fun p -> p "Unknown shift (reg)")
+
+  let decode_shift (register: int) (shift_t: shift_type_t) (shift_n: int) (carry_in: Asm.exp) : Asm.exp =
+    (* Shift *)
+    let result, _ = decode_shift_carry register shift_t shift_n carry_in in
+    result
+
+  let nth_bit (n: int) (value:int) : int = (value lsr n) land 1
+
+  let is_valid (v: char) (m: int) =
+    if v = 'x' then true
+    else int_of_char v = (m+48)
+
+  let bitstring (length: int) (value: int) =
+    let rec aux (acc: int list) (cur: int) (value: int) =
+      if cur < length then (aux ((nth_bit cur value) :: acc) (cur+1) value) else acc
+    in aux [] 0 value
+
+  let check_mask (mask: string) (value: int) : bool =
+    let bit_value = bitstring (String.length mask) value in
+    List.fold_left(fun acc el -> acc && el ) true (List.mapi (fun index b -> is_valid mask.[index] b) bit_value)
+
+  let single_data_transfer _s instruction (store: bool) (updown: bool) (index: bool) (writeback: bool) (offset: Asm.exp) (size: int) (signed: bool) =
+    let rt = (instruction lsr 12) land 0xf in
+    let rn = (instruction lsr 16) land 0xf in
+    let operation = if signed then (SignExt 32) else (ZeroExt 32) in
+    let add = if updown then Sub else Add in
+    let offset_addr = BinOp(add, Lval(V (treg rn)), offset) in
+    let address = if index then offset_addr else Lval (V (treg rn)) in
+    let src, dst =
+      if store then (
+        (if size = 32 then Lval(V (treg rt)) else Lval(V (preg rt 0 (size-1)))),
+        M(address, size)
+      )
+      else (
+        (if size = 32 then Lval(M(address, size)) else UnOp(operation, Lval(M(address, size)))), V (treg rt)
+      )
+   in
+   let update_pc_stmts = if store && rt = 15 then [ Jmp (R (Lval (V (T pc)))) ] else [] in
+    let stmts =
+      [ Set( dst, src)  ]
+    in if writeback then
+      stmts @ [Set(V (treg rn), offset_addr)] @ update_pc_stmts
+    else
+      stmts @ update_pc_stmts
+
+  let decode_single_data_transfer s instruction =
+    (* A5.3 *)
+    let a = instruction lsr 25 land 1 in
+    let op1 = instruction lsr 20 land 0x1f in
+    let b = instruction lsr 4 land 1 in
+
+    let u = instruction land (1 lsl 23) <> 0 in
+    let p = (instruction land (1 lsl 24)) <> 0 in
+    let w = (instruction land (1 lsl 21)) <> 0 in
+
+    let register_form = instruction land (1 lsl 25) <> 0 in
+    let offset = if register_form = false then (* immediate value *)
+      const (instruction land 0xfff) 32
+    else
+      let rm = instruction land 0xf in
+      let shift_op = (instruction lsr 4) land 0xff in
+      if shift_op land 1 = 1 then error s.a "Shift register cannot be specified for single data transfer instructions"
       else
-        stmts @ [ write_back_stmt ] in
-    if update_pc then
-      stmts' @ [ Jmp (R (Lval (V (T pc)))) ]
+        let shift_t, shift_n = decode_imm_shift ((shift_op lsr 1) land 3) ((shift_op lsr 3) land 0x1f) in
+        decode_shift rm shift_t shift_n (const 0 1) in
+
+    if (a = 0 || (a = 1 && b = 0)) && check_mask "xx0x0" op1 then
+      (* STR immediate/register *)
+      single_data_transfer s instruction true u p (not p || w) offset 32 false
+    else if (a = 0 || (a = 1 && b = 0)) && check_mask "0x010" op1 then
+      (* STRT *)
+      single_data_transfer s instruction true u true true offset 32 false
+    else if (a = 0 || (a = 1 && b = 0)) && check_mask "xx0x1" op1 then
+        (* LDR *)
+        single_data_transfer s instruction false u p (not p || w) offset 32 false
+    else if (a = 0 || (a = 1 && b = 0)) && check_mask "0x011" op1 then
+      (* LDRT *)
+      single_data_transfer s instruction false u true true offset 32 false
+    else if (a = 0 || (a = 1 && b = 0)) && check_mask "xx1x0" op1 then
+      (* STRB *)
+      single_data_transfer s instruction false u p (not p || w) offset 8 false
+    else if (a = 0 || (a = 1 && b = 0)) && check_mask "0x110" op1 then
+      (* STRBT *)
+      single_data_transfer s instruction false u true true offset 8 false
+    else if (a = 0 || (a = 1 && b = 0)) && check_mask "xx1x1" op1 then
+      (* LDRB *)
+      single_data_transfer s instruction true u p (not p || w) offset 8 false
+    else if (a = 0 || (a = 1 && b = 0)) && check_mask "0x111" op1 then
+      (* LDRBT *)
+      single_data_transfer s instruction true true true (not p || w) offset 8 false
     else
-      stmts'
+      error s.a (Printf.sprintf "Load store undefined with op1 %d" op1)
+
 
   let halfword_data_transfer s instruction =
-    let rd = (instruction lsr 12) land 0xf in
-    let rn = (instruction lsr 16) land 0xf in
-    let load = (instruction land (1 lsl 20)) <> 0 in
-    let writeback = (instruction land (1 lsl 21)) <> 0 in
-    let immediate = (instruction land (1 lsl 22)) <> 0 in
-    let updown = if (instruction land (1 lsl 23)) = 0 then Sub else Add in
-    let preindex = (instruction land (1 lsl 24)) <> 0 in
-    let extend_op = if (instruction land (1 lsl 6)) = 0 then (ZeroExt 32) else (SignExt 32) in
-    let length = if (instruction land (1 lsl 5)) <> 0 then 16 else 8 in
-    let ofs = if immediate then
-        const (((instruction lsr 4) land 0xf0) lor (instruction land 0xf)) 32
-      else
-        let rm = instruction land 0xf in
-        Lval (V (treg rm)) in
-    let index_expr = BinOp(updown, Lval (V (treg rn)), ofs) in
-    let src_or_dst = match preindex,writeback with
-      | true, false -> M (index_expr, length)
-      | true, true
-      | false, false -> M (Lval (V (treg rn)), length) (* if post-indexing, write back is implied and W=0 *)
-      | false, true -> error s.a "Undefined combination (post indexing and W=1)" in
-    let stmts, update_pc = if load then
-        [ Set (V (treg rd), UnOp(extend_op, Lval src_or_dst)) ], rd = 15
-      else
-        [ Set (src_or_dst, Lval (V (preg rd 0 (length-1)))) ], false in
-    let write_back_stmt = Set (V (treg rn), index_expr) in
-    let stmts' =
-      if preindex then
-        if writeback then
-          write_back_stmt :: stmts
-        else
-          stmts
-      else
-        stmts @ [ write_back_stmt ] in
-    if update_pc then
-      stmts' @ [ Jmp (R (Lval (V (T pc)))) ]
+    (* A5.2.9 *)
+    let op = instruction lsr 20 land 1 in
+    let op2 = instruction lsr 5 land 3 in
+
+    let offset = if (instruction land (1 lsl 22)) <> 0 then
+      const (((instruction lsr 4) land 0xf0) lor (instruction land 0xf)) 32
     else
-      stmts'
+      let rm = instruction land 0xf in
+      Lval (V (treg rm)) in
+
+    let u = instruction land (1 lsl 23) <> 0 in
+
+    match op2 with
+    | 0b01 -> (
+      if op = 0 then
+        (* STRHT *)
+      single_data_transfer s instruction true u true true offset 16 false
+      else
+        (* LDRHT *)
+        single_data_transfer s instruction false u true true offset 16 false
+    )
+    | 0b10 -> (* LDRSBT *)
+      single_data_transfer s instruction false u true true offset 8 true
+    | 0b11 -> (* LDRSHT *)
+      single_data_transfer s instruction false u true true offset 16 true
+    | _ -> error s.a "Undefined halfword data transfer"
 
 
   let data_proc_msr rm_stmt =
@@ -774,8 +869,7 @@ struct
     | 0,_,_ when (op1 land 0b11001 == 0b10000) && (op2 land 0b1000 == 0b0000) -> data_proc_misc_instructions s instruction
     | 0,_,_ when (op1 land 0b11001 == 0b10000) && (op2 land 0b1001 == 0b1000) -> notimplemented_arm s instruction "Halfword multiply and multiply accumulate"
     | 1,0b10000,_ -> if rd == 15
-                     then L.abort (fun p -> p "at %s: MOVW to PC: UNPREDICTABLE"
-                                              (Address.to_string s.a))
+                     then  error_isn s.a instruction "MOVW to PC: UNPREDICTABLE"
                      else [ Set (V (treg rd),
                                  Const (Word.of_int (Z.of_int (
                                                          ((instruction lsr 4) land 0xf000)
@@ -886,7 +980,7 @@ struct
               vflag_update_exp (Lval (V (treg rn))) op2_stmt (Lval (V (P (tmpreg, 0, 31)))) ;
               Directive (Remove tmpreg) ],
             false
-         | _ -> L.abort (fun p -> p "unexpected opcode %x" op1) in
+         | _ -> error_isn s.a instruction "unexpected opcode"  in
        let stmt_cc =
          if set_cond_codes
          then
@@ -1008,6 +1102,7 @@ struct
     | _ -> error s.a (Printf.sprintf "unknown packing/unpacking/saturation/reversal instruction opcode (%08x)" instruction)
 
 
+
   let decode_media_instructions s instruction =
     let op1 = (instruction lsr 20) land 0x1f in
     let op2 = (instruction lsr 5) land 7 in
@@ -1041,20 +1136,21 @@ struct
     let instruction = build_instruction s str in
     let stmts = match (instruction lsr 25) land 0x7 with
     | 0b000 | 0b001 -> data_proc s instruction
-    | 0b010 -> single_data_transfer s instruction
+    | 0b010 -> decode_single_data_transfer s instruction
     | 0b011 ->
            if instruction land (1 lsl 4) = 0
-           then single_data_transfer s instruction
+           then decode_single_data_transfer s instruction
            else decode_media_instructions s instruction
     | 0b100 -> block_data_transfer s instruction (* block data transfer *)
     | 0b101 -> branch s instruction
-    | 0b110 -> error s.a (Printf.sprintf "Comprocessor data transfer not implemented (isn=%08x)" instruction)
+    | 0b110 -> error s.a (Printf.sprintf "Coprocessor data transfer not implemented (isn=%08x)" instruction)
     | 0b111 when instruction land (1 lsl 24) = 0 -> error s.a (Printf.sprintf "coprocessor operation or register transfer (isn=%08x)" instruction)
     | 0b111 when instruction land (1 lsl 24) <> 0 -> error s.a (Printf.sprintf "software interrupt not implemented (swi=%08x)" instruction)
     | _ -> error s.a (Printf.sprintf "Unknown opcode 0x%x" instruction) in
     let cc = (instruction lsr 28) land 0xf in
     let stmts_cc = wrap_cc cc stmts in
-    let current_pc = Const (Word.of_int (Z.add (Address.to_int s.a) (Z.of_int 8)) 32) in (* pc is 8 bytes ahead because of pre-fetching. *)
+    let current_pc = Const (Word.of_int (Z.add (Address.to_int s.a) (Z.of_int 8)) 32) in
+     (* pc is 8 bytes ahead because of pre-fetching. *)
     (* XXX: 12 bytes if a register is used to specify a shift amount *)
     return s instruction (Set( V (T pc), current_pc) :: stmts_cc)
 
@@ -1120,7 +1216,27 @@ struct
       | 0b010 -> L.analysis (fun p -> p "WFE: Wait For Event hint") ; []
       | 0b011 -> L.analysis (fun p -> p "WFI: Wait For Interrupt hint") ; []
       | 0b100 -> L.analysis (fun p -> p "SEV: Send Event hint") ; []
-      | _ -> L.abort (fun p -> p "Unkown hint instruction encoding %04x" isn)
+      | _ -> error_isn s.a isn"Unkown hint instruction encoding"
+
+  let decode_thumb_cbz_cbnz _s isn cmp =
+    let rn = isn land 0x7 in
+    let imm = (((isn lsr 9) land 1) lsl 6) lor (((isn lsr 3) land 0x1f) lsl 1) in (* bit<9>:bit<7-3>:0 *)
+    let branching = [
+      Set (V (T pc), BinOp(Add, Lval (V (T pc)), const imm 32)) ;
+          Jmp (R (Lval (V (T pc))))
+    ] in
+    [ If (Cmp (cmp, Lval (V (treg rn)), const 0 32), branching, []) ] |> mark_as_isn
+
+  let rev _s (rd: int) (rm: int) =
+    (* REV implementation for 32 bits *)
+    let tmpreg = Register.make (Register.fresh_name ()) 32 in
+    [ Set ((V (T tmpreg)), Lval (V (treg rm))); (* Set (V (treg rd), Lval (V (treg rm))) *)
+      Set (V (preg rd 24 31), Lval( V (P (tmpreg, 0, 7))));
+      Set (V (preg rd 16 23), Lval( V (P (tmpreg, 8, 15))));
+      Set (V (preg rd 8 15), Lval( V (P (tmpreg, 16, 23))));
+      Set (V (preg rd 0 7), Lval( V (P (tmpreg, 24, 31))));
+      Directive (Remove tmpreg);
+    ]
 
   let decode_thumb_misc s isn =
     match (isn lsr 6) land 0x3f with
@@ -1130,41 +1246,50 @@ struct
        else (* Change Processor State CPS *)
          notimplemented_thumb s isn "CPS"
     | 0b000000 | 0b000001 -> (* Add Immediate to SP ADD (SP plus immediate) *)
-       notimplemented_thumb s isn "ADD on SP"
+       let imm7 = isn land 0x7f in
+       op_add sp 13 (const (imm7 lsl 2) 32) |> mark_couple
     | 0b000010 | 0b000011 -> (* Subtract Immediate from SP SUB (SP minus immediate) *)
        let imm7 = isn land 0x7f in
        op_sub sp 13 (const (imm7 lsl 2) 32) |> mark_couple
     | 0b000100 | 0b000101 | 0b000110 | 0b000111 -> (* Compare and Branch on Zero CBNZ, CBZ *)
-       notimplemented_thumb s isn "CBZ/CBNZ (0)"
+      decode_thumb_cbz_cbnz s isn EQ
     | 0b001000 -> (* Signed Extend Halfword SXTH *)
        notimplemented_thumb s isn "SXTH"
     | 0b001001 -> (* Signed Extend Byte SXTB *)
        notimplemented_thumb s isn "SXTB"
     | 0b001010 -> (* Unsigned Extend Halfword UXTH *)
-       notimplemented_thumb s isn "UXTH"
+      let rd = isn land 7 in
+      let rm = isn lsr 3 land 7 in
+      [
+        Set ( (V (treg rd)), UnOp( ZeroExt 32, Lval (V (preg rm 0 15))))
+      ] |> mark_as_isn
+       (* notimplemented_thumb s isn "UXTH" *)
     | 0b001011 -> (* Unsigned Extend Byte UXTB *)
        notimplemented_thumb s isn "UXTB"
     | 0b001100 | 0b001101 | 0b001110 | 0b001111 -> (* Compare and Branch on Zero CBNZ, CBZ *)
-       notimplemented_thumb s isn "CBNZ/CBZ (1)"
+      decode_thumb_cbz_cbnz s isn EQ
     | 0b010000 | 0b010001 | 0b010010 | 0b010011 | 0b010100 | 0b010101 | 0b010110 | 0b010111 -> (* Push Multiple Registers PUSH *)
        thumb_push s isn
     | 0b100100 | 0b100101 | 0b100110 | 0b100111 -> (* Compare and Branch on Nonzero CBNZ, CBZ *)
-       notimplemented_thumb s isn "CBNZ/CBZ (2)"
+      decode_thumb_cbz_cbnz s isn NEQ
     | 0b101000 -> (* Byte-Reverse Word REV *)
-       notimplemented_thumb s isn "REV"
+       let rd = isn land 7 in
+       let rm = isn lsr 3 land 0x7 in
+       rev s rd rm |> mark_as_isn
+       (* notimplemented_thumb s isn "REV" *)
     | 0b101001 -> (* Byte-Reverse Packed Halfword REV16 *)
        notimplemented_thumb s isn "REV16"
     | 0b101011 -> (* Byte-Reverse Signed Halfword REVSH *)
        notimplemented_thumb s isn "REVSH"
     | 0b101100 | 0b101101 | 0b101110 | 0b101111 -> (* Compare and Branch on Nonzero CBNZ, CBZ *)
-       notimplemented_thumb s isn "CBNZ/CBZ (3)"
+      decode_thumb_cbz_cbnz s isn NEQ
     | 0b110000 | 0b110001 | 0b110010 | 0b110011 | 0b110100 | 0b110101 | 0b110110 | 0b110111 -> (* Pop Multiple Registers POP *)
        thumb_pop s isn
     | 0b111000 | 0b111001 | 0b111010 | 0b111011 -> (* Breakpoint BKPT *)
        notimplemented_thumb s isn "BKPT"
     | 0b111100 | 0b111101 | 0b111110 | 0b111111 -> (* If-Then and hints *)
        decode_thumb_it_hints s isn
-    | _ ->  L.abort (fun p -> p "Unknown thumb misc encoding %04x" isn)
+    | _ -> error_isn s.a isn "Unkown  thumb misc encoding"
 
 
   let thumb_mov_imm _s isn =
@@ -1174,6 +1299,29 @@ struct
       MARK_FLAG (Set (V (T zflag), const (if imm = 0 then 1 else 0) 1)) ;
       MARK_FLAG (Set (V (T nflag), const (imm lsr 31) 1)) ; ]
 
+  let thumb32_mov_imm _s isn isn2 =
+    (* imm = isn<10>:isn2<14-12>:isn2<7-0>*)
+    let imm = ((isn lsr 10 land 1) lsl 11) lor (((isn2 lsr 12) land 7) lsl 8) lor (isn2 land 0xff) in
+    (* In some case MOVT or MOV (T3) imm = isn<3-0>:imm *)
+    let imm = if isn lsr 9 land 1 = 1 then (isn land 0xf) lsl 12 lor imm else imm in
+    let setflags = (isn lsr 4 land 1) = 1 in
+    (* rd = isn2<11-8>*)
+    let rd = isn2 lsr 8 land 0xf in
+    let dest, cst_size =
+      if isn lsr 7 land 1 = 1 then (* MOVT *)
+        (preg rd 16 31), 16
+      else
+        (treg rd), 32
+      in
+    let flags_stmts =
+      if setflags then
+        [
+          MARK_FLAG (Set (V (T zflag), const (if imm = 0 then 1 else 0) 1));
+          MARK_FLAG (Set (V (T nflag), const (imm lsr 31) 1 ));
+        ]
+      else [] in
+    [MARK_ISN (Set (V dest, const imm cst_size));] @ flags_stmts
+
   let thumb_cmp_imm _s isn =
     let rn = (isn lsr 8) land 7 in
     let imm = isn land 0xff in
@@ -1198,7 +1346,7 @@ struct
             op_add (reg rd) rn (const rm_or_imm3 32)
          | 0b11 -> (* Subtract 3-bit immediate SUB (immediate, Thumb) *)
             op_sub (reg rd) rn (const rm_or_imm3 32)
-         | _ -> L.abort (fun p -> p "Unknown encoding %04x" isn)
+         | _ ->  error_isn s.a isn "Unkown encoding"
        end |> mark_couple
     | 0b000 -> (* Logical Shift Left LSL (immediate) *)
        let shift = (isn lsr 6) land 0x1f in
@@ -1236,7 +1384,7 @@ struct
        let rdn = (isn lsr 8) land 7 in
        let imm8 = isn land 0xff in
        op_sub (reg rdn) rdn (const imm8 32) |> mark_couple
-    | _ -> L.abort (fun p -> p "Unknown encoding %04x" isn)
+    | _ -> error_isn s.a isn "Unkown encoding"
 
 
   let thumb_cond_branching _s isn =
@@ -1258,7 +1406,7 @@ struct
   let decode_thumb_branching_svcall s isn =
     match isn lsr 8 land 0xf with
     | 0b1110 -> (* Permanently UNDEFINED *)
-       L.abort (fun p -> p "Thumb16 instruction %04x permanently undefined" isn)
+      error_isn s.a isn "Permanently undefined"
     | 0b1111 -> (* Supervisor Call *)
        notimplemented_thumb s isn "SVC"
     | _ -> (* Conditional branch *)
@@ -1270,36 +1418,49 @@ struct
     let jump_pc = if rd = 15 then [ Jmp (R (Lval (V (T pc)))) ] else [] in
     [ Set (V (treg rd), Lval (V (treg rm))) ] @ jump_pc |> mark_as_isn
 
-  let thumb_bx _s isn =
+  let thumb_bx_blx _s isn =
     let rm = (isn lsr 3) land 0xf in
-    [ Set (V (T tflag), Lval (V (preg rm 0 0))) ;
+    let set_lr =
+      if isn lsr 7 land 1 = 1 then (* BLX *)
+        (* LR = (PC-2)<31:1>:1 *)
+        [Set (V (T lr), BinOp(Or, BinOp(Add, Lval (V (T pc)), const 0xfffffffe 32), const 1 32))]
+      else (* BX *)
+        []
+    in
+    set_lr @ [
+     Set (V (T tflag), Lval (V (preg rm 0 0))) ;
       Set (V (T pc), BinOp (And, Lval (V (treg rm)), const 0xfffffffe 32)) ;
       Jmp (R (Lval (V (T pc)))) ] |> mark_as_isn
 
-  let decode_thumb32_mov s isn =
-    let str2 = String.sub s.buf 2 2 in
-    let isn2 = build_thumb16_instruction s str2 in
-    L.debug (fun p->p "decode_thumb_mov_low 0x%x 0x%x" isn isn2);
-    let rm = isn2 land 0xF in
-    let rd = (isn2 lsr 8) land 0xF in
-    let jump_pc = if rd = 15 then [ Jmp (R (Lval (V (T pc)))) ] else [] in
-    [ Set (V (treg rd), Lval (V (treg rm))) ] @ jump_pc |> mark_as_isn
 
   let decode_thumb_special_data_branch_exch s isn =
     match (isn lsr 6) land 0xf with
-    | 0b000 | 0b0001 | 0b0010 | 0b0011 -> (* Add High Registers ADD (register) *)
-       let rd = ((isn lsr 4) land 0x8) lor (isn land 0x7) in
-       let rm = (isn lsr 3) land 0xf in
-       op_add (reg rd) rm (Lval (V (treg rd))) |> mark_couple
+    | 0b0000 | 0b0001 | 0b0010 | 0b0011 -> (* ADD *)
+      let rm = isn lsr 3 land 0xf in
+      let rd = ((isn lsr 7 land 1) lsl 3) lor (isn land 7) in
+      let stmts, _ = op_add (reg rd) rm (Lval (V (treg rd))) in
+      stmts |> mark_as_isn
     | 0b0101 | 0b0110 | 0b0111 -> (* Compare High Registers CMP (register) *)
-       notimplemented_thumb s isn "CMP (high reg)"
-    | 0b1000 | 0b1001 | 0b1010 | 0b1011 -> (* Move High Registers MOV (register) *)
+      let rn = (((isn lsr 7) land 1) lsl 3) lor (isn land 7) in
+      let rm = (isn lsr 3) land 0xf in
+      let shift_t, shift_n = decode_imm_shift 0 0 in
+      let shifted = decode_shift rm shift_t shift_n (Lval (V (T cflag))) in
+      let tmpreg = Register.make (Register.fresh_name ()) 32 in
+      let opstmts, flagstmts = op_add tmpreg rn (UnOp(Not, shifted)) in
+      mark_as_isn (opstmts @ flagstmts @ [ Directive (Remove tmpreg) ])
+       (* notimplemented_thumb s isn "CMP (high reg)" *)
+    | 0b1000 -> (* Move Low Registers MOV (register) *)
+      let rd = ((isn land 0x80) lsr 4) lor (isn land 0x7) in
+      let rm = (isn lsr 3) land 0xf in
+      [MARK_ISN (Set (V (treg rd), Lval (V (treg rm))))]
+       (* notimplemented_thumb s isn "MOV (low reg)" *)
+    | 0b1001 | 0b1010 | 0b1011 -> (* Move High Registers MOV (register) *)
        thumb_mov_high_reg s isn
     | 0b1100 | 0b1101 -> (* Branch and Exchange BX *)
-       thumb_bx s isn
+      thumb_bx_blx s isn
     | 0b1110 | 0b1111 -> (* Branch with Link and Exchange BLX *)
-       notimplemented_thumb s isn "BLX"
-    | _ -> L.abort (fun p -> p "Unknown or unpredictable instruction %04x" isn)
+      thumb_bx_blx s isn
+    | _ -> error_isn s.a isn "Unknown or unpredictable instruction"
 
   let thumb_mul _s isn =
     let rn = (isn lsr 3) land 7 in
@@ -1343,8 +1504,10 @@ struct
        op_rsb (reg op0) op1 (const 0 32) |> mark_couple
     | 0b1010 -> (* CMP Compare Registers *)
        let tmpreg = Register.make (Register.fresh_name ()) 32 in
-       let opstmts,flagstmts = op_sub tmpreg op0 (Lval (V (treg op1))) in
+       let opstmts,flagstmts = op_add tmpreg op0 (UnOp(Not, Lval (V (treg op1)))) in
+       (* let opstmts,flagstmts = op_sub tmpreg op0 (Lval (V (treg op1))) in *)
        mark_as_isn (opstmts @ flagstmts @ [ Directive (Remove tmpreg) ])
+
     | 0b1011 -> (* CMN Compare Negative *)
        let tmpreg = Register.make (Register.fresh_name ()) 32 in
        let opstmts,flagstmts = op_add tmpreg op0 (Lval (V (treg op1))) in
@@ -1357,7 +1520,7 @@ struct
        op_bic (reg op0) op0 (Lval (V (treg op1))) |> mark_couple
     | 0b1111 -> (* MVN Bitwise NOT *)
        op_mvn (reg op0) (Lval (V (treg op1))) |> mark_couple
-    | _ -> L.abort (fun p -> p "internal error")
+    | _ -> error_isn s.a isn "Internal error"
 
   let thumb_ldr _s isn =
     let rt = (isn lsr 8) land 7 in
@@ -1369,7 +1532,7 @@ struct
                            const (imm lsl 2) 32),
                     32))) ] |> mark_as_isn
 
-  let decode_thumb_load_store_single_data_item _s isn =
+  let decode_thumb_load_store_single_data_item s isn =
     let stmts =
       match (isn lsr 12) land 0xf with
       | 0b0101 ->
@@ -1395,7 +1558,7 @@ struct
               [ Set (V (treg rt), UnOp( ZeroExt 32, Lval (M (ofs, 8)))) ]
            | 0b111 -> (* LDRSH (register) Load Register Signed Halfword *)
               [ Set (V (treg rt), UnOp( SignExt 32, Lval (M (ofs, 16)))) ]
-           | _ -> L.abort (fun p -> p "Internal error")
+           | _ -> error_isn s.a isn "Internal error (2)"
          end
       | 0b1001 ->
          let imm8 = isn land 0xff in
@@ -1425,45 +1588,124 @@ struct
               [ Set (M (ofs 1, 16), Lval (V (preg rt 0 15))) ]
            | 0b10001 -> (* LDRH (immediate) Load Register Halfword *)
               [ Set (V (treg rt), UnOp(ZeroExt 32, Lval (M (ofs 1, 16)))) ]
-           | _ -> L.abort (fun p -> p "Internal error")
+           | _ -> error_isn s.a isn "Internal error (3)"
          end in
     mark_as_isn stmts
 
 
+  (* THUMB 32 utilities *)
+  let decode_thumb32_imm12 imm12 =
+    if (imm12 lsr 10) = 0 then
+      let imm8 = imm12 land 0xff in
+      match (imm12 lsr 8) land 3 with
+        | 0b00 -> const imm12 32
+        | 0b01 -> const ((imm8 lsl 16) lor imm8) 32 (* 00000000 : imm8 : 00000000 : imm8  *)
+        | 0b10 -> const ((imm8 lsl 24) lor (imm8 lsl 8)) 32 (* imm8 : 00000000 : imm8 : 00000000 *)
+        | 0b11 -> const ((imm8 lsl 24) lor (imm8 lsl 16) lor (imm8 lsl 8) lor imm8) 32
+        | _ -> L.abort(fun p -> p "Unreachable")
+    else
+      (* ror_stmt *)
+      let unrotated_value = (1 lsl 7) lor (imm12 land 0x3f) in
+      ror_stmt (const unrotated_value 32) (imm12 lsr 7)
+
+  let decode_thumb32_cmp_stmts rn value =
+    let tmpreg = Register.make (Register.fresh_name ()) 33 in
+    [
+      MARK_ISN(Set( V (T tmpreg), BinOp(Add, to33bits (Lval (V (treg rn))),
+                                      to33bits(BinOp(Add, value,
+                                                    const 1 32))))) ;
+      MARK_FLAG( zflag_update_exp (Lval (V (P (tmpreg, 0, 31)))));
+      MARK_FLAG( nflag_update_exp tmpreg );
+      MARK_FLAG(vflag_update_exp  (Lval (V (treg rn))) value (Lval (V (P (tmpreg, 0, 31)))));
+      MARK_ISN(Set (V (T cflag), Lval (V (P (tmpreg, 32, 32)))));
+      MARK_ISN(Directive (Remove tmpreg))
+    ]
+
+
+  let decode_thumb32_cmp_imm _s isn isn2 =
+    let rn = isn land 0xf in
+    (* imm = isn<10>:isn2<14-12>:isn2<7-0> *)
+    let imm = (((isn lsr 10) land 1) lsl 11) lor (((isn2 lsr 12) land 7) lsl 8) lor (isn2 land 0xff) in
+    let decoded_imm = decode_thumb32_imm12 imm in
+    decode_thumb32_cmp_stmts rn (UnOp(Not, decoded_imm))
+
+  let decode_thumb32_cmp_reg _s isn isn2 =
+    (* for CMP or CMN reg *)
+    let rm = isn2 land 0xf in
+    let rn = isn land 0xf in
+    let shift_type = isn2 lsr 4 land 3 in
+    let shift_amount = ((isn2 lsr 12 land 0x7) lsl 2) lor (isn2 lsr 6) land 3 in
+    let shift_t, shift_n = decode_imm_shift shift_type shift_amount in
+    let shift = decode_shift rm shift_t shift_n (Lval (V (T cflag))) in
+    let shifted =
+      if isn lsr 5 land 1 = 1 (* CMP *) then
+        UnOp(Not, shift)
+      else (* CMN *)
+        shift
+      in
+    decode_thumb32_cmp_stmts rn shifted
+
   let decode_thumb32_data_proc_shift_reg s isn isn2 =
     let op = (isn lsr 5) land 0xf in
     let rn = isn land 0xf in
+    let rm = isn2 land 0xf in
+    let shift_type = (isn2 lsr 4) land 3 in
+    (* imm5 : <isn2:14-12>:<isn2:7-6> *)
+    let shift_amount = (((isn2 lsr 11) land 7) lsl 2) land ((isn2 lsr 5) land 3) in
+    let shift_t, shift_n = decode_imm_shift shift_type shift_amount in
+    let shifted, carry_out = decode_shift_carry rm shift_t shift_n (Lval (V (T cflag))) in
+    let rd = (isn2 lsr 0x8) land 0xf in
     let tst = (isn lsr 4) land 1 in
     match op with
     | 0b0000 ->
-       if tst = 0 then (* Bitwise AND AND (register) *)
-         notimplemented_thumb s isn "AND (register)"
-       else (* TST (register) *)
-         notimplemented_thumb s isn "TST (register)"
+      if tst = 1 && rd = 15 then (* TST (register) *)
+        notimplemented_thumb s isn "TST (register)"
+      else ( (* AND (register) *)
+        let stmts, flags = op_and (reg rd) rn shifted in
+        let flags = if tst = 1 then (mark_as_flag flags) @ [ MARK_FLAG(set_cflag_from_carry_out carry_out) ] else [] in
+        (mark_as_isn stmts) @ flags
+         (* notimplemented_thumb s isn "AND (register)" *)
+      )
     | 0b0001 -> (* Bitwise Bit Clear BIC (register) *)
-       notimplemented_thumb s isn "BIC (register)"
+      let stmts, flags = op_bic (reg rd) rn shifted in
+      let flags = if tst = 1 then (mark_as_flag flags) @ [ MARK_FLAG(set_cflag_from_carry_out carry_out)] else [] in
+      (mark_as_isn stmts) @ flags
+
     | 0b0010 ->
        if rn = 0xf then (* Move MOV (register) *)
-         notimplemented_thumb s isn "ORR (register)"
+         notimplemented_thumb s isn "MOV (from ORR) (register)"
        else (* Bitwise OR ORR (register) *)
-         notimplemented_thumb s isn "ORR (register)"
+        let result = BinOp(Or, Lval (V (treg rn)), shifted) in
+        let stmts = [ Set (V (treg rd), result) ] in
+        if tst = 0 then
+          mark_as_isn stmts
+        else
+          (mark_as_isn stmts) @ [
+            MARK_FLAG(zflag_update_exp result) ;
+            MARK_FLAG(nflag_update_exp (reg rd)) ;
+            MARK_FLAG(set_cflag_from_carry_out carry_out)
+          ]
     | 0b0011 ->
        if rn = 0xf then (* Bitwise NOT MVN (register) *)
          notimplemented_thumb s isn "MVN (register)"
        else (* Bitwise OR NOT ORN (register) *)
          notimplemented_thumb s isn "ORN (register)"
     | 0b0100 ->
-       if tst = 0 then (* Bitwise Exclusive OR EOR (register) *)
-         notimplemented_thumb s isn "EOR (register)"
-       else (* Test Equivalence TEQ (register) *)
-         notimplemented_thumb s isn "TEQ (register)"
+      if tst = 1 && rd = 15 then
+        notimplemented_thumb s isn "TEQ (register)"
+      else (* EOR (register) *)
+        let stmts, flags = op_eor (reg rd) rn shifted in
+        let flags = if tst = 1 then (mark_as_flag flags) @ [MARK_FLAG(set_cflag_from_carry_out carry_out)] else [] in
+        (mark_as_isn stmts) @ flags
+
     | 0b0110 -> (* Pack Halfword PKH *)
        notimplemented_thumb s isn "PKH"
     | 0b1000 ->
        if tst = 0 then (* Add ADD (register) *)
-         notimplemented_thumb s isn "ADD (register)"
+        [Set (V (treg rd), BinOp(Add, Lval (V (treg rn)), shifted)) ] |> mark_as_isn
+         (* notimplemented_thumb s isn "ADD (register)" *)
        else (* Compare Negative CMN (register) *)
-         notimplemented_thumb s isn "CMN (register)"
+         decode_thumb32_cmp_reg s isn isn2
     | 0b1010 -> (* Add with Carry ADC (register) *)
        notimplemented_thumb s isn "ADC (register)"
     | 0b1011 -> (* Subtract with Carry SBC (register) *)
@@ -1472,12 +1714,10 @@ struct
        if tst = 0 then (* Subtract SUB (register) *)
          notimplemented_thumb s isn "SUB (register)"
        else (* Compare CMP (register) *)
-         notimplemented_thumb s isn "CMP (register)"
+         decode_thumb32_cmp_reg s isn isn2
     | 0b1110 -> (* Reverse Subtract RSB (register) *)
        notimplemented_thumb s isn "RSB (register)"
-    | _ -> L.abort (fun p -> p "Unexpected thumb32 encoding %04x %04x" isn isn2)
-
-
+    | _ -> error_isn s.a isn ~isn2:isn2 "Unexpected thumb encoding (2)"
 
   let thumb32_bl_blx_immediate _s isn isn2 =
     let immh = isn land 0x3ff in
@@ -1522,114 +1762,88 @@ struct
               if op1 = 0 then
                 notimplemented_thumb s isn "SMC"
               else
-                L.abort (fun p -> p "permanently undefined thumb32 instruction %04x %04x" isn isn2)
-           | _ -> L.abort (fun p -> p "unexpected thumb32 encoding %04x %04x" isn isn2)
-         else (* Conditional branch *)
-           notimplemented_thumb s isn "conditional branch"
+                error_isn s.a isn ~isn2:isn2 "permanently undefined thumb32 instruction"
+           | _ -> error_isn s.a isn ~isn2:isn2 "Unexpected thumb encoding (3)"
+         else (* Conditional branch *) (
+           let cond = (isn lsr 6) land 0xf in
+           let bit_s = (isn lsr 10) land 1 in
+           let imm = (bit_s lsl 20) lor (((isn2 lsr 11) land 1) lsl 19) lor (((isn2 lsr 13) land 1) lsl 18) lor ((isn land 0x3f) lsl 12) lor ((isn2 land 0x7ff) lsl 1) in
+           let s_imm = sconst imm 21 32 in
+            let branching = [
+              Set (V (T pc),
+                  BinOp(Add, Lval (V (T pc)), s_imm)) ;
+                  Jmp (R (Lval (V (T pc))))
+            ] in
+            [ If (asm_cond cond, branching, []) ] |> mark_as_isn
+         )
        end
-    | 0b001 | 0b011 -> notimplemented_thumb s isn "B"
+    | 0b001 | 0b011 -> (* B - T4 *)
+       let s_bit = isn lsr 10 land 1 in
+       let i1 = (((isn2 lsr 13) land 1) lxor s_bit) lxor 1 in (* i1 = NOT (<isn2:13> xor <isn:10>) *)
+       let i2 = (((isn2 lsr 11) land 1) lxor s_bit) lxor 1 in
+       (* imm : <isn:10>:<i1>:<i2>:<isn:9-0>:<isn2:10-0> *)
+       let imm = (s_bit lsl 24) lor (i1 lsl 23) lor (i2 lsl 22) lor ((isn land 0x3ff) lsl 12) lor ((isn2 land 0x7ff) lsl 1)  in
+       let s_imm = sconst imm 25 32 in
+       [ Set(V (T pc), BinOp(Add, Lval (V (T pc)), s_imm));
+         Jmp (R (Lval (V (T pc))))
+       ] |> mark_as_isn
+
     | 0b100 | 0b110 | 0b101 | 0b111 -> (* BL, BLX *)
        thumb32_bl_blx_immediate s isn isn2
-    | _ -> L.abort (fun p -> p "unexpected thumb32 encoding %04x %04x" isn isn2)
-
-  let ror_c_imm32 imm n _c =
-    let m = n mod 32 in
-    let result = (imm lsr m) lor (imm lsl (32-m)) in
-    (result land 0xFFFFFFFF, (result lsr 31) land 1)
-
-
-  let thumb_expand_imm_c imm12 c =
-    L.debug (fun p->p "thumb_expand_imm_c 0x%x" imm12);
-    let imm8 = imm12 land 0xFF in
-    if (imm12 lsr 10) land 3 = 0 then
-        let op = ((imm12 lsr 8) land 3) in
-        if op != 0 && imm8 = 0 then
-            L.abort (fun p->p "thumb_expand_imm_c: unpredictable")
-        else
-            let imm32 =
-                match op with
-                | 0b00 -> const imm8 32
-                | 0b01 -> const ((imm8 lsl 16) lor imm8) 32
-                | 0b10 -> const ((imm8 lsl 24) lor (imm8 lsl 8)) 32
-                | 0b11 -> const ((imm8 lsl 24) lor (imm8 lsl 16)
-                                 lor (imm8 lsl 8) lor imm8) 32
-                | _ -> L.abort (fun p -> p "Impossible state")
-            in
-            L.debug (fun p->p "thumb_expand_imm_c ret %s" (Asm.string_of_exp imm32 true));
-            (imm32, c)
-    else
-        let unrot = 0b10000000 lor (imm12 land 0x7F) in
-        let rot, c = ror_c_imm32 unrot (imm12 lsr 7) c in
-        (const rot 32, c)
+    | _ ->  error_isn s.a isn ~isn2:isn2 "Unexpected thumb encoding (4)"
 
+  let decode_thumb32_multiple_store _ _ ins2 =
+    (* TODO(dm) TEST ME: http://class.ece.iastate.edu/cpre288/resources/docs/Thumb-2SupplementReferenceManual.pdf *)
+    let reglist = (ins2 land 0x4000) lor (ins2 land 0xfff) in (* registers: '0':M:'0':reg_list *)
+    let stmts = ref [] in
+    let bitcount = ref 0 in
+    for i = 14 downto 0 do
+      if (reglist lsr i) land 1 = 1 then
+        begin
+          bitcount := !bitcount+4;
+          let stmt = Set (M (BinOp(Sub, Lval (V (T sp)), const !bitcount 32), 32),
+                          Lval (V (treg i))) in
+          stmts := stmt :: (!stmts)
+        end
+    done;
+    (!stmts) @ [ Set (V (T sp), BinOp(Sub, Lval (V (T sp)), const !bitcount 32)) ] |> mark_as_isn
 
-  let thumb32_mov rd rn _bit_s imm12 =
-    let imm32, _ = thumb_expand_imm_c imm12 0 (* TODO: carry *) in
-    if rn = 0xF then
-        [ MARK_ISN (Set (V (treg rd), imm32)) ]
-    else
-        [ MARK_ISN (Set (V (treg rd), BinOp(Or, Lval(V (treg rn)), imm32))) ]
-
-  let thumb32_add_cmn rd rn _bit_s imm12 =
-    let imm32, _ = thumb_expand_imm_c imm12 0 (* TODO: carry *) in
-    if rn = 0xF then
-        [ MARK_ISN (Set (V (treg rd), BinOp(Sub, Lval(V (treg rn)), imm32))) ]
-    else
-        [ MARK_ISN (Set (V (treg rd), BinOp(Add, Lval(V (treg rn)), imm32))) ]
-
-  let thumb32_sub_cmp rd rn _bit_s imm12 =
-    let imm32, _ = thumb_expand_imm_c imm12 0 (* TODO: carry *) in
-    if rn = 0xF then
-        [ MARK_ISN (Set (V (treg rd), imm32)) ]
-    else
-        [ MARK_ISN (Set (V (treg rd), BinOp(Sub, Lval(V (treg rn)), imm32))) ]
+    let decode_thumb32_multiple_load _ _ isn2 = (* TODO(dm) CHECK ME*)
+      let reglist = ((isn2 lsl 7) land 0xc000) lor (isn2 land 0xfff) in (* reglist = bit15(P):bit14(M):0:bit12-0  *)
+      let stmts = ref [] in
+      let bitcount = ref 0 in
+      for i = 0 to 15 do
+        if (reglist lsr i) land 1 = 1 then
+          begin
+            let stmt = Set (V (treg i),
+                            Lval (M (BinOp(Add, Lval (V (T sp)), const !bitcount 32), 32))) in
+            bitcount := !bitcount+4;
+            stmts := stmt :: (!stmts)
+          end
+      done;
 
+      (!stmts) @ [ Set (V (T sp), BinOp(Add, Lval (V (T sp)), const !bitcount 32)) ] |>  mark_as_isn
 
-  let decode_thumb32_data_mod_imm s isn isn2 =
-    let op = (isn lsr 5) land 0xf in
-    let bit_s = (isn lsr 1) land 1 in
+  let decode_thumb32_add _s isn isn2 =
+    (* Decode ADD (immediate) / ADD (SP) / CMN *)
     let rn = isn land 0xf in
-    let rd = (isn2 lsr 8) land 0xf in
-    let imml = isn2 land 0xff in
-    let immh = (isn2 lsr 12) land 0b111 in
-    let imm12 = (immh lsl 8) lor imml lor ((isn land 0x400) lsl 1) in
-    L.debug (fun p->p "decode_thumb32_data_mod_imm 0x%x 0x%x 0x%x" isn isn2 imm12);
-    match op with
-    | 0b0000 -> notimplemented_thumb s isn "thumb32 AND/TST"
-    | 0b0001 -> notimplemented_thumb s isn "thumb32 BIC"
-    | 0b0010 -> thumb32_mov rd rn bit_s imm12
-    | 0b0011 -> notimplemented_thumb s isn "thumb32 OR/NOR"
-    | 0b0100 -> notimplemented_thumb s isn "thumb32 XOR/TST"
-    | 0b1000 -> thumb32_add_cmn rd rn bit_s imm12
-    | 0b1010 -> notimplemented_thumb s isn "thumb32 addc"
-    | 0b1011 -> notimplemented_thumb s isn "thumb32 subc"
-    | 0b1101 -> thumb32_sub_cmp rd rn bit_s imm12
-    | 0b1110 -> notimplemented_thumb s isn "thumb32 revsub"
-    | _ -> L.abort (fun p -> p "Unexpected thumb32 encoding")
-
-  let decode_thumb32_store_single s isn isn2 =
-    let op1 = (isn lsr 5) land 7 in
-    let op2msb = (isn2 lsr 11) land 1 in
-    let rn = (isn land 0xF) in
-    let rt = ((isn2 lsr 12) land 0xF) in
-    match (op1, op2msb) with
-    | (0b100, _) -> notimplemented_thumb s isn "STRB imm"
-    | (0, 1) -> let index  = ((isn2 lsr 10) land 1) = 1 in
-                let op = if ((isn2 lsr 9) land 1) = 1 then Add else Sub in
-                let wback  = ((isn2 lsr 8) land 1) = 1 in
-                let imm32 = const (isn2 land 0xFF) 32 in
-                let offset_addr = BinOp(op, Lval(V (treg rn)), imm32) in
-                let address = if index then offset_addr else Lval(V( treg rn)) in
-                let wback_stmts = if wback then [MARK_ISN(Set(V(treg rn), offset_addr))] else [] in
-                let store = MARK_ISN(Set(M(address, 8), Lval(V (preg rt 0 7)))) in
-                [store] @ wback_stmts
-    | (0, 0) -> notimplemented_thumb s isn "STRB reg"
-    | (0b101, _) | (0b001, 1) -> notimplemented_thumb s isn "STRH imm"
-    | (0b001, 0) -> notimplemented_thumb s isn "STRH reg"
-    | (0b110, _) | (0b010, 1) -> notimplemented_thumb s isn "STR imm"
-    | (0b010, 0) -> notimplemented_thumb s isn "STR reg"
-    | _ -> L.abort (fun p -> p "Unexpected thumb32 encoding")
+    let rd = (isn2 lsr 0x8) land 0xf in
+    let test = ((isn lsr 0x4) land 1) = 1 in
+    (* imm12 = isn<10>:isn2<14-12>:isn2<7-0> *)
+    let imm12 = (((isn lsr 10) land 1) lsl 11) lor (((isn2 lsr 12) land 0x7) lsl 0x8) lor (isn2 land 0xff) in
+    let decoded_imm = decode_thumb32_imm12 imm12 in
+    let stmts, flags = op_add (reg rd) rn decoded_imm in
+    if test then
+      if rd = 15 then (* CMN: discard the results *)
+        flags |> mark_as_isn
+      else
+        stmts @ flags |> mark_as_isn
+    else
+      stmts |> mark_as_isn
 
+  let offset_addr_computation updown_bit src cst =
+    let updown = if updown_bit = 0 then Sub else Add in
+    BinOp(updown, Lval (V (treg src)), cst)
 
   let decode_thumb32 s isn isn2 =
     let op1 = (isn lsr 11) land 3 in
@@ -1637,36 +1851,112 @@ struct
     let op = isn2 lsr 15 in
     match op1 with
     | 0b01 ->
-       if op2 land 0x64 = 0 then (* Load/store multiple *)
-         notimplemented_thumb s isn "thumb32 load/store multible"
+       if op2 land 0x64 = 0 then ((* Load/store multiple *)
+        if op2 land 1 = 1 then
+          decode_thumb32_multiple_load s isn isn2
+        else
+          decode_thumb32_multiple_store s isn isn2
+       )
        else if op2 land 0x64 = 4 then (* Load/store dual, load/store exclusive, table branch *)
-         notimplemented_thumb s isn  "load/store dual/excl, table branch"
+        let rn = isn land 0xf in
+        let rt = (isn2 lsr 12) land 0xf in
+        let rt2 = (isn2 lsr 8) land 0xf in
+        let imm32 = const ((isn2 land 0xff) lsl 2) 32 in
+        let index = ((isn lsr 8) land 1) = 1 in
+        let updown = (isn lsr 7) land 1 in
+        let wback = ((isn lsr 5) land 1) = 1 in
+        let address = if index then offset_addr_computation updown rn imm32 else Lval (V (treg rn)) in
+        let stmts = [
+          Set (M (address, 32), Lval (V (treg rt))) ;
+          Set (M (BinOp(Add, address, const 32 32), 32), Lval (V (treg rt2))) ; (* we set Mem[address+4, 4]*)
+        ] in
+        if wback then
+          stmts @ [ Set(V (treg rn), address) ] |> mark_as_isn
+        else
+          stmts |> mark_as_isn
+         (* notimplemented_thumb s isn  "load/store dual/excl, table branch" *)
        else if op2 land 0x60 = 0x20 then (* Data-processing (shifted register) *)
          decode_thumb32_data_proc_shift_reg s isn isn2
        else if op2 land 0x40 = 40 then (* Coprocessor instructions *)
          notimplemented_thumb s isn "Coprocessor instructions"
-       else L.abort (fun p -> p "Unexpected thumb32 encoding %04x %04x" isn isn2)
+       else  error_isn s.a isn ~isn2:isn2 "Unexpected thumb encoding (5)"
     | 0b10 ->
        if op = 1 then (* Branches and miscellaneous control *)
          decode_thumb32_branches_misc s isn isn2
-       else
-         if op2 land 0x20 = 0 then (* Data-processing (modified immediate) *)
-           decode_thumb32_data_mod_imm s isn isn2
-         else (* Data-processing (immediate) *)
-           notimplemented_thumb s isn "Data-processing (plain binary immediate)"
+       else (
+        let op2 = op2 lsr 1 in
+        match op2 with
+        | 0b011100 -> notimplemented_thumb s isn "MSR (register)"
+        | 0b011111 -> notimplemented_thumb s isn "MRS"
+        | 0b010110|0b110110 -> thumb32_mov_imm s isn isn2 (* MOVT *)
+        | 0b010010|0b110010|0b000010|0b100010 -> thumb32_mov_imm s isn isn2 (* MOV (immediate) *)
+        | 0b000100|0b100100 -> notimplemented_thumb s isn "EOR (immediate)"
+        | 0b011101 -> notimplemented_thumb s isn "DSB/DMB/DBG/CPS/CLREX/ISB"
+        | 0b001101|0b101101 ->
+          decode_thumb32_cmp_imm s isn isn2 (* CMP.W for imm *)
+        | 0b001000|0b101000 -> decode_thumb32_add s isn isn2 (*CMN / ADD(SP+) / ADD(immediate) *)
+        | 0b000001|0b100001 -> notimplemented_thumb s isn "BIC"
+        | 0b011011 -> notimplemented_thumb s isn "BFI/BFC"
+        | 0b000000|0b100000 -> notimplemented_thumb s isn "AND (immediate)"
+        | 0b010000|0b110000|0b010101|0b110101 -> decode_thumb32_add s isn isn2 (* CMN/ADD(immediate)/ADD(SP+)*)
+        | 0b001010|0b101010 -> notimplemented_thumb s isn "ADC (immediate)"
+        | _ -> error_isn s.a isn ~isn2:isn2 "Failed to decode the instruction"
+      )
     | 0b11 ->
+      let rn = isn land 0xf in
+      let rt = (isn2 lsr 12) in
        if op2 land 0x71 = 0 then (* Store single data item *)
-         decode_thumb32_store_single s isn isn2
+        let imm12 = (isn2 land 0xfff) in
+        let address = BinOp(Add, Lval (V (treg rn)), const imm12 32) in
+        [
+          Set (M (address, 8), Lval (V (preg rt 0 7)))
+        ] |> mark_as_isn
+         (* notimplemented_thumb s isn "Store single data item" *)
+
+        else if op2 = 0x21 then (* UXTAH *)
+          let rm = isn2 land 0xf in
+          let rd = isn2 lsr 8 land 0xf in
+          let rotate = (isn2 lsr 4 land 3) lsl 3 in
+          let rotated =
+            if rotate < 24 then
+              Lval (V (preg rm rotate (rotate+15)))
+            else
+              BinOp (Or,
+                     UnOp (ZeroExt 16, Lval (V (preg rm rotate (rotate+7)))),
+                     BinOp (Shl, UnOp (ZeroExt 16, Lval (V (preg rm 0 7))) , const 8 16))
+          in [ Set (V (treg rd),
+                    (UnOp (ZeroExt 32, rotated ))) ] |> mark_as_isn
+
        else if op2 land 0x71 = 0x10 then (* Advanced SIMD element or structure load/store *)
          notimplemented_thumb s isn "Advanced SIMD element or structure load/store"
-       else if op2 land 0x67 = 1 then (* Load byte, memory hints *)
-         notimplemented_thumb s isn "Load byte, memory hints"
+
+       else if op2 land 0x6f = 9 then (* Load byte, memory hints (only T2) *)
+        let imm12 = isn2 land 0xfff in
+
+        let address = BinOp(Add, Lval (V (treg rn)), const imm12 32) in
+        [ Set (V (treg rt), UnOp(ZeroExt 32, Lval(M (address, 8)))) ] |> mark_as_isn
+
        else if op2 land 0x67 = 3 then (* Load halfword, memory hints *)
-         notimplemented_thumb s isn "Load halfword, memory hints"
-       else if op2 land 0x67 = 5 then (* Load word *)
-         notimplemented_thumb s isn "Load word"
+        let rn = isn land 0xf in
+        let rt = isn2 lsr 12 land 0xf in
+        let rm = isn2 land 0xf in
+        let shift_n = isn2 lsr 4 land 3 in
+        let shifted, _ = lsl_c rm shift_n in
+        let address = BinOp(Add, Lval (V (treg rn)), shifted) in
+        [
+          Set(V (treg rt), UnOp(ZeroExt 32, Lval (M (address, 16))))
+        ] |> mark_as_isn
+
+       else if op2 land 0x67 = 5 || op2 land 0x67 = 13 then (* Load word *)
+        let imm12 = isn2 land 0xfff in
+        let u = (isn lsr 7) land 1 in
+        let op = if u = 1 then Add else Sub in
+        let address = BinOp(op, Lval (V (treg rn)), const imm12 32) in
+        [ Set (V (treg rt), Lval (M (address, 32))) ] |> mark_as_isn
+
        else if op2 land 0x67 = 7 then
-         L.abort (fun p -> p "undefined Thumb32 instruction")
+        error_isn s.a isn "Undefined thumb instruction"
+
        else if op2 land 0x70 = 0x20 then (* Data-processing (register) *)
          notimplemented_thumb s isn "Data-processing (register)"
        else if op2 land 0x78 = 0x30 then (* Multiply, multiply accumulate, and absolute difference *)
@@ -1675,8 +1965,18 @@ struct
          notimplemented_thumb s isn "Long multiply, long multiply accumulate, and divide"
        else if op2 land 0x40 = 0x40 then (* Coprocessor instructions *)
          notimplemented_thumb s isn "Coprocessor instructions"
-       else L.abort (fun p -> p "Unexpected thumb32 encoding %04x %04x" isn isn2)
-    | _ -> L.abort (fun p -> p "Unexpected thumb32 encoding")
+
+       else if op2 = 1 then (* LDRB (register) *)
+        let rm = isn2 land 0xf in
+        let _, shift_n = decode_imm_shift 00 (isn2 lsr 4 land 3) in
+        let shifted, _ = lsl_c rm shift_n in
+        let address = BinOp(Add, Lval (V (treg rn)), shifted) in (* Shift left *)
+        [
+          Set (V (treg rt), (UnOp(ZeroExt 32, Lval (M (address, 8)))))
+        ] |> mark_as_isn
+        (* notimplemented_thumb s isn "LDRB (register)" *)
+       else  error_isn s.a isn ~isn2:isn2 "Unexpected thumb encoding (6)"
+    | _ ->  error_isn s.a isn ~isn2:isn2 "Unexpected thumb encoding (7)"
 
   let thumb_generate_pc_relative _s isn =
     let rd = (isn lsr 8) land 7 in
@@ -1732,17 +2032,18 @@ struct
              | 0b010 | 0b011 | 0b100 -> (* Load/store single data item *)
                 (* 0b0100 does not belong here but is taken care of before*)
                 decode_thumb_load_store_single_data_item s instruction
-             | _ -> L.abort (fun p -> p "Unknown thumb encoding %04x" instruction)
+             | _ ->  error_isn s.a instruction "Unexpected thumb encoding (1)"
            end in
     (* pc is 4 bytes ahead in thumb mode because of pre-fetching. *)
     let current_pc = Const (Word.of_int (Z.add (Address.to_int s.a) (Z.of_int 4)) 32) in
     let filtered_stmts =
-      match s.itstate with
-      | None -> L.abort (fun p -> p "Could not obtain a concrete ITSTATE value. Decoding not supported yet in this case")
-      | Some v ->
-         if (v land 0xf) = 0
-         then remove_marks marked_stmts
-         else let next_itstate = if v land 7 = 0 then 0 else (v land 0xf0) lor ((v lsl 1) land 0xf) in
+      let v = match s.itstate with
+        | None -> 0
+        | Some v -> v
+      in if (v land 0xf) = 0 then
+        remove_marks marked_stmts
+      else
+        let next_itstate = if v land 7 = 0 then 0 else (v land 0xf0) lor ((v lsl 1) land 0xf) in
               (wrap_cc (v lsr 4) (remove_marks_keep_isn marked_stmts)) @ [ Set (V (T itstate), const next_itstate 8)] in
     return s instruction (Set( V (T pc), current_pc) :: filtered_stmts)
 
@@ -1769,12 +2070,19 @@ struct
       let v', ip' = decode s in
       Some (v', ip', ())
     with
+      | Exceptions.Failed_decoding (msg, isn) -> (
+        L.debug (fun p -> p "Failed-decoding: %s" msg);
+        let isn_size = if s.thumbmode then 4 else 8 in
+        let current_pc = Const (Word.of_int (Z.add (Address.to_int s.a) (Z.of_int isn_size)) 32) in
+        let v', ip' = (return s isn ([(Set (V (T pc), current_pc))])) in
+        Some (v', ip', ())
+      )
       | Exceptions.Error _ as e -> raise e
       | _  -> (*end of buffer *) None
 
-  let init_registers () = []
-                        
-let init () = Imports.init ()
+let init_registers () = ()
+  let init () =
+    Imports.init ()
 
   let overflow_expression () = Lval (V (T vflag))
 end
diff --git a/ocaml/src/disassembly/armv7Imports.ml b/ocaml/src/disassembly/armv7Imports.ml
index ee221a0c..1425ef9e 100644
--- a/ocaml/src/disassembly/armv7Imports.ml
+++ b/ocaml/src/disassembly/armv7Imports.ml
@@ -46,9 +46,9 @@ struct
     | Config.AAPCS -> aapcs_calling_convention
     | c -> L.abort (fun p -> p "Calling convention [%s] not supported for arm v7 architecture"
                                (Config.call_conv_to_string c))
-    
+
   let get_callconv () = get_local_callconv !Config.call_conv
-                      
+
   let typing_rule_stmts_from_name name =
     try
       let _rule = Hashtbl.find Config.typing_rules name in
@@ -101,7 +101,7 @@ struct
   (** check if fdesc (import description) or a (address) should be skipped
    *  raise Not_found if not
    *  else
-   *    return either a 
+   *    return either a
    *      - *patched* fdesc (stub replaced with 'Skip')
    *      - new minimal fdesc to Skip
    * *)
@@ -128,7 +128,7 @@ struct
            }
          else
            raise Not_found
-    
+
   let init () =
     Stubs.init ();
     init_imports ()
diff --git a/ocaml/src/disassembly/armv8A.ml b/ocaml/src/disassembly/armv8A.ml
index efb5d427..d6e30a42 100644
--- a/ocaml/src/disassembly/armv8A.ml
+++ b/ocaml/src/disassembly/armv8A.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2019 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -162,7 +162,7 @@ struct
       P (reg_from_num n, 0, 31)
 
   module Cfa = Cfa.Make(Domain)
-               
+
   module Imports = Armv8aImports.Make(Domain)(Stubs)
 
   type state = {
@@ -174,9 +174,28 @@ struct
 
   (* fatal error reporting *)
   let error a msg =
-    L.abort (fun p -> p "at %s: %s" (Address.to_string a) msg)
-
-  
+    L.error (fun p -> p "at %s: %s" (Address.to_string a) msg);
+    raise (Exceptions.Failed_decoding ((Printf.sprintf "ERROR: %s" (Address.to_string a)), 0))
+
+  let error_isn (a: Address.t) (isn: int) ?(isn2) (msg: string) =
+    let isn = match isn2 with None -> isn | Some value -> (isn lsl 16 lor value) in
+    L.error (fun p -> p "at %s: isn=%08x %s" (Address.to_string a) isn msg);
+    raise (Exceptions.Failed_decoding ((Printf.sprintf "ERROR_ISN: %d" isn), isn))
+
+  let notimplemented (s: state) (isn: int) (mnemo: string) =
+    L.error (fun p -> p "at %s: %s (%08x): ARMV8 instruction not implemented yet"
+                                                  (Address.to_string s.a) mnemo isn);
+    raise (Exceptions.Failed_decoding ((Printf.sprintf "ARMV8: %s" mnemo), isn))
+
+  let string_to_char_list str =
+    let len = String.length str in
+    let rec process i =
+      if i < len then
+        (String.get str i)::(process (i+1))
+      else
+        []
+    in
+    List.rev (process 0)
 
   let build_instruction (str: string): int =
     (Char.code (String.get str 0))
@@ -250,7 +269,7 @@ struct
     let res = BinOp (Or, high, low) in
     res
 
-  let get_shifted_reg sz insn reg amount =
+  let get_shifted_reg (s: state) (sz: int) (insn: int) (reg: Asm.exp) (amount: int) =
     if amount = 0 then
       reg
     else
@@ -258,9 +277,9 @@ struct
       match shift with
       | 0b00 (* LSL *) -> BinOp(Shl, reg, const amount sz)
       | 0b01 (* LSR *) -> BinOp(Shr, reg, const amount sz)
-      | 0b10 (* ASR XXX *) -> L.abort (fun p->p "shifted reg with ASR not implemented yet");
+      | 0b10 (* ASR XXX *) -> error_isn s.a insn "shifted reg with ASR not implemented yet"
       | 0b11 (* ROR *) -> ror sz reg (const amount sz)
-      | _ -> L.abort (fun p->p "Invalid value for shift")
+      | _ -> error_isn s.a insn "Invalid value for shift"
 
   (* 32 bits ops zero the top 32 bits, this helper does it if needed *)
   let sf_zero_rd rd_v sf s_b =
@@ -410,7 +429,7 @@ struct
     let rd, post = get_Rd_lv rd_v sf_v in
     let rn = get_reg_exp rn_v sf_v in
     let rm = get_reg_exp rm_v sf_v in
-    let shifted_rm =  get_shifted_reg sz insn rm imm6_v in
+    let shifted_rm =  get_shifted_reg s sz insn rm imm6_v in
     (add_sub_core sz rd rn op_v shifted_rm s_b @ sf_zero_rd rd_v sf_v s_b) @ post
 
   (* AND / ORR / EOR / ANDS (32/64) core *)
@@ -451,7 +470,7 @@ struct
     let rd, post = get_Rd_lv ~use_sp:(not flags) rd_v sf_v in
     let rn = get_reg_exp rn_v sf_v in
     let rm = get_reg_exp rm_v sf_v in
-    let shifted_rm = get_shifted_reg sz insn rm imm6_v in
+    let shifted_rm = get_shifted_reg s sz insn rm imm6_v in
     let shifted_rm' = if n_v = 1 then UnOp(Not, shifted_rm) else shifted_rm in
     logic_core sz rd rn opc_v shifted_rm' flags @ sf_zero_rd rd_v sf_v (not flags) @ post
 
@@ -500,7 +519,7 @@ BFM <31:31:sf:F:0,30:29:opc:F:01,28:23:_:F:100110,22:22:N:F:0,21:16:immr:F:xxxxx
 SBFM <31:31:sf:F:0,30:29:opc:F:00,28:23:_:F:100110,22:22:N:F:0,21:16:immr:F:xxxxxx,15:10:imms:F:xxxxxx,9:5:Rn:F:xxxxx,4:0:Rd:F:xxxxx> Signed Bitfield Move
 UBFM <31:31:sf:F:0,30:29:opc:F:10,28:23:_:F:100110,22:22:N:F:0,21:16:immr:F:xxxxxx,15:10:imms:F:xxxxxx,9:5:Rn:F:xxxxx,4:0:Rd:F:xxxxx> Unsigned Bitfield Move
 *)
-  let bitfield insn =
+  let bitfield (s: state) (insn: int) =
     let%decode insn' = insn "31:31:sf:F:0,30:29:opc:F:10,28:23:_:F:100110,22:22:N:F:0,21:16:immr:F:xxxxxx,15:10:imms:F:xxxxxx,9:5:Rn:F:xxxxx,4:0:Rd:F:xxxxx" in
     let sz = sf2sz sf_v in
     let wmask, tmask = decode_bitmasks sz n_v imms_v immr_v in
@@ -524,7 +543,7 @@ UBFM <31:31:sf:F:0,30:29:opc:F:10,28:23:_:F:100110,22:22:N:F:0,21:16:immr:F:xxxx
           (* (top AND NOT(tmask)) OR (bot AND tmask); *)
           [Set(rd, BinOp(Or, BinOp(And, top, UnOp(Not, Const(Word.of_int tmask sz))), BinOp(And, rored, Const(Word.of_int tmask sz))))]
         end
-      | _ -> L.abort (fun p->p "BFM/SBFM not handled yet")
+      | _ -> notimplemented s insn "BFM/SBFM not handled yet"
     in
     res @ sf_zero_rd rd_v sf_v false
 
@@ -550,18 +569,18 @@ UBFM <31:31:sf:F:0,30:29:opc:F:10,28:23:_:F:100110,22:22:N:F:0,21:16:immr:F:xxxx
       | 0b010 | 0b011 -> add_sub_imm s insn sf
       | 0b100         -> logic_imm s insn
       | 0b101 -> mov_wide s insn
-      | 0b110 -> bitfield insn
+      | 0b110 -> bitfield s insn
       | 0b111 -> extr insn
-      | _ -> error s.a (Printf.sprintf "Unknown opcode 0x%x" insn)
+      | _ -> error_isn s.a insn "Unknown opcode"
     in stmts
 
   let data_proc_2src s insn =
     (* XXX *)
-    error s.a (Printf.sprintf "Data processing (2 sources) not decoded yet (0x%x)" insn)
+    notimplemented s insn "Data processing (2 sources) not decoded yet"
 
   let data_proc_1src s insn =
     (* XXX *)
-    error s.a (Printf.sprintf "Data processing (1 source) not decoded yet (0x%x)" insn)
+    notimplemented s insn "Data processing (1 sources) not decoded yet"
 
   (*
 MADD   <31:31:sf:0  30:29:op54:00  28:24:_:11011  23:21:op31:000         20:16:Rm:  15:15:o0:0  14:10:Ra:  9:5:Rn:  4:0:Rd:> Multiply-Add
@@ -577,7 +596,7 @@ UMULH  <31:31:sf:1  30:29:op54:00  28:24:_:11011  23:23:U:1  22:21:_:10  20:16:R
     let%decode insn' = insn "31:31:sf:F:0,30:29:_op54:F:00,28:24:_:F:11011,23:21:op31:F:000,20:16:Rm:F:xxxxx,15:15:o0:F:1,14:10:Ra:F:xxxxx,9:5:Rn:F:xxxxx,4:0:Rd:F:xxxxx" in
     let op = if o0_v = 0 then Add else Sub in
     if sf_v = 0 && (op31_v != 0) then
-      error s.a (Printf.sprintf "invalid instruction 0x%x" insn);
+      error_isn s.a insn "invalid instruction";
     let sz = sf2sz sf_v in
     let tmp = Register.make (Register.fresh_name ()) (sz*2) in
     let u_v = op31_v lsr 2 in
@@ -634,11 +653,11 @@ UMULH  <31:31:sf:1  30:29:op54:00  28:24:_:11011  23:23:U:1  22:21:_:10  20:16:R
         end
       else
         match op2 with
-        | 0 -> error s.a (Printf.sprintf "ADD/SUB with carry not decoded yet (0x%x)" insn)
-        | 2 -> error s.a (Printf.sprintf "cond compare not decoded yet (0x%x)" insn)
-        | 4 -> error s.a (Printf.sprintf "cond select not decoded yet (0x%x)" insn)
+        | 0 -> notimplemented s insn "ADD/SUB with carry"
+        | 2 -> notimplemented s insn "cond compare"
+        | 4 -> notimplemented s insn "cond select"
         | _ when op2 >= 8 && op2 <= 15 -> data_proc_3src s insn
-        | _-> error s.a (Printf.sprintf "invalid opcode (0x%x)" insn)
+        | _-> error_isn s.a insn "invalid opcode"
     end
 
 (*
@@ -655,19 +674,20 @@ STR   <31:30:size:00  29:27:_:111  26:26:V:1  25:24:_:00  23:22:opc:00  21:21:_:
 STR   <31:30:size:10  29:27:_:111  26:26:V:0  25:24:_:00  23:22:opc:00  21:21:_:1  20:16:Rm:  15:13:option:  12:12:S:  11:10:_:10  9:5:Rn:  4:0:Rt:> Store Register (register)
 *)
   (* LDR / STR (register offset) *)
-  let load_store_reg_off insn =
+  let load_store_reg_off (s: state) (insn: int) =
     let%decode insn' = insn "31:30:size:F:10,29:27:_:F:111,26:26:_V:F:0,25:24:_:F:00,23:22:opc:F:00,21:21:_:F:1,20:16:Rm:F:xxxxx,15:13:option:F:xxx,12:12:S:F:x,11:10:_:F:10,9:5:Rn:F:xxxxx,4:0:Rt:F:xxxxx" in
     let mem_sz = match size_v with
       | 0 -> 8
       | 1 -> 16
       | 2 -> 32
       | 3 -> 64
-      | _ -> L.abort (fun p->p "impossible size")
+      | _ -> error_isn s.a insn "impossible size"
     in
     let sf = (size_v land 1) in
     let sz = sf2sz sf in
     let rn = get_reg_lv ~use_sp:true rn_v sf in
     let rt = get_reg_lv rt_v sf in
+    L.info(fun p -> p "Reg are : %s and %s" (string_of_lval rn false) (string_of_lval rt false));
     let shl_amount = if s_v = 1 then size_v else 0 in
     let offset = extend_reg sz rm_v option_v shl_amount in
     let addr = BinOp(Add, Lval rn, offset) in
@@ -699,17 +719,18 @@ STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:00  23:22:opc:00  21:21:_:
 STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:00  23:22:opc:00  21:21:_:0  20:12:imm9:  11:10:_:11  9:5:Rn:  4:0:Rt:> Store Register Halfword (immediate)
 
 *)
-  let load_store_reg_imm insn =
+  let load_store_reg_imm (s: state) (insn: int) =
     let%decode insn' = insn "31:30:size:F:10,29:27:_:F:111,26:26:_V:F:0,25:24:_:F:00,23:22:opc:F:10,21:21:_:F:0,20:12:imm9:F:xxxxxxxxx,11:10:op5:F:01,9:5:Rn:F:xxxxx,4:0:Rt:F:xxxxx" in
     let mem_sz = match size_v with
       | 0 -> 8
       | 1 -> 16
       | 2 -> 32
       | 3 -> 64
-      | _ -> L.abort (fun p->p "impossible size")
+      | _ -> error_isn s.a insn "impossible size"
     in
+    let use_64 = if mem_sz = 3 then 1 else 0 in
     let rn = get_reg_lv ~use_sp:true rn_v 1 in
-    let rt = get_reg_lv rt_v 1 in
+    let rt = get_reg_lv rt_v use_64 in
     let offset = UnOp(SignExt 64, const imm9_v 9) in
     let addr, post = match op5_v with
       (* no index *)
@@ -718,7 +739,7 @@ STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:00  23:22:opc:00  21:21:_:
       | 0b01 -> offset, [Set(rn, BinOp(Add, Lval(rn), offset))]
       (* pre index *)
       | 0b11 -> BinOp(Add, Lval(rn), offset), [Set(rn, BinOp(Add, Lval(rn), offset))]
-      | _ -> L.abort (fun p->p "Impossible value in load_store_pair")
+      | _ -> error_isn s.a insn "Impossible value in load_store_pair"
     in
     if opc_v = 1 then
       (* load *)
@@ -740,14 +761,14 @@ LDRSW <31:30:size:10  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:10  21:10:im
 STRB  <31:30:size:00  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:00  21:10:imm12:  9:5:Rn:  4:0:Rt:> Store Register Byte (immediate)
 STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:00  21:10:imm12:  9:5:Rn:  4:0:Rt:> Store Register Halfword (immediate)
 *)
-  let load_store_reg_uimm insn =
+  let load_store_reg_uimm s insn =
     let%decode insn' = insn "31:30:size:F:01,29:27:_:F:111,26:26:_V:F:0,25:24:_:F:01,23:22:opc:F:00,21:10:imm12:F:xxxxxxxxxxxx,9:5:Rn:F:xxxxx,4:0:Rt:F:xxxxx" in
     let mem_sz = match size_v with
       | 0 -> 8
       | 1 -> 16
       | 2 -> 32
       | 3 -> 64
-      | _ -> L.abort (fun p->p "impossible size")
+      | _ -> error_isn s.a insn "impossible size"
     in
     let sf = (size_v land 1) in
     let sz = sf2sz sf in
@@ -765,7 +786,7 @@ STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:00  21:10:im
       [Set(M(addr, mem_sz), Lval(rt))]
 
   (* STP / STNP / LDP *)
-  let load_store_pair insn op3 =
+  let load_store_pair s insn op3 =
     let%decode insn' = insn "31:30:opc:F:00,29:27:_:F:101,26:26:_V:F:0,25:23:_:F:001,22:22:L:F:1,21:15:imm7:F:xxxxxxx,14:10:Rt2:F:xxxxx,9:5:Rn:F:xxxxx,4:0:Rt:F:xxxxx" in
     let sf = (opc_v lsr 1) land 1 in
     let sz = sf2sz sf in
@@ -780,7 +801,7 @@ STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:00  21:10:im
       | 0b01 ->  Lval(rn), [Set(rn, BinOp(Add, Lval(rn), offset))]
       (* pre index *)
       | 0b11 -> BinOp(Add, Lval(rn), offset), [Set(rn, BinOp(Add, Lval(rn), offset))]
-      | _ -> L.abort (fun p->p "Impossible value in load_store_pair")
+      | _ -> error_isn s.a insn "Impossible value in load_store_pair"
     in
     if l_v = 1 then
       (* load *)
@@ -805,31 +826,31 @@ STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:00  21:10:im
        (op0 = 1 && op1 = 0 && op2 = 1) ||
        (op1 = 0 && op2 = 0 && op3 > 1) ||
        (op1 = 1 && op3 > 1) then
-      error s.a (Printf.sprintf "Unallocated opcode 0x%x" insn);
+      error s.a "Unallocated opcode";
     (* SIMD *)
     if (op0 = 0 && op1 =0 && op2 = 1) then
-      error s.a (Printf.sprintf "SIMD load/store not decoded yet. opcode 0x%x" insn);
+      notimplemented s insn "SIMD load/store";
     if (op1 = 0b10) then
-      load_store_pair insn op3
+      load_store_pair s insn op3
     else begin
       if (op1 = 0b11) then
         begin
           if op3 > 1 then begin
-            load_store_reg_uimm insn
+            load_store_reg_uimm s insn
           end else begin
             if op5 = 0b10 then begin
-              load_store_reg_off insn
+              load_store_reg_off s insn
             end else begin
-              load_store_reg_imm insn
+              load_store_reg_imm s insn
             end
           end
         end
       else
-        error s.a (Printf.sprintf "load/store type not decoded yet. opcode 0x%x" insn);
+        notimplemented s insn "load/store";
     end
 
   (* Return statement matching cond, see ConditionHolds in MRA *)
-  let decode_cond cond =
+  let decode_cond s cond =
     let base_cond = match (cond lsr 1) with
       | 0b000 -> Cmp(EQ, zf_lv, const1 1)
       | 0b001 -> Cmp(EQ, cf_lv, const1 1)
@@ -839,7 +860,7 @@ STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:00  21:10:im
       | 0b101 -> Cmp(EQ, nf_lv, vf_lv)
       | 0b110 -> BBinOp(LogAnd, Cmp(EQ, nf_lv, vf_lv), Cmp(EQ, zf_lv, const0 1))
       | 0b111 -> BConst(true)
-      | _ -> L.abort (fun p->p "Invalid condition")
+      | _ -> error s.a "invalid condition"
     in
     if (cond land 1) = 1 && cond != 15 then
       BUnOp(LogNot, base_cond)
@@ -851,7 +872,7 @@ STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:00  21:10:im
     let%decode insn' = insn "31:25:_:F:0101010,24:24:_o1:F:0,23:5:imm19:F:xxxxxxxxxxxxxxxxxxx,4:4:_o0:F:0,3:0:cond:F:xxxx" in
     let offset = imm19_v lsl 2 in
     let signed_offset = sign_extension (Z.of_int offset) 21 64 in
-    let cond_il = decode_cond cond_v in
+    let cond_il = decode_cond s cond_v in
     [If(cond_il, [Jmp(A(Address.add_offset s.a signed_offset))], [Nop])]
 
   (*
@@ -910,6 +931,16 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
          [Jmp(A(Address.add_offset s.a signed_offset))],
          [Nop])]
 
+  let branch_system_register_move (_s: state) (_isn: int) : (Asm.stmt list) =
+    (* Not implemented for the moment but does not fails *)
+    L.info(fun p -> p "branch system register move not implemented");
+    []
+    (* let%decode isn' = isn "31:22:_:F:1101010100,21:21:L:F:x,20:20:_:F:1,19:19:oO:F:x,18:16:op1:F:xxx,15:12:CRn:F:xxxx,11:8:CRm:F:xxxx,7:5:Rt:F:xxx,4:0:Rt:F:xxxxx" in
+    if L_v = 0 (* MSR (register) *) then
+      []
+    else (* MRS *)
+      [] *)
+
   (* Branches, Exception Generating and System instructions *)
   let branch (s: state) (insn: int): (Asm.stmt list) =
     let op0 = (insn lsr 29) land 7 in
@@ -924,8 +955,13 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
       tst_br s insn
     else if (op0 land 3) = 1 && op1 <= 7 then
       cmp_br s insn
+    else if op0 = 0b110 && op1 = 0b0100 then
+      if insn lsr 20 land 1 = 1 then
+        branch_system_register_move s insn
+      else
+        notimplemented s insn "System instruction"
     else
-      error s.a (Printf.sprintf "Unsupported branch opcode 0x%08x" insn)
+      notimplemented s insn "Branch opcode"
 
 
   (* SIMD three same - C4.1.5, page C-302) *)
@@ -958,7 +994,7 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
 
   (* Conversion between floating-point and fixed-point *)
   let fp_fp_conv  (s: state) (insn: int): (Asm.stmt list) =
-    error s.a (Printf.sprintf "Conversion between floating-point and fixed-point not implemented, opcode : 0x%08x" insn)
+    notimplemented s insn "Conversion between floating-point and fixed-point"
 
 
   (* Conversion between floating-point and integer *)
@@ -973,7 +1009,7 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
     match sf, s_, typ, rmode, opcode with
     | 0, 0, 0b00, 0b00, 0b110 -> [ Set( V (wreg rd), Lval (V (sreg rn))) ]
     | 0, 0, 0b00, 0b00, 0b111 -> [ Set( V (qreg rd), UnOp(ZeroExt 128, Lval (V (wreg rn)))) ]
-    | _ -> error s.a (Printf.sprintf "Unsupported floating-point and integer conversion instruction opcode: 0x%08x" insn)
+    | _ -> notimplemented s insn "Floating-point and integer conversion"
 
   let scalar_fp_simd  (s: state) (insn: int): (Asm.stmt list) =
     let op0 = (insn lsr 28) land 0xf in
@@ -990,12 +1026,12 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
           if (op2 land 4) = 4 && (op3 land 1) = 1 then
             simd_three_same
           else
-            error s.a (Printf.sprintf "Unsupported scalar floating point or SIMD opcode: 0x%08x" insn)
+            notimplemented s insn "Scalar floating point or SIMD"
         end
       else
         begin
           L.debug (fun p -> p "FP/SIMD instruction decoded as: op0=%x op1=%x op2=%x op3=%x" op0 op1 op2 op3);
-          error s.a (Printf.sprintf "Unsupported scalar floating point or SIMD opcode: 0x%08x" insn)
+          notimplemented s insn "Scalar floating point or SIMD (2)"
         end
     in f s insn
 
@@ -1006,7 +1042,7 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
     let stmts = match (instruction lsr 25) land 0xF with
       (* C4.1 in ARMv8 manual *)
       (* 00xx : unallocated *)
-      | 0b0000 | 0b0001 | 0b0010 | 0b0011 -> error s.a (Printf.sprintf "Unallocated opcode 0x%x" instruction)
+      | 0b0000 | 0b0001 | 0b0010 | 0b0011 -> error s.a "Unallocated opcode"
       (* 100x : data processing (immediate) *)
       | 0b1000 | 0b1001 -> data_processing_imm s instruction
       (* 101x : branches, exceptions, system instructions *)
@@ -1016,7 +1052,7 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
       (* x101 : data processing (register) *)
       | 0b0101 | 0b1101 -> data_processing_reg s instruction
       | 0b0111 | 0b1111 -> scalar_fp_simd s instruction
-      | _ -> error s.a (Printf.sprintf "Unknown opcode 0x%x" instruction)
+      | _ -> error s.a "Unknown opcode"
     in
     return s str stmts
 
@@ -1032,6 +1068,11 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
       let v', ip' = decode s in
       Some (v', ip', ())
     with
+    | Exceptions.Failed_decoding (msg, isn) -> (
+      L.debug(fun p -> p "Failed-decoding: %s" msg);
+      let v', ip' = return s (String.sub s.buf 0 4) [] in
+      Some (v', ip', ())
+    )
     | Exceptions.Error _ as e -> raise e
     | _             -> (*end of buffer *) None
 
@@ -1040,5 +1081,5 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
     Imports.init ()
 
   let overflow_expression () = Lval (V (T vflag))
-  let init_registers () = []
+  let init_registers () = ()
 end
diff --git a/ocaml/src/disassembly/armv8aImports.ml b/ocaml/src/disassembly/armv8aImports.ml
index 6a3d6fe1..5fc4a8ca 100644
--- a/ocaml/src/disassembly/armv8aImports.ml
+++ b/ocaml/src/disassembly/armv8aImports.ml
@@ -116,7 +116,7 @@ struct
           libname = "";
           prologue = [];
           stub = [];
-          epilogue = [] ;
+          epilogue = [Directive ( Skip (Asm.Fun_addr a, get_callconv()))] ;
           ret_addr =Lval(reg "x30");
            }
          else
diff --git a/ocaml/src/disassembly/cfa.ml b/ocaml/src/disassembly/cfa.ml
index bde19f51..0b418492 100644
--- a/ocaml/src/disassembly/cfa.ml
+++ b/ocaml/src/disassembly/cfa.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2019 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -34,13 +34,8 @@ sig
     type ctx_t = {
       addr_sz: int; (** size in bits of the addresses *)
       op_sz  : int; (** size in bits of operands *)
-      }
-               
-    (** data type for handler management *)
-    type handler_kind_t =
-      | Direct of Data.Address.t
-      | Inlined of Asm.stmt list
-                 
+    }
+
     type t  = {
       id: int;                          (** unique identificator of the state *)
       mutable ip: Data.Address.t;       (** instruction pointer *)
@@ -54,8 +49,7 @@ sig
       mutable branch: bool option;      (** None is for unconditional predecessor. Some true if the predecessor is a If-statement for which the true branch has been taken. Some false if the false branch has been taken *)
       mutable bytes: char list;         (** corresponding list of bytes *)
       mutable taint_sources: Taint.Set.t;    (** set of taint sources*)
-      mutable back_taint_sources: Taint.Set.t option; (** set of taint sources in backward mode. None means undefined *)
-      mutable handlers: (int, Data.Address.t) Hashtbl.t * (int -> Asm.stmt list); (** table of user defined handlers * default handler behavior *)
+      mutable back_taint_sources: Taint.Set.t option (** set of taint sources in backward mode. None means undefined *)
     }
 
     val compare: t -> t -> int
@@ -63,17 +57,13 @@ sig
 
   (** oracle for retrieving any semantic information computed by the interpreter *)
   class oracle:
-          domain ->
-          (int, Data.Address.t) Hashtbl.t * (int -> Asm.stmt list) ->
+    domain ->
   object
     (** returns the computed concrete value of the given register
         may raise an exception if the conretization fails
         (not a singleton, bottom) *)
     method value_of_register: Register.t -> Z.t
 
-    (** returns the address associated to the given interrupt number *)
-    method get_handler: int -> State.handler_kind_t
-         
   end
 
   (** abstract data type of the control flow graph *)
@@ -82,12 +72,16 @@ sig
   (** [create] creates an empty CFG *)
   val create: unit -> t
 
-  (** [init_state addr] creates a state whose ip field is _addr_ *)
-  val init_state: Data.Address.t -> (Register.t * Data.Word.t) list -> (int -> Asm.stmt list) -> State.t
+  (** [init addr] creates a state whose ip field is _addr_ *)
+  val init_state: Data.Address.t -> State.t
 
   (** [add_state cfg state] adds the state _state_ from the CFG _cfg_ *)
   val add_state: t -> State.t -> unit
 
+  val has_ip: t -> State.t -> bool
+
+  val update_states: t -> Data.Address.t -> unit
+
   (** [copy_state cfg state] creates a fresh copy of the state _state_ in the CFG _cfg_.
       The fresh copy is returned *)
   val copy_state: t -> State.t -> State.t
@@ -128,7 +122,7 @@ sig
 
   (** [init_abstract_value] builds the initial abstract value from the input configuration *)
 
-  val init_abstract_value: Data.Address.t -> (Register.t * Data.Word.t) list -> domain * Taint.Set.t
+  val init_abstract_value: Data.Address.t -> domain * Taint.Set.t
 
   (** [update_abstract_value] updates the given abstract state from the input configuration *)
   val update_abstract_value: Data.Address.t -> domain -> domain * Taint.Set.t
@@ -136,7 +130,6 @@ sig
   (** [iter_state_ip f ip] iterates function _f_ on states that have _ip_ as ip field *)
   val iter_state_ip: (State.t -> unit) -> t -> Data.Address.t -> unit
 
-  val update_ips: t -> State.t -> unit
 end
 
 (** the control flow automaton functor *)
@@ -158,10 +151,6 @@ struct
       op_sz  : int; (** size in bits of operands *)
     }
 
-    type handler_kind_t =
-      | Direct of Data.Address.t
-      | Inlined of Asm.stmt list
-                 
     (** abstract data type of a state *)
     type t = {
       id: int;                          (** unique identificator of the state *)
@@ -176,8 +165,7 @@ struct
       mutable branch: bool option;      (** None is for unconditional predecessor. Some true if the predecessor is a If-statement for which the true branch has been taken. Some false if the false branch has been taken *)
       mutable bytes: char list;         (** corresponding list of bytes *)
       mutable taint_sources: Taint.Set.t;     (** set of taint sources. Empty if not tainted  *)
-      mutable back_taint_sources: Taint.Set.t option; (** set of taint sources in backward mode. None means undefined *)
-      mutable handlers: (int, Data.Address.t) Hashtbl.t * (int -> Asm.stmt list); (** table of user defined handlers * default handler behavior *)
+      mutable back_taint_sources: Taint.Set.t option (** set of taint sources in backward mode. None means undefined *)
     }
 
     (** the state identificator counter *)
@@ -202,14 +190,9 @@ struct
   open State
 
 
-  class oracle (d: domain) (handlers: (((int, Data.Address.t) Hashtbl.t) * (int -> Asm.stmt list))) =
+  class oracle (d: domain) =
   object
     method value_of_register (reg: Register.t) = Domain.value_of_register d reg
-
-    method get_handler i = 
-      try
-        State.Direct (Hashtbl.find (fst handlers) i)
-      with Not_found -> State.Inlined ((snd handlers) i)
   end
 
   (** type of a CFA *)
@@ -249,7 +232,7 @@ struct
       match c with
       | Some c' -> Config.size_of_content c'
       | None -> 0
-         
+
     let init_heap ip domain content_list =
       (* TODO: factorize with init_mem *)
       List.fold_left
@@ -266,8 +249,8 @@ struct
           in
           d', Taint.Set.union prev_taint taint
         ) (domain, Taint.Set.singleton Taint.U) (List.rev content_list)
-  
-      
+
+
   let update_abstract_value ip d =
     (* initialisation of Global memory + registers *)
     let d', taint1 = init_registers d in
@@ -276,22 +259,16 @@ struct
     let d', taint3 = init_heap ip d' !Config.heap_content in
     d', Taint.Set.union taint3 (Taint.Set.union taint2 taint1)
 
-  let init_abstract_value ip init_reg =
-    let d  = List.fold_left (fun d r ->
-                 let exp =
-                   try
-                     Some (List.assoc r init_reg)
-                   with Not_found -> None
-                 in
-                 Domain.add_register r d exp) (Domain.init()) (Register.used()) in
+    let init_abstract_value ip =
+      let d  = List.fold_left (fun d r -> Domain.add_register r d) (Domain.init()) (Register.used()) in
       update_abstract_value ip d
 
 
   (* CFA creation.
      Return the abstract value generated from the Config module *)
-    
-  let init_state (ip: Data.Address.t) init_reg default_handlers: State.t =
-    let d', _taint = init_abstract_value ip init_reg in
+
+  let init_state (ip: Data.Address.t): State.t =
+    let d', _taint = init_abstract_value ip in
     {
       id = 0;
       ip = ip;
@@ -309,26 +286,66 @@ struct
       };
       taint_sources = Taint.Set.singleton Taint.U;
       back_taint_sources = None;
-      handlers = Hashtbl.create 5, default_handlers;
     }
 
 
   (* CFA utilities *)
   (*****************)
 
-  let update_ips (_g, ips) v =
+  let has_ip (_, ips) v =
+    try
+      let states = Hashtbl.find ips v.State.ip in
+      let states_with_statements =
+      try
+        List.find_all (fun p -> p.stmts <> []) states;
+      with Not_found -> []
+     in
+      if (List.length states_with_statements) > 0 then true else false
+    with Not_found -> false
+
+
+    (* let states =
+      try
+        Hashtbl.find ips v.State.ip
+      with Not_found -> []
+    in L.info(fun p -> p "(has_ip) States (id %d) %d" v.State.id (List.length states));
+    List.iter(fun v -> L.info(fun p -> p "Statements : %d" (List.length v.stmts))) states;
+    Hashtbl.mem ips v.State.ip *)
+
+  let update_ips ips v =
+    L.info(fun p -> p "Update ips with state %d and ip %s" v.State.id (Data.Address.to_string v.State.ip));
     let states =
        try Hashtbl.find ips v.State.ip
       with Not_found -> []
     in
     Hashtbl.replace ips v.State.ip (v::states)
-    
-  let copy_state (g, _ips) v =
+
+  let update_states ((_, ips): t) (old_ip: Data.Address.t): unit =
+    (* After cloning states for branches, the IP may be wrong so we update it and set the state to the correct IP *)
+    L.info(fun p -> p "Updating state for old_ip %s" (Data.Address.to_string old_ip));
+    let states =
+      try
+        Hashtbl.find ips old_ip
+      with Not_found -> []
+    in
+    L.info(fun p -> p "States size before : %d " (List.length states));
+    let new_states = List.fold_left (fun l' v ->
+      L.info(fun p -> p "Old_ip %s / State ip is %s / R: %b" (Data.Address.to_string old_ip) (Data.Address.to_string v.State.ip) (v.State.ip = old_ip));
+      if v.State.ip <> old_ip then (
+        update_ips ips v;
+        l'
+      ) else
+        v::l'
+    ) [] states in
+    Hashtbl.replace ips old_ip new_states;
+    L.info(fun p -> p "States size after : %d " (List.length new_states))
+
+  let copy_state (g, ips) v =
     let v = { v with id = new_state_id() } in
     G.add_vertex g v;
+    update_ips ips v;
     v
 
-
   let create () = G.create (), Hashtbl.create 117
 
   let remove_state (g, ips: t) (v: State.t): unit =
@@ -336,10 +353,8 @@ struct
     let rec remove l =
       match l with
       | [] -> []
-      | a::l ->
-         if a.State.id = vid then l else a::(remove l)
-    in
-    let states =
+      | a::l -> if a.State.id = vid then l else a::(remove l)
+    in let states =
       try
         remove (Hashtbl.find ips v.State.ip)
       with Not_found -> []
@@ -349,8 +364,9 @@ struct
 
   let remove_successor ((g, _): t) (src: State.t) (dst: State.t): unit = G.remove_edge g src dst
 
-  let add_state (g, _ips: t) (v: State.t): unit =
-    G.add_vertex g v
+  let add_state (g, ips: t) (v: State.t): unit =
+    G.add_vertex g v;
+    update_ips ips v
 
   let add_successor (g, _ips) src dst: unit = G.add_edge g src dst
 
@@ -410,7 +426,7 @@ struct
     Printf.fprintf f "\n[program]\nnull = 0x%s\nmem_sz=%d\nstack_width=%d\n" (Z.format "%02x" (!Config.null_cst) ) (!Config.address_sz)(!Config.stack_width);
     Printf.fprintf f "architecture = %s\n\n" architecture_str;
     (* taint sources *)
-    Printf.fprintf f "[taint sources]\n"; 
+    Printf.fprintf f "[taint sources]\n";
     Hashtbl.iter (fun id src -> Printf.fprintf f "%d = %s\n" id (Dump.string_of_src src)) Dump.taint_src_tbl;
     Printf.fprintf f "\n";
     Printf.fprintf f "[heap ids]\n";
@@ -422,11 +438,11 @@ struct
     close_out f;;
 
 
-  let marshal (fid: out_channel) (cfa, ips: t): unit =
-    Marshal.to_channel fid cfa [Marshal.Closures];
-    Marshal.to_channel fid ips [Marshal.Closures];
+  let marshal (fid:out_channel) (cfa, ips: t): unit =
+    Marshal.to_channel fid cfa [];
+    Marshal.to_channel fid ips [];
     Marshal.to_channel fid !state_cpt [];;
-  
+
   let unmarshal fid: t =
     let origcfa = Marshal.from_channel fid in
     let origips = Marshal.from_channel fid in
diff --git a/ocaml/src/disassembly/cfa.mli b/ocaml/src/disassembly/cfa.mli
index 7951833f..d43ba347 100644
--- a/ocaml/src/disassembly/cfa.mli
+++ b/ocaml/src/disassembly/cfa.mli
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2018 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -33,11 +33,6 @@ module type T =
       op_sz  : int; (** size in bits of operands *)
     }
 
-    (** data type for handler management *)
-    type handler_kind_t =
-      | Direct of Data.Address.t
-      | Inlined of Asm.stmt list
-                 
     type t  = {
       id: int;                  (** unique identificator of the state *)
       mutable ip: Data.Address.t;   (** instruction pointer *)
@@ -52,8 +47,7 @@ module type T =
       mutable branch: bool option; (** None is for unconditional predecessor. Some true if the predecessor is a If-statement for which the true branch has been taken. Some false if the false branch has been taken *)
       mutable bytes: char list;      (** corresponding list of bytes *)
       mutable taint_sources: Taint.Set.t; (** set of taint sources *)
-      mutable back_taint_sources: Taint.Set.t option; (** set of taint sources in backward mode. None means undefined *)
-      mutable handlers: (int, Data.Address.t) Hashtbl.t * (int -> Asm.stmt list); (** table of user defined handlers * default handler behavior *)
+      mutable back_taint_sources: Taint.Set.t option (** set of taint sources in backward mode. None means undefined *)
 
     }
 
@@ -63,15 +57,13 @@ module type T =
 
   (** oracle for retrieving any semantic information computed by the interpreter *)
   class oracle:
-    domain -> (int, Data.Address.t) Hashtbl.t * (int -> Asm.stmt list) -> 
+    domain ->
   object
     (** returns the computed concrete value of the given register
         may raise an exception if the conretization fails
         (not a singleton, bottom) *)
     method value_of_register: Register.t -> Z.t
 
-    (** returns the address associated to the given interrupt number *)
-    method get_handler: int -> State.handler_kind_t
   end
 
   (** abstract data type of the control flow graph *)
@@ -80,12 +72,16 @@ module type T =
   (** [create] creates an empty CFG *)
   val create: unit -> t
 
-  (** [init_state addr] creates a state whose ip field is _addr_ *)
-  val init_state: Data.Address.t -> (Register.t * Data.Word.t) list -> (int -> Asm.stmt list) -> State.t
+  (** [init addr] creates a state whose ip field is _addr_ *)
+  val init_state: Data.Address.t -> State.t
 
   (** [add_state cfg state] adds the state _state_ from the CFG _cfg_ *)
   val add_state: t -> State.t -> unit
 
+  val has_ip: t -> State.t -> bool
+
+  val update_states: t -> Data.Address.t -> unit
+
   (** [copy_state cfg state] creates a fresh copy of the state _state_ in the CFG _cfg_.
       The fresh copy is returned *)
   val copy_state: t -> State.t -> State.t
@@ -126,7 +122,7 @@ module type T =
 
   (** [init_abstract_value] builds the initial abstract value from the input configuration *)
 
-  val init_abstract_value: Data.Address.t -> (Register.t * Data.Word.t) list -> domain * Taint.Set.t
+  val init_abstract_value: Data.Address.t -> domain * Taint.Set.t
 
   (** [update_abstract_value] updates the given abstract state from the input configuration *)
   val update_abstract_value: Data.Address.t -> domain -> domain * Taint.Set.t
@@ -134,7 +130,6 @@ module type T =
   (** [iter_state_ip f ip] iterates function _f_ on states that have _ip_ as ip field *)
   val iter_state_ip: (State.t -> unit) -> t -> Data.Address.t -> unit
 
-    val update_ips: t -> State.t -> unit
 end
 
 module Make: functor (D: Domain.T) ->
diff --git a/ocaml/src/disassembly/core_x86.ml b/ocaml/src/disassembly/core_x86.ml
index 3c2110f5..7e98006f 100644
--- a/ocaml/src/disassembly/core_x86.ml
+++ b/ocaml/src/disassembly/core_x86.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2019 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -17,7 +17,7 @@
  *)
 
 (************************************************************)
-(* Core functionalities of the x86 decoders                 *)
+(* core functionalities of the x86 decoders                 *)
 (************************************************************)
 
 module L = Log.Make(struct let name = "core_x86" end)
@@ -71,7 +71,7 @@ type tbl_entry = {
     dpl: privilege_level;
     p: Z.t;
     avl: Z.t;
-    l: Z.t; (* 64-bit flag *)
+    l: Z.t;
     db: Z.t;
     gran: Z.t;}
 
@@ -98,46 +98,40 @@ type ictx_t = {
 
 
 module type Arch =
-  functor (Domain: Domain.T) ->
-  functor (Stubs: Stubs.T with type domain_t := Domain.t) ->
-  sig
-    module Cfa: Cfa.T
-    val operand_sz: int
-    module Imports:
-    sig
-      val init: unit -> unit
-      val skip: (Asm.import_desc_t * Asm.calling_convention_t) option ->
-                Data.Address.t -> Asm.import_desc_t
-      val tbl: (Data.Address.t, Asm.import_desc_t * Asm.calling_convention_t) Hashtbl.t
-
-      (** returns the statements enabling to set the first function argument corresponding to the current calling convention *)
-      val set_first_arg: Asm.exp -> Asm.stmt list
-      val unset_first_arg: unit -> Asm.stmt list
-        
-    end
-    val ebx: Register.t
-    val ebp: Register.t
-    val esi: Register.t
-    val edi: Register.t
-    val edx: Register.t
-    val eax: Register.t
-    val ecx: Register.t
-    val esp: Register.t
-    val init_registers: (int, Register.t) Hashtbl.t -> (int, Register.t) Hashtbl.t -> unit
-    val decode_from_0x40_to_0x4F: char -> int -> rex_t
-    val arch_get_base_address: Cfa.oracle -> ictx_t -> Data.Address.t -> Register.t -> Z.t
-    (* function to set an lval to an expression *)
-    val set_dest: Asm.lval -> Asm.exp -> Asm.stmt list
-      
-    (** add_segment translates the segment selector/offset pair into a linear addresss *)
-    val add_segment: Cfa.oracle -> ictx_t -> int -> Data.Address.t -> Asm.exp -> Register.t -> Asm.exp
-    (* Check segments limits, returns (success_bool, base_addr, limit) *)
-    val check_seg_limit: Cfa.oracle -> Data.Address.t -> ictx_t -> Register.t -> Data.Address.t -> bool * Z.t * Z.t
-    val get_rex: int -> rex_t option
-    val prologue: Address.t -> Asm.stmt list
-    val get_operand_sz_for_stack: unit -> int
-  end
-  
+  functor (Domain: Domain.T) -> functor (Stubs: Stubs.T with type domain_t := Domain.t) ->
+                                sig
+                                  module Cfa: Cfa.T
+                                  val operand_sz: int
+                                  module Imports:
+                                  sig
+                                    val init: unit -> unit
+                                    val skip: (Asm.import_desc_t * Asm.calling_convention_t) option ->
+                                              Data.Address.t -> Asm.import_desc_t
+                                    val tbl: (Data.Address.t, Asm.import_desc_t * Asm.calling_convention_t) Hashtbl.t
+                                  end
+                                  val ebx: Register.t
+                                  val ebp: Register.t
+                                  val esi: Register.t
+                                  val edi: Register.t
+                                  val edx: Register.t
+                                  val eax: Register.t
+                                  val ecx: Register.t
+                                  val esp: Register.t
+                                  val init_registers: (int, Register.t) Hashtbl.t -> (int, Register.t) Hashtbl.t -> unit
+                                  val decode_from_0x40_to_0x4F: char -> int -> rex_t
+                                  val arch_get_base_address: Cfa.oracle -> ictx_t -> Data.Address.t -> Register.t -> Z.t
+                                  (* function to set an lval to an expression *)
+                                  val set_dest: Asm.lval -> Asm.exp -> Asm.stmt list
+
+                                  (** add_segment translates the segment selector/offset pair into a linear addresss *)
+                                  val add_segment: Cfa.oracle -> ictx_t -> int -> Data.Address.t -> Asm.exp -> Register.t -> Asm.exp
+                                  (* Check segments limits, returns (success_bool, base_addr, limit) *)
+                                  val check_seg_limit: Cfa.oracle -> Data.Address.t -> ictx_t -> Register.t -> Data.Address.t -> bool * Z.t * Z.t
+                                  val get_rex: int -> rex_t option
+                                  val prologue: Address.t -> Asm.stmt list
+                                  val get_operand_sz_for_stack: unit -> int
+                                end
+
 (** fatal error reporting *)
 let error a msg =
   L.abort (fun p -> p "at %s: %s" (Address.to_string a) msg)
@@ -305,7 +299,7 @@ module  X64(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := Domain.t) =
       | M(_, _) -> normal_set
       | V(r) -> match r with
                 | T(_) -> (* full assignation *) normal_set
-                | P(reg, l, u) -> if l == 0 && u == 31 then [Set (V (T reg), UnOp (ZeroExt 64, value))] else normal_set 
+                | P(reg, l, u) -> if l == 0 && u == 31 then [Set (V (T reg), UnOp (ZeroExt 64, value))] else normal_set
 
     let add_segment ctx segments operand_sz rip offset sreg =
       match (Register.name sreg) with
@@ -715,7 +709,6 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
   (** control flow automaton *)
   module Arch = Arch(Domain)(Stubs)
   open Arch
-
   module Cfa = Arch.Cfa
   module Imports = Arch.Imports
   let cl = P (Arch.ecx, 0, 7)
@@ -763,8 +756,7 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
     }
 
   let init_registers() =
-    Arch.init_registers register_tbl xmm_tbl;
-    []
+    Arch.init_registers register_tbl xmm_tbl
 
   (** initialization of the decoder *)
   let init () =
@@ -849,9 +841,7 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
     let lvl   = v land 3         in
     let ti    = (v lsr 2) land 1 in
     let index = (v lsr 3)        in
-    { rpl = privilege_level_of_int lvl;
-      ti = if ti = 0 then GDT else LDT;
-      index = Word.of_int (Z.of_int index) 13 }
+    { rpl = privilege_level_of_int lvl; ti = if ti = 0 then GDT else LDT; index = Word.of_int (Z.of_int index) 13 }
 
 
 
@@ -867,8 +857,7 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
   let copy_segments s addr ctx =
     let segments =
       get_segments addr ctx in
-    { gdt = Hashtbl.copy s.gdt; ldt = Hashtbl.copy s.ldt;
-      idt = Hashtbl.copy s.idt; data = ds; reg = segments  }
+    { gdt = Hashtbl.copy s.gdt; ldt = Hashtbl.copy s.ldt; idt = Hashtbl.copy s.idt; data = ds; reg = segments  }
 
   (** returns the base address corresponding to the given value (whose format is supposed to be compatible with the content of segment registers *)
   let get_base_address s sreg =
@@ -1385,16 +1374,19 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
     in
     replace_lv lv
 
-  let icall s =
-      let cesp = M (Lval (V (T esp)), !Config.stack_width) in
-      (* call destination *)
-      let ip' = Data.Address.add_offset s.a (Z.of_int s.o) in
-      let ip = Const (Data.Address.to_word ip' s.operand_sz) in
-      [set_esp Sub (T esp) !Config.stack_width;
-       Set (cesp, ip)]
-                
-  let call s dest_exp = (icall s)@[Call dest_exp]
-                      
+  let call s dest_exp =
+    let cesp = M (Lval (V (T esp)), !Config.stack_width)   in
+    (* call destination *)
+    let ip' = Data.Address.add_offset s.a (Z.of_int s.o) in
+    let ip   = Const (Data.Address.to_word ip' s.operand_sz) in
+    let stmts =
+      [
+        set_esp Sub (T esp) !Config.stack_width;
+        Set (cesp, ip);
+        Call dest_exp
+      ]
+    in
+    stmts
 
   (** call with expression *)
   let indirect_call s dst =
@@ -1498,29 +1490,27 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
   (** state generation for the pop instructions *)
   let pop s lv = return s (pop_stmts true s lv)
 
-  let popf_stmts s sz =
-    let name = Register.fresh_name () in
-    let v = Register.make ~name:name ~size:sz in
-    let tmp = V (T v) in
+  let popf s sz =
+    let name        = Register.fresh_name ()            in
+    let v           = Register.make ~name:name ~size:sz in
+    let tmp         = V (T v) in
     let stmt = set_eflags v in
     let popst = pop_stmts true s [tmp, sz] in
-    popst @ stmt @ [Directive (Remove v)]
+    return s (popst @ stmt @ [Directive (Remove v)])
 
-  let popf s sz = return s (popf_stmts s sz)
-                
   (** generation of statements for the push instructions *)
   let push_stmts (s: state) v =
     let esp' = esp_lval () in
     let t    = Register.make (Register.fresh_name ()) (Register.size esp) in
-    (* in case esp is in the list, save its value before the first push 
-       (this is this value that has to be pushed for esp) 
-       this is the purpose of the pre and post statements *)
+    (* in case esp is in the list, save its value before the first push (this is this value that has to be pushed for esp) *)
+    (* this is the purpose of the pre and post statements *)
     let pre, post=
       if List.exists (fun k -> with_stack_pointer false s.a (fst k)) v then
         [ Set (V (T t), Lval (V esp')) ], [ Directive (Remove t) ]
       else
         [], []
     in
+
     let stmts =
       List.fold_left (
           fun stmts (lv, n) ->
@@ -1553,9 +1543,7 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
   let push_immediate s sz =
     let c     = get_imm s sz !Config.stack_width true in
     let esp'  = esp_lval () in
-    let stmts = [
-        set_esp Sub esp' !Config.stack_width;
-        Set (M (Lval (V esp'), !Config.stack_width), c) ]
+    let stmts = [ set_esp Sub esp' !Config.stack_width; Set (M (Lval (V esp'), !Config.stack_width), c) ]
     in
     return s stmts
 
@@ -1575,8 +1563,7 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
 
   let pushf s sz = return s (pushf_stmts s sz)
 
-  (** returns the state for the mov from immediate operand to register. 
-      The size in byte of the immediate is given as parameter *)
+  (** returns the state for the mov from immediate operand to register. The size in byte of the immediate is given as parameter *)
   let mov_immediate s sz =
     let sz' = if sz = 8 then sz else s.operand_sz in
     let dst, _ = operands_from_mod_reg_rm s sz' 0 in
@@ -2486,7 +2473,6 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
       if s.repne then
         match c with
         | c when '\xA6' <= c && c <= '\xA7' || '\xAE' <= c && c <= '\xAF' -> c
-        | '\xFF' -> if !Config.mpx then error s.a "bnd jmp instruction not managed (MPX enabled)" else c
         | _ -> L.warn (fun p->p "%s: Decoder: undefined behavior of REPNE with opcode %x" (Data.Address.to_string s.a) (Char.code c)); c
       else
         c
@@ -2498,7 +2484,7 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
   let unroll_scas (cmp: cmp) s i: stmt =
     let edi' = V (to_reg edi s.addr_sz) in
     let mem  = add_segment s (Lval edi') es in
-    Directive (Unroll_until (mem, cmp, Lval (V (to_reg eax i)), 1024, i))
+    Directive (Unroll_until (mem, cmp, Lval (V (to_reg eax i)), 10000, i))
 
   let switch_sizes s = s.operand_sz <- if s.operand_sz = 16 then 32 else 16; s.imm_sz <- s.operand_sz;;
 
@@ -2576,65 +2562,12 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
   exception No_rep of Cfa.State.t * Data.Address.t
 
 
-  let convert_interrupt_number n =
-    match !Config.os, n with
-    | Config.Linux, 3 -> 5
-    | _, _ -> n
-
-  (** INT n *)
-  let int_n n s ctx =
-    let n = convert_interrupt_number n in
-    let handler = ctx#get_handler n in
-    let stmts =
-      match handler with
-      | Cfa.State.Direct a -> (Imports.set_first_arg (const n !Config.stack_width)) @ (call s (A a)) @ (Imports.unset_first_arg ())
-      | Cfa.State.Inlined stmts -> (icall s) @ stmts
-    in
-    let stmts = (* push flags, set the first arg of the handler and call the handler *)
-      (if !Config.os = Config.Windows then [] else pushf_stmts s !Config.stack_width)
-      @ stmts
-      @ (if !Config.os = Config.Windows then [] else popf_stmts s !Config.stack_width)
-    in
-    return s stmts
- 
-
-  (* INT 3*)
-  let int_3 s ctx =
-    L.debug2 (fun p -> p "decoding INT 3");
-    (* we ignore the differences between the opcode CC et CD03 *)
-    int_n 3 s ctx
-
-
-  let into s ctx =
-    try
-      (* Vol 3, 5.2.1: Bit 53 is defined as the 64-bit (L) flag and is used to select 
-         between 64-bit mode and compatibility mode when IA-32e mode is active *)
-      let csv = get_segment_register_mask (ctx#value_of_register cs) in
-      let tbl = if csv.ti = GDT then s.segments.gdt else s.segments.ldt in
-      let cs_segment = Hashtbl.find tbl csv.index in
-      let is_64 =  Z.logand (Z.shift_right cs_segment.base 53) Z.one in
-      if Z.compare is_64 Z.one = 0 then
-        (* vol 2A, 3-457 *)
-        error s.a "Illegal call to INTO in x64 mode"
-      else
-        let ofv = ctx#value_of_register fof in
-        if Z.compare ofv Z.one = 0 then
-          int_n 4 s ctx
-        else
-          return s []
-    with _ -> error s.a "Imprecise value for cs or overflow flag. Analysis stops"
-
-  let iret s =
-    let stmts = (* pop ip, pop flags and restore context *)
-      Return::(popf_stmts s !Config.stack_width) in
-    return s stmts
-    
   (************************************************************)
   (* Main decoding                                            *)
   (************************************************************)
 
   (** decoding of one instruction *)
-  let decode s ctx =
+  let decode s =
     let add_sub_mrm s op use_carry sz direction =
       let dst, src = operands_from_mod_reg_rm s sz direction in
       add_sub s op use_carry dst src sz
@@ -2867,7 +2800,6 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
          let n = (Char.code c) - 0xb4  in
          let r = V (P (Hashtbl.find register_tbl n, 8, 15)) in
          return s [Set (r, Const (Word.of_int (int_of_byte s) 8))]
-         
       | c when '\xb8' <= c && c <= '\xbf' -> mov_imm_direct s c
       | '\xc0' -> (* shift grp2 with byte size*) grp2 s 8 None
       | '\xc1' -> (* shift grp2 with word or double-word size *) grp2 s s.operand_sz None
@@ -2882,17 +2814,12 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
          let sp = V (to_reg esp !Config.stack_width) in
          let bp = V (to_reg ebp !Config.stack_width) in
          return s ( (Set (sp, Lval bp))::(pop_stmts false s [bp, !Config.stack_width]))
-
-      | '\xca' -> (* RET FAR and pop a word *)
-         return s ([Return ; set_esp Add (T esp) s.addr_sz ; ] @ (pop_stmts false s [V (T cs), 16] @ (* pop imm16 *) [set_esp Add (T esp) 16]))
-                                             
+      | '\xca' -> (* RET FAR and pop a word *) return s ([Return ; set_esp Add (T esp) s.addr_sz ; ] @ (pop_stmts false s [V (T cs), 16] @ (* pop imm16 *) [set_esp Add (T esp) 16]))
       | '\xcb' -> (* RET FAR *) return s ([Return ; set_esp Add (T esp) s.addr_sz; ] @ (pop_stmts false s [V (T cs), 16]))
-      | '\xcc' -> (* INT 3 *) int_3 s ctx
+      | '\xcc' -> (* INT 3 *) error s.a "INT 3 decoded. Interpreter halts"
       | '\xcd' -> (* INT *) let c = getchar s in error s.a (Printf.sprintf "INT %d decoded. Interpreter halts" (Char.code c))
-
-      | '\xce' -> (* INTO *) into s ctx
-         
-      | '\xcf' -> (* IRET *) iret s
+      | '\xce' -> (* INTO *) error s.a "INTO decoded. Interpreter halts"
+      | '\xcf' -> (* IRET *) error s.a "IRET instruction decoded. Interpreter halts"
 
       | '\xd0' -> (* grp2 shift with one on byte size *) grp2 s 8 (Some (const1 8))
       | '\xd1' -> (* grp2 shift with one on word or double size *) grp2 s s.operand_sz (Some (const1 8))
@@ -2939,7 +2866,6 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
         begin
           match List.hd v.Cfa.State.stmts with
           | Return -> L.decoder (fun p -> p "simplified rep ret into ret")
-          | Jmp _ -> L.decoder (fun p -> p "simplified rep jmp into jmp")
           | _ ->
              (* XXX:
               * if we do not have a cmps or a scas remove repe/repne flag
@@ -2972,7 +2898,7 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
              in
              if not (s.repe || s.repne) then
                v.Cfa.State.stmts <- [ Directive (Type (V (T ecx), Types.T (TypedC.Int (Newspeak.Unsigned, Register.size ecx))));
-                                      Directive (Unroll (Lval (V (T ecx)), 1024)) ] @ blk
+                                      Directive (Unroll (Lval (V (T ecx)), 10000)) ] @ blk
              else
                begin
                  let cmp = if s.repne then EQ else NEQ in
@@ -3009,18 +2935,6 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
          let v, ip = mod_rm_on_xmm2 s sz in
          raise (No_rep (v, ip))
 
-      | '\x1e' ->
-         let byte = getchar s in
-         if byte = '\xfa' || byte = '\xfb' then
-           (* endbr64 / endbr62 *)
-           if !Config.mpx then
-             error s.a "endbr: MPX extension not managed"
-           else
-             (* TODO: could call our checker that verifies whether the actual return address is the one expected *)
-             return s [ Nop ]
-         else
-           error s.a (Printf.sprintf "unknown third opcode 0x%x\n" (Char.code byte))
-           
       | '\x1F' -> (* long nop *) let _, _ = operands_from_mod_reg_rm s s.operand_sz 0 in return s [ Nop ]
 
       | '\x28' -> (* MOVAPD *) (* TODO: make it more precise *)
@@ -3135,6 +3049,10 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
       | '\xc7' -> (* CMPXCHG8B *)  cmpxchg8b_mrm s
       | c when '\xc8' <= c && c <= '\xcf' -> let nreg = ((Char.code c)  - 0xc8) + (8*s.rex.b_)  in bswap s nreg s.operand_sz
 
+      | '\xef' -> (* PXOR *)
+        let forgets = List.map (fun r -> Directive (Forget (V (T r)))) [xmm0; xmm1] in
+        let v, ip = return s forgets in
+        raise (No_rep (v, ip))
 
       | c        -> error s.a (Printf.sprintf "unknown second opcode 0x%x\n" (Char.code c))
     in
@@ -3161,7 +3079,7 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
       }
     in
     try
-      let v', ip = decode s' ctx in
+      let v', ip = decode s' in
       Some (v', ip, s'.segments)
     with
     | Exceptions.Error _ as e -> raise e
diff --git a/ocaml/src/disassembly/decoder.mli b/ocaml/src/disassembly/decoder.mli
index 4f879d6d..8d643721 100644
--- a/ocaml/src/disassembly/decoder.mli
+++ b/ocaml/src/disassembly/decoder.mli
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2018 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -21,52 +21,13 @@
 (***************************************************************************************)
 
 
-module type T =
-
-
-sig
-  (** control flow graph *)
-  module Cfa: Cfa.T
-    
-  (** data struct for external functions management *)
-  module Imports:
-  sig
-
-
-  (** mapping from code addresses to library functions *)
-    val tbl: (Data.Address.t, Asm.import_desc_t * Asm.calling_convention_t) Hashtbl.t
-
-    (** returns a function modeling a skip of the given import function wrt to the given calling convention *)
-      val skip: (Asm.import_desc_t * Asm.calling_convention_t) option -> Data.Address.t -> Asm.import_desc_t
-  end
-
-    (** decoding context *)
-    type ctx_t
-
-
-    (**  [parse text cfg ctx state addr oracle] *)
-    val parse: string -> Cfa.t -> ctx_t -> Cfa.State.t -> Data.Address.t -> Cfa.oracle -> (Cfa.State.t * Data.Address.t * ctx_t) option
-  (** extract the opcode at address _addr_ in _text_ and translate it as a list of statements.
-      This list of statement is added to the list of possible successor of the state _state_ in the control flow graph _cfg_.
-      All needed context for the decoder is passed through the context parameter _ctx_ *)
-
-  (** initialize the decoder and returns its initial context *)
-    val init: unit -> ctx_t
-
-    (** returns the expression to check whether an overflow occurs *)
-    val overflow_expression: unit -> Asm.exp
-
-                                       (** creates registers if not done by default (see x86 and x64 mechanisms) *)
-    val init_registers: unit -> (Register.t * Data.Word.t) list 
-
-end
-
-
-module type Make = functor (D: Domain.T)(Stubs: Stubs.T with type domain_t := D.t)-> 
 
+module type Make = functor (D: Domain.T) (Stubs: Stubs.T with type domain_t := D.t) ->
 sig
   (** control flow graph *)
   module Cfa: (Cfa.T with type domain = D.t)
+
+  (** data struct for external functions management *)
   module Imports:
   sig
 
@@ -95,6 +56,5 @@ sig
     val overflow_expression: unit -> Asm.exp
 
                                        (** creates registers if not done by default (see x86 and x64 mechanisms) *)
-    val init_registers: unit -> (Register.t * Data.Word.t) list 
-
+    val init_registers: unit -> unit
 end
diff --git a/ocaml/src/disassembly/decodeutils.ml b/ocaml/src/disassembly/decodeutils.ml
index c80f8de0..9a287222 100644
--- a/ocaml/src/disassembly/decodeutils.ml
+++ b/ocaml/src/disassembly/decodeutils.ml
@@ -36,9 +36,6 @@ let to33bits_s x = UnOp(SignExt 33, x)
 
 (** sign extension of a Z.int _i_ of _sz_ bits on _nb_ bits *)
 let sign_extension i sz nb =
-  if sz = nb then
-    i
-  else
     if Z.testbit i (sz-1) then
       let ff = (Z.sub (Z.shift_left (Z.one) nb) Z.one) in
       (* ffff00.. mask *)
@@ -102,14 +99,3 @@ let overflow_stmts sz res op1 op op2 =
   let c1          = Cmp (cmp_op, sign_op1, sign_op2)          in
   let c2          = Cmp (NEQ, sign_res, sign_op1)         in
   TernOp (BBinOp (LogAnd, c1, c2), const1 1, const0 1)
-
-(** returns the char list of the given string **)
-let string_to_char_list str =
-    let len = String.length str in
-    let rec process i =
-      if i < len then
-        (String.get str i)::(process (i+1))
-      else
-        []
-    in
-    List.rev (process 0)
diff --git a/ocaml/src/disassembly/powerpc.ml b/ocaml/src/disassembly/powerpc.ml
index 0d7feb60..00eea9e9 100644
--- a/ocaml/src/disassembly/powerpc.ml
+++ b/ocaml/src/disassembly/powerpc.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2018 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -21,7 +21,7 @@
 *)
 module L = Log.Make(struct let name = "powerpc" end)
 
-module Make(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := Domain.t)=
+module Make(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := Domain.t) =
 struct
 
   type ctx_t = unit
@@ -31,7 +31,7 @@ struct
   open Decodeutils
 
   module Cfa = Cfa.Make(Domain)
-               
+
   type state = {
     mutable g             : Cfa.t;        (** current cfa *)
     mutable b             : Cfa.State.t;  (** state predecessor *)
@@ -1270,5 +1270,5 @@ struct
 
   let overflow_expression () = Lval (V (P (cr, 28, 28)))
 
-  let init_registers () = []
+  let init_registers () = ()
 end
diff --git a/ocaml/src/disassembly/powerpcImports.ml b/ocaml/src/disassembly/powerpcImports.ml
index 505042db..1b832724 100644
--- a/ocaml/src/disassembly/powerpcImports.ml
+++ b/ocaml/src/disassembly/powerpcImports.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2018 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
diff --git a/ocaml/src/disassembly/riscVImports.ml b/ocaml/src/disassembly/riscVImports.ml
index 155d9e1d..414cc3f0 100644
--- a/ocaml/src/disassembly/riscVImports.ml
+++ b/ocaml/src/disassembly/riscVImports.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2019 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -18,95 +18,3 @@
 
 
 module L = Log.Make(struct let name = "riscVImports" end)
-module Make(D: Domain.T)(Stubs: Stubs.T with type domain_t := D.t) =
-  struct
-
-    open Asm
-    let reg r = V (T (Register.of_name r))
-    let const x sz = Const (Data.Word.of_int (Z.of_int x) sz)
-
-    let tbl: (Data.Address.t, Asm.import_desc_t * Asm.calling_convention_t) Hashtbl.t = Hashtbl.create 5
-    (* https://github.com/riscv/riscv-elf-psabi-doc/ *)
-    (* https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md *)
-    let integer_calling_convention = {
-        return = reg "x1";
-        callee_cleanup = (fun _ -> []);
-        arguments =
-          function
-          | 0 -> reg "x10"
-          | 1 -> reg "x11"
-          | 2 -> reg "x12"
-          | 3 -> reg "x13"
-          | 4 -> reg "x14"
-          | 5 -> reg "x15"
-          | 6 -> reg "x16"
-          | 7 -> reg "x17"
-          | n ->
-             let sz = !Config.operand_sz in
-             M (BinOp (Add, Lval (reg "x2"), const ((n-7)*sz) sz), sz)
-      }
-                                
-    let get_local_callconv cc =
-      match cc with
-      | Config.RISCVI -> integer_calling_convention
-      | c -> L.abort (fun p -> p "Calling convention [%s] not supported for RISC V architecture"
-                                    (Config.call_conv_to_string c))
-              
-    let get_callconv () = get_local_callconv !Config.call_conv
-
-    let stub_stmts_from_name name callconv =
-    if  Hashtbl.mem Stubs.stubs name then
-      [ Directive (Stub (name, callconv)) ]
-    else
-      [ Directive (Forget (reg "x2")) ]
-      
-    let init_imports () =
-    let default_cc = get_callconv () in
-    Hashtbl.iter (fun adrs (libname,fname) ->
-        let tainting_pro,tainting_epi, cc = Rules.tainting_rule_stmts libname fname (fun cc -> get_local_callconv cc) in
-        let cc' =
-          match cc with
-          | Some cc -> cc
-          | None -> default_cc
-        in
-        let typing_pro,typing_epi = Rules.typing_rule_stmts fname cc' in
-        let stub_stmts = stub_stmts_from_name fname cc' in
-        let fundesc:Asm.import_desc_t = {
-        name = fname ;
-        libname = libname ;
-        prologue = typing_pro @ tainting_pro ;
-        stub = stub_stmts ;
-        epilogue = typing_epi @ tainting_epi ;
-        ret_addr = Lval(reg "x30") ;
-      } in
-      Hashtbl.replace tbl (Data.Address.global_of_int adrs) (fundesc, cc')
-    ) Config.import_tbl
-
-    let init () =
-      Stubs.init();
-      init_imports ()
-
-    let skip fdesc a =
-        match fdesc with
-      | Some (fdesc', cc) ->
-         if Hashtbl.mem Config.funSkipTbl (Config.Fun_name fdesc'.Asm.name) then
-           let stmts = [Directive (Skip (Asm.Fun_name fdesc'.Asm.name, cc))]  in
-           { fdesc' with stub = stmts }
-         else
-           fdesc'
-        
-      | None ->
-         let ia = Data.Address.to_int a in
-         if Hashtbl.mem Config.funSkipTbl (Config.Fun_addr ia) then
-           {
-          name = "";
-          libname = "";
-          prologue = [];
-          stub = [];
-          epilogue = [] ;
-          ret_addr =Lval(reg "x1");
-           }
-         else
-           raise Not_found
-
-  end
diff --git a/ocaml/src/disassembly/risc_v.ml b/ocaml/src/disassembly/risc_v.ml
index 84699b7e..fd461e1d 100644
--- a/ocaml/src/disassembly/risc_v.ml
+++ b/ocaml/src/disassembly/risc_v.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2019 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -16,28 +16,15 @@
     along with BinCAT.  If not, see <http://www.gnu.org/licenses/>.
  *)
 
-(* implements at least RV32I and RV64I ISA as stated in spec v2.1
-https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf *)
+(* implements at least RV32I and RV64I ISA as stated in spec v2.2 *)
 module L = Log.Make(struct let name = "risc_v" end)
-
-(* XLEN refers to the width of an integer register in bits (either 32 or 64), see section 1.3) *)
-
-(* 32I ISA *)
-module I32 = struct let xlen = 32 end
-
-(* 64I ISA *)
-module I64 = struct let xlen = 64 end
-           
-module Make(Isa: sig val xlen: int end)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := Domain.t) =
+module Make(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := Domain.t) =
 struct
 
   type ctx_t = unit
 
   open Data
   open Asm
-  open Decodeutils
-     
-
   module Cfa = Cfa.Make(Domain)
              
   type state = {
@@ -45,484 +32,76 @@ struct
     mutable b: Cfa.State.t; (** state predecessor *)
     a: Address.t; (** current address to decode *)
     buf: string; (** buffer to decode *)
-    mutable operand_sz: int; (** operand size in bits *)
+    mutable addr_sz: int; (** address size in bits *)
     }
 
+  module Imports = RiscVImports.Make(Domain)(Stubs)
 
-  type type_kind =
-    | R | I | S
-    | B | U | J | IW (* I-immediate kind of word-size *)
- 
-  (************************************************************************)
+                   (************************************************************************)
   (* Creation of the general purpose registers *)
   (************************************************************************)
-
-  (* correspondence between ABI mnemonics and actual registers can be found
-     here: https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md#named-abis
-   *)
-
-  (* page 14: There is no dedicated stack pointer or subroutine return address link register in the Base Integer
-     ISA; the instruction encoding allows any x register to be used for these purposes. However, the
-     standard software calling convention uses register x1 to hold the return address for a call, with
-     register x5 available as an alternate link register. The standard calling convention uses register
-     x2 as the stack pointer *)
-  let (register_tbl: (int, Register.t) Hashtbl.t) = Hashtbl.create 33;;
-  let x0 = Register.make ~name:"x0" ~size:Isa.xlen;; (* hardcoded to zero *)
-  let x1 = Register.make ~name:"x1" ~size:Isa.xlen;; (* standard return address ; fallback is x5 *)
-  let x2 = Register.make_sp ~name:"x2" ~size:Isa.xlen;; (* standard stack pointer *)
-  let x3 = Register.make ~name:"x3" ~size:Isa.xlen;;
-  let x4 = Register.make ~name:"x4" ~size:Isa.xlen;;
-  let x5 = Register.make ~name:"x5" ~size:Isa.xlen;;
-  let x6 = Register.make ~name:"x6" ~size:Isa.xlen;;
-  let x7 = Register.make ~name:"x7" ~size:Isa.xlen;;
-  let x8 = Register.make ~name:"x8" ~size:Isa.xlen;;
-  let x9 = Register.make ~name:"x9" ~size:Isa.xlen;;
-  let x10 = Register.make ~name:"x10" ~size:Isa.xlen;;
-  let x11 = Register.make ~name:"x11" ~size:Isa.xlen;;
-  let x12 = Register.make ~name:"x12" ~size:Isa.xlen;;
-  let x13 = Register.make ~name:"x13" ~size:Isa.xlen;;
-  let x14 = Register.make ~name:"x14" ~size:Isa.xlen;;
-  let x15 = Register.make ~name:"x15" ~size:Isa.xlen;;
-  let x16 = Register.make ~name:"x16" ~size:Isa.xlen;;
-  let x17 = Register.make ~name:"x17" ~size:Isa.xlen;;
-  let x18 = Register.make ~name:"x18" ~size:Isa.xlen;;
-  let x19 = Register.make ~name:"x19" ~size:Isa.xlen;;
-  let x20 = Register.make ~name:"x20" ~size:Isa.xlen;;
-  let x21 = Register.make ~name:"x21" ~size:Isa.xlen;;
-  let x22 = Register.make ~name:"x22" ~size:Isa.xlen;;
-  let x23 = Register.make ~name:"x23" ~size:Isa.xlen;;
-  let x24 = Register.make ~name:"x24" ~size:Isa.xlen;;
-  let x25 = Register.make ~name:"x25" ~size:Isa.xlen;;
-  let x26 = Register.make ~name:"x26" ~size:Isa.xlen;;
-  let x27 = Register.make ~name:"x27" ~size:Isa.xlen;;
-  let x28 = Register.make ~name:"x28" ~size:Isa.xlen;;
-  let x29 = Register.make ~name:"x29" ~size:Isa.xlen;;
-  let x30 = Register.make ~name:"x30" ~size:Isa.xlen;;
-  let x31 = Register.make ~name:"x31" ~size:Isa.xlen;;
-
-  let reg_tbl = Hashtbl.create 32;;
-
-  List.iteri (fun i reg -> Hashtbl.add reg_tbl i reg) [
-      x0; x1; x2; x3; x4; x5; x6; x7; x8; x9; x10; x11; x12; x13; x14;
-      x15; x16; x17; x18; x19; x20; x21; x22; x23; x24; x25; x26; x27;
-      x28; x29; x30; x31 ];;
-
-  let get_register (i: int): lval = V ( T(Hashtbl.find reg_tbl i))
-                                  
-  module Imports = RiscVImports.Make(Domain)(Stubs)
-
-
-  (* opcode is bits 6 to 0 *)
-  let get_opcode (bits: int): int =
-    bits land 0x7f
-
-  let get_isn str =
-    (Char.code (String.get str 0))
-    lor ((Char.code (String.get str 1)) lsl 8)
-    lor ((Char.code (String.get str 2)) lsl 16)
-    lor ((Char.code (String.get str 3)) lsl 24)
-
-  (* returns an int from the l-th to u-th bits, left-shifted by o *)
-  let get_range_immediate bits l u o =
-    ((bits lsr l) land (lnot (-1 lsl (u-l+1)))) lsl o
-
-  let get_z_immediate bits o l u = Z.of_int (get_range_immediate bits o l u)
-
-  (* figure 2.4 *)
-  let i_core_immediate bits sz =
-    let z = get_z_immediate bits 20 31 0 in
-    sign_extension z 12 sz
-
-  let i_immediate bits = i_core_immediate bits Isa.xlen
-  let i_immediate_w bits = i_core_immediate bits 32
-
-  let s_immediate bits =
-    let z1 = get_z_immediate bits 7 11 0 in
-    let z2 = get_z_immediate bits 25 31 5 in
-    let z = Z.logor z1 z2 in
-    sign_extension z 12 Isa.xlen
-
-  let b_immediate bits =
-    let z1 = get_z_immediate bits 8 11 1 in
-    let z2 = get_z_immediate bits 25 30 5 in
-    let z3 = get_z_immediate bits 7 7 11 in
-    let z4 = get_z_immediate bits 31 31 12 in
-    let z = List.fold_left (fun z' zi -> Z.add z' zi) Z.zero [z1; z2; z3; z4] in  
-    sign_extension z 13 Isa.xlen
-
-  let u_immediate bits =
-    let z = get_z_immediate bits 12 31 12 in
-    sign_extension z 32 Isa.xlen
-
-  let j_immediate bits: Z.t =
-    let z1 = get_z_immediate bits 21 30 1 in
-    let z2 = get_z_immediate bits 20 20 11 in
-    let z3 = get_z_immediate bits 12 19 12 in
-    let z4 = get_z_immediate bits 31 31 20 in
-    let z = List.fold_left (fun z' zi -> Z.add z' zi) Z.zero [z1; z2; z3; z4] in
-    sign_extension z 21 Isa.xlen
-
-  (* the result is signed-extended *)
-  let get_immediate kind bits =
-    match kind with
-    | I -> i_immediate bits
-    | S -> s_immediate bits
-    | B -> b_immediate bits
-    | U -> u_immediate bits 
-    | J -> j_immediate bits
-    | IW -> i_immediate_w bits
-    | R -> L.abort (fun p -> p "no R-immediate defined in the spec")  
- 
-
-  (* figure 2.3, row B-type *)
-  let b_decode bits =                  
-    let funct3 = get_range_immediate bits 12 14 0 in
-    let rs1 = get_range_immediate bits 15 19 0 in
-    let rs2 = get_range_immediate bits 20 24 0 in
-    let offset = get_immediate B bits in
-    offset, rs1, rs2, funct3
-
-  (* figure 2.3, row J-type *)
-  let j_decode bits =
-    let rd = get_range_immediate bits 7 11 0 in
-    let imm = get_immediate J bits in
-    rd, imm
-
-  (* figure 2.3, row I-type *)
-  let i_core_decode bits =
-    let rd = get_range_immediate bits 7 11 0 in
-    let funct3 = get_range_immediate bits 12 14 0 in
-    let rs1 = get_range_immediate bits 15 19 0 in
-    rs1, funct3, rd
-
-  let i_decode bits =
-    let rs1, funct3, rd = i_core_decode bits in
-    get_immediate I bits, rs1, funct3, rd
-                    
-  (* RV64I special instruction of I-type *)
-  let iw_decode bits =
-    let rs1, funct3, rd = i_core_decode bits in
-    get_range_immediate bits 20 31 0, rs1, funct3, rd
-    
-  (* figure 2.3, row U-type *)
-  let u_decode bits =
-    let rd = get_range_immediate bits 7 11 0 in
-    let imm = get_immediate U bits in
-    imm, rd
-
-  (* figure 2.3, row R-type *)
-  let r_decode bits =
-    let funct7 = get_range_immediate bits 25 31 0 in
-    let rs2 = get_range_immediate bits 20 24 0 in
-    let rs1 = get_range_immediate bits 15 19 0 in
-    let funct3 = get_range_immediate bits 12 14 0 in
-    let rd = get_range_immediate bits 7 11 0 in
-    funct7, rs2, rs1, funct3, rd
-
-  (* figure 2.3, row S-type *)
-  let s_decode bits =
-    let rs1 = get_range_immediate bits 15 19 0 in
-    let rs2 = get_range_immediate bits 20 24 0 in
-    let funct3 = get_range_immediate bits 12 14 0 in
-    let imm = get_immediate S bits in
-    imm, rs1, rs2, funct3
-
-
-  (** fatal error reporting *)
-  let error a msg =
-    L.abort (fun p -> p "at %s: %s" (Address.to_string a) msg)
-
-  let return s str stmts =
-    s.b.Cfa.State.stmts <- stmts;
-    s.b.Cfa.State.bytes <- string_to_char_list str;
-    s.b, Data.Address.add_offset s.a (Z.of_int 4)
-    
-  let comparison s bits =
-    let offset, rs1, rs2, func3 = b_decode bits in
-    let bop =
-      match func3 with
-      | 0b000 -> (* beq *) EQ
-      | 0b001 -> (* bne *) NEQ
-      | 0b100 -> (* blt *) LTS
-      | 0b101 -> (* bge *) GES
-      | 0b110 -> (* bltu *) LT
-      | 0b111 -> (* bgeu *) GEQ
-      | _ -> L.abort (fun p -> p "undefined comparison opcode")
-    in
-    (* page 22: the offset is signed-extended and added to the address of the 
-       branch instruction to give the target address *)
-    let a' = Address.add_offset s.a offset in
-    [If (Cmp(bop, Lval (get_register rs1), Lval (get_register rs2)), [Jmp (A a')], [Nop])]
-
-  let const z = Const (Data.Word.of_int z Isa.xlen)
-  let const_w z = Const (Data.Word.of_int z 32)
-                
-  let jal s bits =
-    let rd, imm = j_decode bits in
-    let a = Data.Address.add_offset s.a imm in
-    if rd = 0 then
-      (* unconditional jump *)
-      [Jmp (A a)]
-    else
-      (* call *)
-      let a' = Data.Address.add_offset s.a (Z.of_int 4) in
-      [Set(get_register rd, Const (Data.Address.to_word a' Isa.xlen));
-       Call (A a)]
-
-  let jalr s bits =
-    let offset, rs1, _funct3, rd = i_decode bits in
-    (* The target address is obtained by adding the sign-extended 12-bit I-immediate 
-       to the register rs1, then setting the least-significant bit of the result to zero *)
-    let target = BinOp (And,
-                        BinOp(Add, Lval (get_register rs1), const offset),
-                        const (Z.of_int 0xFFFFFFFE))
-    in
-    if rd = 0 then
-      [Jmp (R target)]
-    else
-      let a' = Z.add (Data.Address.to_int s.a) (Z.of_int 4) in
-      [Set(get_register rd, const a');
-       Call (R target)]
-
-  let lui bits =
-    let imm, rd = u_decode bits in
-    if rd = 0 then []
-    else [ Set (get_register rd, const imm) ]
-
-  let auipc s bits =
-    let imm, rd = u_decode bits in
-    if rd = 0 then []
-    else
-      let c = Z.add (Data.Address.to_int s.a) imm in
-      [ Set(get_register rd, const c) ]
-
- 
-  let shift_imm bits rs1 is_left =
-    let b = if Isa.xlen = 32 then 25 else 26 in
-    let hi = get_range_immediate bits b 31 0 in
-    let lo = const (Z.of_int (get_range_immediate bits 20 (b-1) 0)) in
-    match hi, is_left with
-    | 0, true -> BinOp (Shl, rs1, lo)
-    | 0, false -> UnOp (ZeroExt Isa.xlen, BinOp (Shr, rs1, lo))
-    | 16, _ -> UnOp (SignExt Isa.xlen, BinOp (Shr, rs1, lo))
-    | _ -> L.abort (fun p -> p "illegal high bits for shift with immediate")
-    
-  let reg_imm bits =
-    let imm, rs1, funct3, rd = i_decode bits in
-    if rd = 0 then
-      []
-    else
-      let rs1 = Lval (get_register rs1) in
-      let c = const imm in
-      let binop op = BinOp (op, rs1, c) in
-      let ternop op = TernOp (Cmp (op, rs1, c), const Z.one, const Z.zero) in 
-      let e =
-        match funct3 with
-        | 0 -> (* addi *) binop Add
-        | 1 -> (* slli *) shift_imm bits rs1 true           
-        | 2 -> (* slti *) ternop LTS
-        | 3 -> (* sltiu *) ternop LT
-        | 5 -> (* slri / srai *) shift_imm bits rs1 false
-        | 4 -> (* xori *) binop Xor
-        | 6 -> (* ori *) binop Or
-        | 7 -> (* andi *) binop And
-        | _ -> L.abort (fun p -> p "undefined register immediate instruction")
-      in
-      [ Set (get_register rd, e) ]
-
-  let binop_imm_w op res rs1 rd imm ext =
-    [
-      Set(V (T res), BinOp(op, imm, rs1));
-      Set(rd, UnOp(ext, Lval (V (P(res, 0, 31)))));
-      Directive(Remove res)
-    ]
-    
-  let reg_imm_w bits =
-    let imm, rs1, funct3, rd = iw_decode bits in
-    let rs1 = Lval (V (P (Hashtbl.find reg_tbl rs1, 0, 31))) in
-    let rd = get_register rd in
-    match imm, funct3 with
-    | 0, 1 -> (* slliw *)
-       let c = const_w (Z.of_int imm) in
-       let res = Register.make (Register.fresh_name()) (32+imm) in
-       binop_imm_w Shl res rs1 rd c (ZeroExt Isa.xlen) 
-       
-    | imm, 0 -> (* addiw *)
-       let imm = Const (Word.of_int (sign_extension (Z.of_int imm) 12 32) 32) in
-       let res = Register.make (Register.fresh_name()) 33 in
-       binop_imm_w Add res rs1 rd imm (SignExt Isa.xlen)
-       
-    | 0, 5 -> (* srliw *) 
-       let c = const_w (Z.of_int imm) in
-       let res = Register.make (Register.fresh_name()) (32-imm) in
-       binop_imm_w Shl res rs1 rd c (ZeroExt Isa.xlen)
-       
-    | 32, 5 -> (* sraiw *)
-       let c = const_w (Z.of_int imm) in
-       let res = Register.make (Register.fresh_name()) (32-imm) in
-       binop_imm_w Shl res rs1 rd c (SignExt Isa.xlen)
-       
-    | _, _ -> L.abort (fun p -> p "undefined register-immediate instruction on words")
-
-  let reg_reg_w bits =
-    let funct7, rs2, rs1, funct3, rd = r_decode bits in
-    let rs1 = Lval (V (P (Hashtbl.find reg_tbl rs1, 0, 31))) in
-    let rs2 = Lval (V (P (Hashtbl.find reg_tbl rs2, 0, 31))) in
-    if rd = 0 then
-      []
-    else
-      let rd = get_register rd in
-      let op, sz, ext =
-        match funct3, funct7 with
-        | 0, 0 -> (* addw *) Add, 33, None
-        | 0, 32 -> (* subw *) Sub, 33, None
-        | 1, 0 -> (* sllw *) Shl, 32, None
-        | 5, 0 -> (* srlw *) Shr, 64, Some (ZeroExt 32)
-        | 5, 32 -> (* sraw *) Shr, 64, Some (SignExt 32)
-        | _, _ -> L.abort (fun p -> p "undefined (funct3, funct3) in .w instruction")
-      in
-      let aux = Register.make (Register.fresh_name()) sz in
-      let e = BinOp(op, rs1, rs2) in
-      let paux = Lval (V (P (aux, 0, 31))) in
-      let e' =
-        match ext with
-        | Some ext -> UnOp(ext, paux)
-        | None -> paux
-      in
-      [
-        Set(V (T aux), e);
-        Set(rd, e');
-        Directive(Remove aux)
-      ]
-      
-  let reg_reg bits =
-    let funct7, rs2, rs1, funct3, rd = r_decode bits in
-    if rd = 0 then
-      []
-    else
-      let r1 = Hashtbl.find reg_tbl rs1 in
-      let rs1' = Lval(V (T r1)) in
-      let rs2' = Lval(get_register rs2) in
-      let rd = get_register rd in
-      let bin_set op = [Set(rd, BinOp(op, rs1', rs2'))] in
-      let tern_set op = [Set (rd, TernOp(Cmp(op, rs1', rs2'), const Z.one, const Z.zero)) ] in
-      let low_bit_mask = const (Z.of_int (if Isa.xlen = 32 then 0x1f else 0x3f)) in
-      let reg_mask op = BinOp(op, rs1', BinOp(And, rs2', low_bit_mask)) in
-      match funct7, funct3 with
-      | 0, 0 -> bin_set Add
-      | 32, 0 -> bin_set Sub
-      | 0, 1 -> (* sll *) [ Set(rd, reg_mask Shl) ]
-      | 0, 2 -> (* slt *) tern_set LTS
-      | 0, 3 -> (* sltu *)
-         if rs1 = 0 then
-           let c = Cmp(NEQ, rs2', const Z.zero) in
-           [ Set(rd, TernOp(c, const Z.one, const Z.zero)) ]
-         else tern_set LT
-        
-      | 0, 4 -> bin_set Xor
-      | 0, 5 -> (* srl *) [ Set (rd, reg_mask Shr) ]
-      | 32, 5 -> (* sra *)
-         let e = reg_mask Shr in
-         [ Set(rd, UnOp(SignExt Isa.xlen, e)) ]
-         
-      | 0, 6 -> bin_set Or
-      | 0, 7 -> bin_set And
-      | _ -> L.abort (fun p -> p "undefined (funct7, funct3) pair in Register Register instruction")
-
-    
-  let load bits =
-    let imm, rs1, funct3, rd = i_decode bits in
-    if rd = 0 then
-      []
-    else
-      let rd = get_register rd in
-      let rs1 = get_register rs1 in
-      let off = const imm in
-      let mem = BinOp(Add, Lval rs1, off) in
-      let e =
-        match funct3 with
-        | 0 -> (* lb *) UnOp(SignExt Isa.xlen, Lval (M(mem, 8)))
-        | 1 -> (* lh *) UnOp(SignExt Isa.xlen, Lval (M(mem, 16)))
-        | 2 -> (* lw *) Lval (M(mem, 32))
-        | 4 -> (* lbu *) Lval (M(mem, 8))
-        | 5 -> (* lhu *) Lval (M(mem, 16))
-        | _ -> L.abort (fun p -> p "undefined funct3 for load")
-      in
-      [ Set(rd, e) ]
-
-  let store bits =
-    let imm, rs1, rs2, funct3 = s_decode bits in
-    let rs2 = Lval (get_register rs2) in
-    let rs1 = Hashtbl.find reg_tbl rs1 in
-    let imm = const imm in
-    let lval, sz =
-      match funct3 with
-      | 0 -> (* sb *) P (rs1, 0, 8), 0 
-      | 1 -> (* sh *) P (rs1, 0, 16), 16
-      | 2 -> (* sw *) T rs1, Isa.xlen
-      | _ -> L.abort (fun p -> p "undefined store kind")
-    in
-    let src = M(BinOp(Add, rs2, imm), sz) in 
-      [ Set (src, Lval (V lval)) ]
-        
-  let fence bits =
-    let funct3 = get_range_immediate bits 12 14 0 in
-    match funct3 with
-    | 0 (* fence *) | 1 (* fence.i *) -> []
-    | _ -> L.abort (fun p -> p "undefined funct3 for fence instructions")
+  let (register_tbl: (int, Register.t) Hashtbl.t) = Hashtbl.create 16;;
+  (*  let x0 = Register.make ~name:"x0" ~size:!Config.address_sz;; (* hardcoded to zero *) see Vol I*)
+  let x1 = Register.make ~name:"x1" ~size:!Config.address_sz;;
+  let x2 = Register.make ~name:"x2" ~size:!config.address_sz;;
+  let x3 = Register.make ~name:"x3" ~size:!config.address_sz;;
+  let x4 = Register.make ~name:"x4" ~size:!Config.address_sz;;
+  let x5 = Register.make ~name:"x5" ~size:!Config.address_sz;;
+  let x6 = Register.make ~name:"x6" ~size:!Config.address_sz;;
+  let x7 = Register.make ~name:"x7" ~size:!Config.address_sz;;
+  let x8 = Register.make ~name:"x8" ~size:!Config.address_sz;;
+  let x9 = Register.make ~name:"x9" ~size:!Config.address_sz;;
+  let x10 = Register.make ~name:"x10" ~size:!Config.address_sz;;
+  let x11 = Register.make ~name:"x11" ~size:!Config.address_sz;;
+  let x12 = Register.make ~name:"x12" ~size:!Config.address_sz;;
+  let x13 = Register.make ~name:"x13" ~size:!Config.address_sz;;
+  let x14 = Register.make ~name:"x14" ~size:!Config.address_sz;;
+  let x15 = Register.make ~name:"x15" ~size:!Config.address_sz;;
+  let x16 = Register.make ~name:"x16" ~size:!Config.address_sz;;
+  let x17 = Register.make ~name:"x17" ~size:!Config.address_sz;;
+  let x18 = Register.make ~name:"x18" ~size:!Config.address_sz;;
+  let x19 = Register.make ~name:"x19" ~size:!Config.address_sz;;
+  let x20 = Register.make ~name:"x20" ~size:!Config.address_sz;;
+  let x21 = Register.make ~name:"x21" ~size:!Config.address_sz;;
+  let x22 = Register.make ~name:"x22" ~size:!Config.address_sz;;
+  let x23 = Register.make ~name:"x23" ~size:!Config.address_sz;;
+  let x24 = Register.make ~name:"x24" ~size:!Config.address_sz;;
+  let x25 = Register.make ~name:"x25" ~size:!Config.address_sz;;
+  let x26 = Register.make ~name:"x26" ~size:!Config.address_sz;;
+  let x27 = Register.make ~name:"x27" ~size:!Config.address_sz;;
+  let x28 = Register.make ~name:"x28" ~size:!Config.address_sz;;
+  let x29 = Register.make ~name:"x29" ~size:!Config.address_sz;;
+  let x30 = Register.make ~name:"x30" ~size:!Config.address_sz;;
+  let x31 = Register.make ~name:"x31" ~size:!Config.address_sz;;
+
+  let get_opcode str =
+    String.get str 25
     
-  let decode (s: state): Cfa.State.t * Data.Address.t =
+  let decode s instr_sz: Cfa.State.t * Data.Address.t =
     let str = String.sub s.buf 0 4 in
-    let bits = get_isn str in
-    let opcode = get_opcode bits in 
-    let stmts =
-      match opcode with
-      (* RV32I *)
-      | 0b1100011 -> comparison s bits
-
-      | 0b1100111 -> jal s bits
-      | 0b1101111 -> jalr s bits
-
-      | 0b0110111 -> lui bits
-      | 0b0010111 -> auipc s bits
-
-      | 0b0010011 -> reg_imm bits
-
-      | 0b0110011 -> reg_reg bits
-
-      | 0b0000011 -> load bits
-
-      | 0b0100011 -> store bits
-
-      | 0b0001111 -> fence bits
-
-      (* RV64I *)
-      | 0b0011011 -> reg_imm_w bits
-      | 0b0111011 -> reg_reg_w bits
-                   
-      | _ -> error s.a (Printf.sprintf "unknown opcode %x\n" opcode)
-    in
-    return s str stmts
+    let opcode = get_opcode str in
+      match str with
     
-  let parse (text: string) cfg _ctx state addr _oracle =
+  let parse text cfg _ctx state addr oracle =
      let s =  {
       g = cfg;
       b = state;
       a = addr;
       buf = text;
-      operand_sz = Isa.xlen;
+      addr_sz = !Config.address_sz;
     }
     in
     try
-      let v', ip' = decode s in
+      let v' = decode s A in
+      let ip' = Data.Address.add_offset addr (s.addr_sz/8) in
       Some (v', ip', ())
     with
     | Exceptions.Error _ as e -> raise e
     | _  -> (*end of buffer *) None
 
-  let init_registers () = (); [x0, Data.Word.of_int Z.zero Isa.xlen]
-                          
-  let init () = Imports.init ()
-              
-  let overflow_expression () = failwith "Not implemented" (* see comment section 2.4, Vol 1 *)
+let init_registers () = ()
+  let init () =
+    Imports.init ()
+
+  let overflow_expression () = Failwith "Not implemented" (* see comment section 2.4, Vol 1 *)
 end
diff --git a/ocaml/src/disassembly/x64Imports.ml b/ocaml/src/disassembly/x64Imports.ml
index 14ede6c4..33fc8b43 100644
--- a/ocaml/src/disassembly/x64Imports.ml
+++ b/ocaml/src/disassembly/x64Imports.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2018 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -63,12 +63,6 @@ struct
               !Config.stack_width)
     }
 
-  let set_first_arg e =
-    let r = if !Config.call_conv = Config.SYSV then (reg "rdi") else (reg "rcx") in
-    [Set (r, e)]
-
-  let unset_first_arg () = []
-                               
   let get_local_callconv cc =
     match cc with
     | Config.SYSV -> sysv_calling_convention ()
diff --git a/ocaml/src/disassembly/x86Imports.ml b/ocaml/src/disassembly/x86Imports.ml
index f8f407e7..bbfdeafb 100644
--- a/ocaml/src/disassembly/x86Imports.ml
+++ b/ocaml/src/disassembly/x86Imports.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2018 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -31,7 +31,7 @@ struct
 
   let cdecl_calling_convention () = {
     return = reg "eax" ;
-    callee_cleanup = (fun _x -> []) ;
+    callee_cleanup = (fun _x -> [ ]) ;
     arguments = function
     | n -> M (BinOp (Add,
                      Lval (reg "esp"),
@@ -60,23 +60,6 @@ struct
 
   let get_callconv () = get_local_callconv !Config.call_conv
 
-  let set_first_arg e =
-    let r = reg "esp" in
-    [
-      Set (r, BinOp(Sub, Lval r, Const (Data.Word.of_int (Z.of_int (!Config.stack_width/8)) !Config.stack_width))) ;
-      Set (M(Lval r, !Config.stack_width), e)
-    ]
-    
-  let unset_first_arg () =
-    match !Config.call_conv with
-    | Config.CDECL ->
-       let r = reg "esp" in
-       [
-         Set (r, BinOp(Add, Lval r, Const (Data.Word.of_int (Z.of_int (!Config.stack_width/8)) !Config.stack_width)))
-       ]
-    | Config.STDCALL -> [] (* done by the callee *)
-    | cc -> L.abort (fun p -> p "Unset_first_arg: unsupported pour that calling convetion (%s)" (Config.call_conv_to_string cc))
-          
   let stub_stmts_from_name name callconv =
     if  Hashtbl.mem Stubs.stubs name then
       [ Directive (Stub (name, callconv)) ]
diff --git a/ocaml/src/domains/bit.ml b/ocaml/src/domains/bit.ml
index 5d58980a..b1a27ba6 100644
--- a/ocaml/src/domains/bit.ml
+++ b/ocaml/src/domains/bit.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -159,8 +159,6 @@ let compare v1 op v2 =
   | Asm.GEQ -> geq v2 v1
   | Asm.LT  -> lt v1 v2
   | Asm.GT  -> gt v1 v2
-  | Asm.LTS -> lt v1 v2 (* at bit level does make difference between signed and unsigned *)
-  | Asm.GES -> geq v1 v2 (* same remark as LTS *)
 
 let is_subset v1 v2 = eq v1 v2
 
diff --git a/ocaml/src/domains/domain.mli b/ocaml/src/domains/domain.mli
index 59b4f43a..a0952d23 100644
--- a/ocaml/src/domains/domain.mli
+++ b/ocaml/src/domains/domain.mli
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -46,8 +46,8 @@ module type T =
       (** forget the value of the given lvalue (ie set to top) *)
       val forget_lval: Asm.lval -> t -> t
 
-      (** add the given register to the given abstract value with an optional initial value *)
-      val add_register: Register.t -> t -> Data.Word.t option -> t
+      (** add the given register to the given abstract value *)
+      val add_register: Register.t -> t -> t
 
       (** string conversion. The int parameter is an id to be added to the generated string *)
       val to_string: t -> int -> string list
@@ -117,7 +117,7 @@ module type T =
       val taint_sources: Asm.exp -> t -> Taint.Set.t
 
       (** [set_type lv t m] type the left value lv with type t *)
-      val set_type: Asm.lval -> Types.t -> t -> t
+      (* val set_type: Asm.lval -> Types.t -> t -> t *)
 
 
       (** [get_address_of addr terminator upper_bound sz m] scans memory to get
@@ -166,7 +166,7 @@ number of copied bytes is returned *)
     (** [print_chars d src nb pad_options]
       print src until nb bytes are copied or null byte is found. If it found before nb bytes
       are copied then if pad_options = Some (pad_char, pad_left) it is padded with the char pad_char on the left if pad_left = true otherwise on the right *)
-      val print_chars: t -> Asm.exp -> int -> (char * bool) option -> t * int
+      val print_chars: t -> Asm.exp -> int -> (char * bool) option -> t
 
       (** [copy_register r dst src] returns dst with value of register r being replaced by its value in src *)
       val copy_register: Register.t -> t -> t -> t
diff --git a/ocaml/src/domains/pointer.ml b/ocaml/src/domains/pointer.ml
index 1f7d35f1..657907d0 100644
--- a/ocaml/src/domains/pointer.ml
+++ b/ocaml/src/domains/pointer.ml
@@ -19,14 +19,14 @@
 module L = Log.Make(struct let name = "pointer" end)
 
 module A = Data.Address
-         
+
 module Make (V: Vector.T) =
   (struct
     type t =
       | BOT
       | Val of (A.region * V.t) (** a pointer is a pair (r, o) where r is the region it points-to and o an offset in that region *)
       | TOP
-             
+
     let bot = BOT
     let top = TOP
     let is_bot p = p = BOT
@@ -63,7 +63,7 @@ module Make (V: Vector.T) =
         | Val (r, o) ->
            let s, t = V.to_strings o in
            Printf.sprintf "%s%s" (A.string_of_region r) s, t
-                      
+
     let untaint p =
       match p with
       | TOP | BOT  -> p
@@ -78,7 +78,7 @@ module Make (V: Vector.T) =
       match p with
       | TOP | BOT  -> p
       | Val (r, o) -> Val (r, V.span_taint o t)
-         
+
     let join p1 p2 =
       match p1, p2 with
       | BOT, p | p, BOT -> p
@@ -103,7 +103,7 @@ module Make (V: Vector.T) =
             else BOT
 
 
-                    
+
         let of_config c n =
           let r =
             match c with
@@ -127,7 +127,7 @@ module Make (V: Vector.T) =
               try Val (r1, V.meet o1 o2)
               with _ -> BOT
             else BOT
-              
+
     let unary op p =
       match p with
       | BOT  -> BOT
@@ -135,7 +135,7 @@ module Make (V: Vector.T) =
       | Val (r, o) ->
          try Val (r, V.unary op o)
          with _ -> BOT
-           
+
     let binary op p1 p2 =
       match p1, p2 with
       | BOT, _ | _, BOT      -> BOT
@@ -154,12 +154,12 @@ module Make (V: Vector.T) =
               if r1 = r2 then Val (r1, V.binary op o1 o2)
               else BOT
             with Exceptions.Too_many_concrete_elements _ -> TOP
-              
-              
+
+
     let of_word w = Val (A.Global, V.of_word w)
-      
+
     let of_addr (r, w): t = Val (r, V.of_word w)
-      
+
     let compare p1 op p2 =
       match p1, p2 with
       | BOT, BOT -> op = Asm.EQ || op = Asm.LEQ
@@ -171,13 +171,23 @@ module Make (V: Vector.T) =
          else
            if op = Asm.NEQ then true
            else false
-           
-    let to_addresses p =
-      match p with
-      | BOT  -> raise (Exceptions.Empty "pointer.to_addresses: undefined pointer")
-      | TOP  -> raise (Exceptions.Too_many_concrete_elements "pointer.to_addresses: imprecise pointer")
-      | Val (r, o) -> V.to_addresses r o
-         
+
+      let to_addresses_taint _p b =
+        L.info(fun p -> p "To address p-taint");
+        let addr = Mapped_mem.get_address_from_taint b in
+        Data.Address.Set.singleton addr
+
+      let to_addresses p b =
+        L.info(fun p -> p "To address pointer");
+        try
+          match p with
+          | BOT | TOP -> raise (Exceptions.Empty "")
+          | Val (r, o) -> V.to_addresses r o
+        with _ -> (
+          if Taint.is_tainted b then to_addresses_taint p b
+          else raise (Exceptions.Empty "pointer.to_address undefined or imprecise")
+        )
+
     let is_subset p1 p2 =
       match p1, p2 with
       | BOT, _ | _, TOP -> true
@@ -185,14 +195,14 @@ module Make (V: Vector.T) =
       | Val (r1, o1), Val (r2, o2) ->
          if r1 = r2 then V.is_subset o1 o2
          else false
-           
+
     let taint_of_config taint n prev: t * Taint.t =
       match prev with
       | Val (r, o) ->
          let o', taint' = V.taint_of_config taint n (Some o) in
          Val (r, o'), taint'
       | _      -> prev, Taint.BOT
-        
+
 
     let combine p1 p2 l u =
       L.debug2 (fun p -> p "Pointer.combine between %s and %s" (to_string p1) (to_string p2));
@@ -200,10 +210,10 @@ module Make (V: Vector.T) =
       | BOT, _ | _, BOT  -> BOT
       | TOP, _ | _, TOP  -> TOP
       | Val (r1, o1), Val (r2, o2) ->
-         if r1 = r2 then 
+         if r1 = r2 then
            Val (r1, V.combine o1 o2 l u)
          else BOT
-           
+
     let extract p l u =
       match p with
       | BOT | TOP  -> p
@@ -229,12 +239,12 @@ module Make (V: Vector.T) =
          let newoffset = V.of_repeat_val offset v_len nb in
          Val (region, newoffset)
 
-         
+
     let rec concat l =
-      L.debug2 (fun p -> p "concat len %d" (List.length l));
+
       match l with
       | [ ] -> BOT
-      | [v] -> v           
+      | [v] -> v
       | v::l' ->
          let v' = concat l' in
          match v, v' with
@@ -244,7 +254,7 @@ module Make (V: Vector.T) =
             if r1 = r2 then
               Val (r1, V.concat o1 o2)
             else BOT
-             
+
     let get_minimal_taint p =
       match p with
       | TOP -> Taint.TOP
@@ -268,5 +278,5 @@ module Make (V: Vector.T) =
       match p with
       | TOP | BOT -> p
       | Val (r, o) -> Val (r, V.forget_taint o)
-                        
+
     end: Unrel.T)
diff --git a/ocaml/src/domains/reduced_bit_tainting.ml b/ocaml/src/domains/reduced_bit_tainting.ml
index 44d442dd..2e26891c 100644
--- a/ocaml/src/domains/reduced_bit_tainting.ml
+++ b/ocaml/src/domains/reduced_bit_tainting.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -53,8 +53,8 @@ let core_sub_add op (v1, t1) (v2, t2) =
     match carry, res_taint with
     | B.ZERO, _   -> None
     | B.ONE, t    -> Some (B.ONE, t)
-    | B.TOP, T.U  -> Some (B.TOP, T.U)
-    | B.TOP, _    -> Some (B.TOP, T.TOP)
+    | B.TOP, t  -> Some (B.TOP, t)
+    (* | B.TOP, _    -> Some (B.TOP, T.TOP) *)
   in
   (res, res_taint), res_carry
 
diff --git a/ocaml/src/domains/reduced_unrel_typenv_heap.ml b/ocaml/src/domains/reduced_unrel_typenv_heap.ml
index c294fe45..3e9b6279 100644
--- a/ocaml/src/domains/reduced_unrel_typenv_heap.ml
+++ b/ocaml/src/domains/reduced_unrel_typenv_heap.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -53,7 +53,7 @@ module Make(D: Unrel.T) =
     in
     U.forget_lval lv uenv (H.check_status henv), tenv', henv
 
-  let add_register r (uenv, tenv, henv) w = U.add_register r uenv w, T.add_register r tenv, henv
+  let add_register r (uenv, tenv, henv) = U.add_register r uenv, T.add_register r tenv, henv
 
   let to_string (uenv, tenv, henv) id = (U.to_string uenv id) @ (T.to_string tenv) @ (H.to_string henv)
 
@@ -213,8 +213,7 @@ module Make(D: Unrel.T) =
 
 
   let print_chars (uenv, _tenv, henv) src sz pad_options =
-    let uenv', len = U.print_chars uenv src sz pad_options (H.check_status henv) in
-    (uenv', T.top, henv), len
+    U.print_chars uenv src sz pad_options (H.check_status henv), T.top, henv
 
   let copy_until (uenv, tenv, henv) dst arg terminator term_sz upper_bound with_exception pad_options =
     let len, uenv' = U.copy_until uenv dst arg terminator term_sz upper_bound with_exception pad_options (H.check_status henv) in
diff --git a/ocaml/src/domains/unrel.ml b/ocaml/src/domains/unrel.ml
index b96d8b90..fae5ed72 100644
--- a/ocaml/src/domains/unrel.ml
+++ b/ocaml/src/domains/unrel.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -28,7 +28,7 @@ module type T =
   sig
     (** abstract data type *)
     type t
- 
+
     (** bottom value *)
     val bot: t
 
@@ -57,7 +57,7 @@ module type T =
 
     (** converts an address into an abstract value *)
     val of_addr: Data.Address.t -> t
-      
+
     (** comparison.
     Returns true whenever the concretization of the first parameter is included in the concretization of the second parameter *)
     val is_subset: t -> t -> bool
@@ -90,7 +90,9 @@ module type T =
     val combine: t -> t -> int -> int -> t
 
     (** converts an abstract value into a set of concrete adresses *)
-    val to_addresses: t -> Data.Address.Set.t
+    val to_addresses: t -> Taint.t -> Data.Address.Set.t
+
+    val to_addresses_taint: t -> Taint.t -> Data.Address.Set.t
 
     (** [binary op v1 v2] return the result of v1 op v2 *)
     val binary: Asm.binop -> t -> t -> t
@@ -112,7 +114,7 @@ module type T =
 
     (** forgets the taint of the given value *)
     val forget_taint: t -> t
-      
+
     (** returns the sub value between bits low and up *)
     val extract: t -> int -> int -> t
 
@@ -134,17 +136,17 @@ module type T =
 
 module Make(D: T) =
   struct
-      
+
     (** type of the Map from Dimension (register or memory) to abstract values *)
     type t = D.t Env.t (* For Ocaml non-gurus : Env is a Map, indexed by Key, with values of D.t *)
 
 
     let empty = Env.empty
-              
+
     let top = Env.empty
-            
- 
-  
+
+
+
     let value_of_register m r =
       let v =
         try
@@ -159,13 +161,7 @@ module Make(D: T) =
         with Not_found -> raise (Exceptions.Empty (Printf.sprintf "unrel.value_of_string: register %s not found in environment" (Register.name r)))
       in D.to_string v
 
-    let add_register r m w =
-      let v =
-        match w with
-        | None -> D.top
-        | Some w' -> D.of_word w'
-      in
-      Env.add (Env.Key.Reg r) v m
+    let add_register r m = Env.add (Env.Key.Reg r) D.top m
 
     let remove_register v m = Env.remove (Env.Key.Reg v) m
 
@@ -187,12 +183,7 @@ module Make(D: T) =
       try Env.for_all2 D.is_subset m1 m2
       with _ ->
         try
-          Env.iteri (fun k v1 ->
-              try
-                let v2 = Env.find k m2 in
-                if not (D.is_subset v1 v2) then
-                  raise Exit
-              with Not_found -> ()) m1;
+          Env.iteri (fun k v1 -> try let v2 = Env.find k m2 in if not (D.is_subset v1 v2) then raise Exit with Not_found -> ()) m1;
           true
         with Exit -> false
 
@@ -306,13 +297,19 @@ module Make(D: T) =
           try
             snd (Env.find_key (where addr) map)
           with Not_found ->
-          L.debug (fun p -> p "Address %s not found in mapping, checking sections"
-                              (Data.Address.to_string addr));
           (* not in mem map, check file sections, again, will raise [Not_found] if not matched *)
           let mapped_mem = match !Mapped_mem.current_mapping with
             | None -> L.abort (fun p -> p "File not mmapped")
             | Some x -> x in
-          D.of_word (Mapped_mem.read mapped_mem addr) in
+          (* TODO(dm) CHECK ME*)
+          try
+            let read_value = Mapped_mem.read mapped_mem addr in
+            if Data.Word.to_int read_value < Z.of_int 0 then D.top
+            else D.of_word read_value
+          with _ ->
+            D.top
+          in
+          (* D.of_word (Mapped_mem.read mapped_mem addr) in *)
         let vals = map_or_revmap read_one_byte exp_addrs in
         let res = D.concat vals in
         L.debug (fun p -> p "get_mem_value result : %s" (D.to_string res));
@@ -388,7 +385,7 @@ module Make(D: T) =
       let endianness' = match endianness with
         | None -> !Config.endianness
         | Some x -> x in
-      L.debug (fun p -> p "write_in_memory (addr=%s, value=%s, size=%d bits, %s)" 
+      L.debug (fun p -> p "write_in_memory (addr=%s, value=%s, size=%d bits, %s)"
                           (Data.Address.to_string addr) (D.to_string value) sz
                           (Config.endianness_to_string endianness'));
       let nb = sz / 8 in
@@ -431,7 +428,7 @@ module Make(D: T) =
       let new_mem = List.mapi (fun i addr -> (addr, (D.extract value (i*8) ((i+1)*8-1)))) addrs in
       do_update new_mem domain
 
-                
+
     (***************************)
     (* Non mem functions  :)   *)
     (***************************)
@@ -445,8 +442,6 @@ module Make(D: T) =
       | Asm.GEQ -> Asm.LT
       | Asm.LEQ -> Asm.GT
       | Asm.GT  -> Asm.LEQ
-      | Asm.GES -> Asm.LTS
-      | Asm.LTS -> Asm.GES
 
 
 
@@ -455,11 +450,10 @@ module Make(D: T) =
         the resulting expression is tainted
     *)
     let rec eval_exp m e check_address_validity: (D.t * Taint.t) =
-      L.debug (fun p -> p "eval_exp(%s)" (Asm.string_of_exp e true));
       let rec eval (e: Asm.exp): D.t * Taint.t =
         match e with
-        | Asm.Const c                -> D.of_word c, Taint.U
-        | Asm.Lval (Asm.V (Asm.T r))         ->
+        | Asm.Const c -> D.of_word c, Taint.U
+        | Asm.Lval (Asm.V (Asm.T r)) ->
            begin
              try
                let v = Env.find (Env.Key.Reg r) m in
@@ -477,15 +471,15 @@ module Make(D: T) =
              | Not_found -> D.bot, Taint.U
            end
 
-        | Asm.Lval (Asm.M (e, n))            ->
+        | Asm.Lval (Asm.M (e, n)) ->
            begin
              let r, tsrc = eval e in
-             try
-               let addresses = Data.Address.Set.elements (D.to_addresses r) in
+             let addresses = Data.Address.Set.elements (D.to_addresses r tsrc)
+           in try
                let rec to_value a =
                  match a with
                  | [a]  ->
-                    check_address_validity a;
+                   check_address_validity a;
                    let v = get_mem_value m a n in
                    v, Taint.logor tsrc (D.taint_sources v)
 
@@ -517,7 +511,9 @@ module Make(D: T) =
            let v1, tsrc1 = eval e1 in
            let v2, tsrc2 = eval e2 in
            let v = D.binary op v1 v2 in
-           v, Taint.logor tsrc1 (Taint.logor tsrc2  (D.taint_sources v))
+           let first_part = Taint.logor tsrc2 (D.taint_sources v) in
+           let tsrc = Taint.logor tsrc1 first_part in
+           v, tsrc
 
         | Asm.UnOp (op, e) ->
            let v, tsrc = eval e in
@@ -564,7 +560,7 @@ module Make(D: T) =
            if b then v1&&v2, Taint.logand b1 b2
            else v1||v2, Taint.logor b1 b2
 
-        | Asm.Cmp (cmp, e1, e2)   -> 
+        | Asm.Cmp (cmp, e1, e2)   ->
            let cmp' = if b then cmp else inv_cmp cmp in
            compare_env m e1 cmp' e2 check_address_validity
       in
@@ -575,13 +571,13 @@ module Make(D: T) =
       let v2, tsrc2 = eval_exp env e2 check_address_validity in
       D.compare v1 op v2, Taint.logor tsrc1 tsrc2
 
-    let forget_lval lv m' check_address_validity = 
+    let forget_lval lv m' check_address_validity =
       match lv with
       | Asm.V (Asm.T r) -> forget_reg m' r None
       | Asm.V (Asm.P (r, l, u)) -> forget_reg m' r (Some (l, u))
       | Asm.M (e, n) ->
-         let v, _b = eval_exp m' e check_address_validity in
-         let addrs = D.to_addresses v in
+         let v, b = eval_exp m' e check_address_validity in
+         let addrs = D.to_addresses v b in
          let l     = Data.Address.Set.elements addrs in
          List.fold_left (fun m a ->  write_in_memory a m D.top n true check_address_validity) m' l
 
@@ -628,10 +624,10 @@ module Make(D: T) =
           val_restrict m' e1 v1 op e2 v2, Taint.logor b1 b2
         else
           raise (Exceptions.Empty "Unrel.compare")
-      
+
     let mem_to_addresses m' e check_address_validity =
       let v, b = eval_exp m' e check_address_validity in
-      let addrs = D.to_addresses v in
+      let addrs = D.to_addresses v b in
       (* check whether the address is allowed to be dereferenced *)
       (* could be put elsewhere with a set of forbidden addresses to check (e.g. range of low addresses) *)
       Data.Address.Set.iter (fun a -> if Data.Address.is_null a then raise (Exceptions.Null_deref (Asm.string_of_exp e true))) addrs;
@@ -685,15 +681,16 @@ module Make(D: T) =
 
     let set_to_memory dst_exp dst_sz v' m' b check_address_validity =
       let v, b' = eval_exp m' dst_exp check_address_validity in
-      let addrs = D.to_addresses v in
-      try
+      let addrs = D.to_addresses v b'
+      in try
         let l     = Data.Address.Set.elements addrs in
-        let t' = Taint.logor b b' in
-        match l with
-        | [a] -> (* strong update *) write_in_memory a m' v' dst_sz true check_address_validity, t'
-        | l   -> (* weak update *) List.fold_left (fun m a -> write_in_memory a m v' dst_sz false check_address_validity) m' l, t'
+          let t' = Taint.logor b b' in
+          match l with
+          | [a] -> (* strong update *) write_in_memory a m' v' dst_sz true check_address_validity, t'
+          | l   -> (* weak update *) List.fold_left (fun m a -> write_in_memory a m v' dst_sz false check_address_validity) m' l, t'
       with
       | Exceptions.Too_many_concrete_elements "unrel.set" -> Env.empty, Taint.TOP
+      | _ -> (L.info(fun p -> p "Other exp"); Env.empty, Taint.TOP)
 
     let set_to_register r v' m' =
       match r with
@@ -701,8 +698,8 @@ module Make(D: T) =
       | Asm.P (r', low, up) ->
          let prev = Env.find (Env.Key.Reg r') m' in
            Env.replace (Env.Key.Reg r') (D.combine prev v' low up) m'
-         
-             
+
+
     let set dst src m' check_address_validity: (t * Taint.t) =
       let v', _ = eval_exp m' src check_address_validity in
          let v' = span_taint m' src v' in
@@ -718,7 +715,7 @@ module Make(D: T) =
                   set_to_register r v' m', b
                 with Not_found -> raise (Exceptions.Empty "Unrel.set (register case)"), Taint.BOT
               end
-                
+
            | Asm.M (e, n) ->
               try
                 set_to_memory e n v' m' b check_address_validity
@@ -744,7 +741,7 @@ module Make(D: T) =
         else
           let m' = Env.empty in
           Env.fold (fun k v1 m' ->
-              try                
+              try
                 let v2 = Env.find k m2 in
                 let v' = D.meet v1 v2 in
                 if D.is_bot v' then
@@ -771,23 +768,23 @@ module Make(D: T) =
         else
           sz
 
-   
+
 
     let extract_taint_src_ids taint =
       let extract acc taint =
         match taint with
         | Config.Taint_all id
-        | Config.Taint (_, id) 
-        | Config.TMask (_, _, id)  
-        | Config.TBytes (_, id) 
+        | Config.Taint (_, id)
+        | Config.TMask (_, _, id)
+        | Config.TBytes (_, id)
         | Config.TBytes_Mask (_, _, id) -> id::acc
         | Config.Taint_none -> acc
-      in 
-      List.fold_left extract [] taint 
-   
+      in
+      List.fold_left extract [] taint
+
     (** builds an abstract tainted value from a config concrete tainted value *)
     let of_config (content, (taint: Config.tvalue list)) sz: (D.t * Taint.t) =
-      let v' = D.of_config content sz in  
+      let v' = D.of_config content sz in
       if taint = [] then
         (v', Taint.U)
       else
@@ -813,6 +810,7 @@ module Make(D: T) =
          Env.replace k v' m', taint
 
     let span_taint_to_addr a taint m': t * Taint.t =
+      L.info2(fun p -> p "Span taint to addr");
       let k = Env.Key.Mem a in
       let v = Env.find k m' in
       let v' = D.span_taint v taint in
@@ -821,7 +819,7 @@ module Make(D: T) =
 
     let forget_taint m = Env.map (fun v -> D.forget_taint v) m
 
-                 
+
     let taint_in_memory a m taint sz strong =
       let addrs = get_addr_list a (sz/8) in
       let update_one_key a (m, prev_taint): D.t Env.t * Taint.t =
@@ -855,17 +853,17 @@ module Make(D: T) =
     let get_taint lv m check_address_validity =
       let _, taint = eval_exp m (Asm.Lval lv) check_address_validity in
       taint
-                       
+
     let taint_lval lv taint check_address_validity m: t * Taint.t =
       match lv with
       | Asm.V (Asm.T r) -> span_taint_to_register r taint m
       | Asm.V (Asm.P (r, _l, _u)) -> span_taint_to_register r Taint.TOP m (* TODO: could be more precise *)
       | Asm.M (e, sz) ->
          try
-           let v, _ = eval_exp m e check_address_validity in
-           let addrs = D.to_addresses v in
+           let v, t = eval_exp m e check_address_validity in
+           let addrs = D.to_addresses v t in
            let l = Data.Address.Set.elements addrs in
-           begin 
+           begin
              match l with
              | [a] -> taint_in_memory a m taint sz true
              | _  -> List.fold_left (fun (m, prev_t) a ->
@@ -873,11 +871,11 @@ module Make(D: T) =
                        m', Taint.join prev_t taint') (m, Taint.U) l
            end
          with _ -> forget_taint m, Taint.TOP
-         
-         
+
+
     let set_memory_from_config addr ((content: Config.cvalue option), (taint: Config.tvalue list)) nb check_address_validity domain': t * Taint.t =
-      L.debug (fun p->p "Unrel.set_memory_from_config");  
-      let taint_srcs = extract_taint_src_ids taint in          
+      L.debug (fun p->p "Unrel.set_memory_from_config");
+      let taint_srcs = extract_taint_src_ids taint in
       let m', taint, sz =
         match content with
         | None ->
@@ -895,7 +893,7 @@ module Make(D: T) =
                  m, t
              in
              let m', taint = repeat (domain', Taint.U) 0 in
-             m', taint, taint_sz                
+             m', taint, taint_sz
            end
         | Some content' ->
            let sz = Config.size_of_content content' in
@@ -914,12 +912,12 @@ module Make(D: T) =
              write_in_memory ~endianness:endianness addr domain' v' sz true check_address_validity, taint, sz
       in
       List.iter (fun id -> if not (Hashtbl.mem Dump.taint_src_tbl id) then
-                             Hashtbl.add Dump.taint_src_tbl id (Dump.M(addr, sz*nb))) taint_srcs;  
+                             Hashtbl.add Dump.taint_src_tbl id (Dump.M(addr, sz*nb))) taint_srcs;
       m', taint
 
 
 
-    let set_register_from_config r (content, taint) m': t * Taint.t =     
+    let set_register_from_config r (content, taint) m': t * Taint.t =
       let taint_srcs = extract_taint_src_ids taint in
       List.iter (fun id ->
           if not (Hashtbl.mem Dump.taint_src_tbl id) then
@@ -930,16 +928,16 @@ module Make(D: T) =
          let v = Env.find k m' in
          let v', taint' =  D.taint_of_config taint (Register.size r) v in
          Env.replace k v' m', taint'
-      | Some c ->  
+      | Some c ->
          let sz = Register.size r in
 
-            let vt, taint = of_config  (c, taint) sz in               
+            let vt, taint = of_config  (c, taint) sz in
             Env.replace (Env.Key.Reg r) vt m', taint
 
-            
+
     let set_lval_to_addr lv (region, word) m check_address_validity =
       (* TODO: should we taint the lvalue if the address to set is tainted ? *)
-      L.debug2 (fun p -> p "entering set_lval_to_addrs with lv = %s" (Asm.string_of_lval lv true));  
+      L.debug2 (fun p -> p "entering set_lval_to_addrs with lv = %s" (Asm.string_of_lval lv true));
          match lv with
          | Asm.M (e, n) ->
             if n <> !Config.address_sz then
@@ -958,15 +956,15 @@ module Make(D: T) =
                         m', Taint.logor taint taint', Z.add i Z.one) (m, Taint.U, Z.zero) bytes
                   in
                   m', taint
-                with _ -> raise (Exceptions.Empty "set_lval_to_addr: invalid dereference"), Taint.BOT 
+                with _ -> raise (Exceptions.Empty "set_lval_to_addr: invalid dereference"), Taint.BOT
               end
-              
+
          | Asm.V r ->
             let v = D.of_addr (region, word) in
             try
               set_to_register r v m, Taint.U
             with Not_found -> raise (Exceptions.Empty (Printf.sprintf "set_lval_to_addr: register %s not found" (Asm.string_of_reg r))), Taint.BOT
-            
+
     let value_of_exp m e check_address_validity =
       D.to_z (fst (eval_exp m e check_address_validity))
 
@@ -977,12 +975,12 @@ module Make(D: T) =
 
     let i_get_bytes (addr: Asm.exp) (cmp: Asm.cmp) (terminator: Asm.exp) (upper_bound: int) (sz: int) (m': t) (with_exception: bool) pad_options check_address_validity: (int * D.t list) =
 
-      L.debug(fun p -> p "i_get_bytes addr=%s cmp='%s' terminator=%s upper_bound=%i sz=%i"
+      L.debug(fun p -> p "i_get_bytes addr=%s cmp=%s terminator=%s upper_bound=%i sz=%i"
         (Asm.string_of_exp addr true) (Asm.string_of_cmp cmp)
         (Asm.string_of_exp terminator true) upper_bound sz);
-    
-         let v, _ = eval_exp m' addr check_address_validity in
-         let addrs = Data.Address.Set.elements (D.to_addresses v) in
+
+         let v, t = eval_exp m' addr check_address_validity in
+         let addrs = Data.Address.Set.elements (D.to_addresses v t) in
          let term = fst (eval_exp m' terminator check_address_validity) in
          let off = sz / 8 in
          let rec find (a: Data.Address.t) (o: int): (int * D.t list) =
@@ -991,6 +989,7 @@ module Make(D: T) =
              else o, []
            else
              let a' = Data.Address.add_offset a (Z.of_int o) in
+             L.info2(fun p -> p "i_get_bytes");
              let v = get_mem_value m' a' sz in
              if D.compare v cmp term then
                match pad_options with
@@ -1039,13 +1038,13 @@ module Make(D: T) =
         len, bytes
       with Not_found -> raise (Exceptions.Too_many_concrete_elements "unrel.get_bytes")
 
-    let get_offset_from e cmp terminator upper_bound sz m check_address_validity = fst (i_get_bytes e cmp terminator upper_bound sz m true None check_address_validity) 
+    let get_offset_from e cmp terminator upper_bound sz m check_address_validity = fst (i_get_bytes e cmp terminator upper_bound sz m true None check_address_validity)
 
     let copy_register r dst' src' =
       let k = Env.Key.Reg r in
       let v = Env.find k src' in
       Env.replace k v dst'
-      
+
 
 
     (* Remove the prefix of the string, if needed
@@ -1066,8 +1065,9 @@ module Make(D: T) =
       L.debug (fun p->p "strip, after: %s" res);
       res
 
-    let copy_until m' dst e terminator term_sz upper_bound with_exception pad_options check_address_validity: int * t =  
-       let addrs = Data.Address.Set.elements (D.to_addresses (fst (eval_exp m' dst check_address_validity))) in
+    let copy_until m' dst e terminator term_sz upper_bound with_exception pad_options check_address_validity: int * t =
+      let r, t = eval_exp m' dst check_address_validity in
+       let addrs = Data.Address.Set.elements (D.to_addresses r t) in
        (* TODO optimize: m is pattern matched twice (here and in i_get_bytes) *)
        let len, bytes = i_get_bytes e Asm.EQ terminator upper_bound term_sz m' with_exception pad_options check_address_validity in
        let copy_byte a m' strong =
@@ -1085,7 +1085,7 @@ module Make(D: T) =
          | [] -> raise (Exceptions.Empty "unrel.copy_until")
        in
        len, m'
-   
+
 
     (* print nb bytes on stdout as raw string *)
     let print_bytes bytes nb =
@@ -1103,11 +1103,10 @@ module Make(D: T) =
 
     let print_chars m' src nb pad_options check_address_validity =
       (* TODO: factorize with copy_until *)
-      let len, bytes = i_get_bytes src Asm.EQ (Asm.Const (Data.Word.of_int Z.zero 8)) nb 8 m' false pad_options check_address_validity
-      in
-      print_bytes bytes len;
-      m', len
-       
+      let bytes = snd (i_get_bytes src Asm.EQ (Asm.Const (Data.Word.of_int Z.zero 8)) nb 8 m' false pad_options check_address_validity) in
+      print_bytes bytes nb;
+      m'
+
 
     let copy_chars_to_register m reg offset src nb pad_options check_address_validity =
      let terminator = Asm.Const (Data.Word.of_int Z.zero 8) in
@@ -1133,7 +1132,7 @@ module Make(D: T) =
         with _ -> "?"
       in
       str, String.length str
-      
+
     let to_hex m src nb capitalise pad_option full_print _word_sz check_address_validity: string * int =
       let capitalise str =
         if capitalise then String.uppercase_ascii str
@@ -1193,8 +1192,8 @@ module Make(D: T) =
         (* TODO generalise to non concrete src value *)
       let _, src_tainted = (eval_exp m' src check_address_validity) in
       let str_src, len = to_hex m' src nb capitalise pad_option false word_sz check_address_validity in
-      let vdst = fst (eval_exp m' dst check_address_validity) in
-      let dst_addrs = Data.Address.Set.elements (D.to_addresses vdst) in
+      let vdst, taint = eval_exp m' dst check_address_validity in
+      let dst_addrs = Data.Address.Set.elements (D.to_addresses vdst taint) in
       match dst_addrs with
       | [dst_addr] ->
          let znb = Z.of_int nb in
@@ -1222,8 +1221,8 @@ module Make(D: T) =
     let copy_int m' dst src nb capitalise pad_option word_sz check_address_validity: t * int =
       let _, src_tainted = (eval_exp m' src check_address_validity) in
       let str_src, len = to_int m' src nb capitalise pad_option false word_sz check_address_validity in
-      let vdst = fst (eval_exp m' dst check_address_validity) in
-      let dst_addrs = Data.Address.Set.elements (D.to_addresses vdst) in
+      let vdst, taint = eval_exp m' dst check_address_validity in
+      let dst_addrs = Data.Address.Set.elements (D.to_addresses vdst taint) in
       match dst_addrs with
       | [dst_addr] ->
          let znb = Z.of_int nb in
@@ -1247,8 +1246,8 @@ module Make(D: T) =
       | [] -> raise (Exceptions.Empty "unrel.copy_int")
       | _  -> Env.empty, len (* TODO could be more precise *)
 
-            
-    let print_hex m' src nb capitalise pad_option word_sz check_address_validity: t * int =      
+
+    let print_hex m' src nb capitalise pad_option word_sz check_address_validity: t * int =
       let str, len = to_hex m' src nb capitalise pad_option false word_sz check_address_validity in
       (* str is already stripped in hex *)
       Log.Stdout.stdout (fun p -> p "%s" str);
@@ -1259,30 +1258,31 @@ module Make(D: T) =
       let str, len = to_int m' src nb capitalise pad_option false word_sz check_address_validity in
       Log.Stdout.stdout (fun p -> p "%s" str);
       m', len
-      
+
     let copy m' dst arg sz check_address_validity: t =
     (* TODO: factorize pattern matching of dst with Interpreter.sprintf and with Unrel.copy_hex *)
     (* plus make pattern matching more generic for register detection *)
       let v = fst (eval_exp m' arg check_address_validity) in
-      let addrs = fst (eval_exp m' dst check_address_validity) in
-      match Data.Address.Set.elements (D.to_addresses addrs) with
-      | [a] -> write_in_memory a m' v sz true check_address_validity
-      | _::_ as l -> List.fold_left (fun m a -> write_in_memory a m v sz false check_address_validity) m' l
-      | [ ] -> raise (Exceptions.Empty "Unrel.copy")
-    
+      let addrs, taint = eval_exp m' dst check_address_validity in
+        match Data.Address.Set.elements (D.to_addresses addrs taint) with
+        | [a] -> write_in_memory a m' v sz true check_address_validity
+        | _::_ as l -> List.fold_left (fun m a -> write_in_memory a m v sz false check_address_validity) m' l
+        | [ ] -> raise (Exceptions.Empty "Unrel.copy")
+
 
     (* display (char) arg on stdout as a raw string *)
     let print m' arg _sz check_address_validity: unit =
-      let str = strip (D.to_string (fst (eval_exp m' arg check_address_validity))) in
-      let str' =
-        if String.length str <= 2 then
+      (* let str = strip (D.to_string (fst (eval_exp m' arg check_address_validity))) in *)
+      let str = strip(D.to_string (fst (eval_exp m' arg check_address_validity))) in
+      (* let str' =
+        if String.length str <= 2 then (
+          L.info(fun p -> p "dm(%s)" str);
           String.make 1 (Char.chr (Z.to_int (Z.of_string_base 16 str)))
-        else raise (Exceptions.Empty "Unrel.print")
-      in
-      Log.Stdout.stdout (fun p -> p "%s" str')
-      
+        )
+        else raise (Exceptions.Empty "Unrel.print") *)
+      let str' = String.make 1 (Char.chr (Z.to_int (Z.of_string_base 16 str)))
+      in Log.Stdout.stdout (fun p -> p "%s" str');
 
-   
   end
 
 
diff --git a/ocaml/src/domains/unrels.ml b/ocaml/src/domains/unrels.ml
index bea6c3fb..5f588e74 100644
--- a/ocaml/src/domains/unrels.ml
+++ b/ocaml/src/domains/unrels.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -17,7 +17,7 @@
  *)
 
 module L = Log.Make(struct let name = "unrels" end)
-         
+
 (* k-set of Unrel *)
 module Make(D: Unrel.T) =
   struct
@@ -29,14 +29,14 @@ module Make(D: Unrel.T) =
       | Val of ut list
 
     let init () = Val [U.empty, Log.History.new_ [] ""]
-                
+
     let bot = BOT
-            
+
     let is_bot m = m = BOT
 
     let imprecise_exn r =
       raise (Exceptions.Too_many_concrete_elements (Printf.sprintf "value of register %s is too much imprecise" (Register.name r)))
-      
+
     let value_of_register m r =
       match m with
       | BOT -> raise (Exceptions.Empty (Printf.sprintf "unrel.value_of_register:  environment is empty; can't look up register %s" (Register.name r)))
@@ -54,7 +54,7 @@ module Make(D: Unrel.T) =
            | None -> imprecise_exn r
            | Some v' -> v'
 
-         
+
     let string_of_register m r =
       match m with
       | BOT ->  raise (Exceptions.Empty (Printf.sprintf "string_of_register: environment is empty; can't look up register %s" (Register.name r)))
@@ -70,8 +70,8 @@ module Make(D: Unrel.T) =
       | BOT, _ -> true
       | _, BOT -> false
       | Val m1', Val m2' ->
-         List.for_all (fun (u1, _ids2) ->
-             List.exists (fun (u2, _ids1) -> U.is_subset u1 u2) m2') m1'
+         List.for_all (fun (u2, _ids2) ->
+             List.exists (fun (u1, _ids1) -> U.is_subset u1 u2) m1') m2'
 
     let remove_register r m =
       match m with
@@ -82,24 +82,27 @@ module Make(D: Unrel.T) =
        match m with
       | BOT -> BOT
       | Val m' -> Val (List.map (fun (u, ids) -> U.forget_lval lv u check_address_validity, ids) m')
-                
-    let add_register r m w =
+
+    let add_register r m =
       match m with
       | BOT -> BOT
-      | Val m' -> Val (List.map (fun (u, id) -> U.add_register r u w, id) m')
+      | Val m' -> Val (List.map (fun (u, id) -> U.add_register r u, id) m')
 
     let to_string m id =
       match m with
       | BOT    -> ["_"]
       | Val m' ->
+        if !Config.loglevel > 2 then
          List.fold_left (fun acc (u, id') ->
-                              let msg = Log.History.get_msg id' in
-                              (Printf.sprintf "\n[node %d - unrel %d]\ndescription =  %s" id id' msg)::((U.to_string u)@acc)
-                             ) [] m'
+            let msg = Log.History.get_msg id' in
+            (Printf.sprintf "\n[node %d - unrel %d]\ndescription =  %s" id id' (String.trim   msg))::((U.to_string u)@acc)
+            ) [] m'
+        else
+          [""]
 
     let imprecise_value_of_exp e =
       raise (Exceptions.Too_many_concrete_elements (Printf.sprintf "concretisation of expression %s is too much imprecise" (Asm.string_of_exp e true)))
-      
+
     let value_of_exp m e check_address_validity =
       match m with
       | BOT -> raise (Exceptions.Empty "unrels.value_of_exp: environment is empty")
@@ -116,7 +119,7 @@ module Make(D: Unrel.T) =
            | None -> imprecise_value_of_exp e
            | Some v' -> v'
 
-                             
+
     (* auxiliary function that will join all set elements *)
     let merge m =
       L.info2 (fun p -> p "threshold on unrel number is exceeded: merging all the unrels into one (join)");
@@ -124,9 +127,9 @@ module Make(D: Unrel.T) =
       | [] -> []
       | u::tl ->
          let u', pred = List.fold_left (fun (u', pred) (u, id) -> U.join u' u, id::pred) (fst u, [snd u]) tl in
-         [u', Log.History.new_ pred "merge"]
-                           
-               
+         [u', Log.History.new_ pred ""]
+
+
     let set dst src m check_address_validity: (t * Taint.Set.t) =
       L.debug2 (fun p -> p "set %s <- %s" (Asm.string_of_lval dst true) (Asm.string_of_exp src true));
       match m with
@@ -146,9 +149,9 @@ module Make(D: Unrel.T) =
              BOT, Taint.Set.singleton Taint.BOT
          else
            Val mres, t
-         
-  
-               
+
+
+
     let set_lval_to_addr lv addrs m check_address_validity =
       match m with
       | BOT -> BOT, Taint.Set.singleton Taint.BOT
@@ -164,7 +167,7 @@ module Make(D: Unrel.T) =
            List.fold_left (fun acc (a, msg) ->
                let m' =
                  List.map (fun (u, prev_id) ->
-                     let u', t = U.set_lval_to_addr lv a u check_address_validity in                     
+                     let u', t = U.set_lval_to_addr lv a u check_address_validity in
                      taint := Taint.Set.add t !taint;
                      let id = Log.History.new_ [prev_id] msg in
                      u', id) m'
@@ -174,7 +177,7 @@ module Make(D: Unrel.T) =
          in
          Val m2, !taint
 
-  
+
     let remove_duplicates m1 m2 =
       let one_check ulist (u, id) =
         if List.exists (fun (u', _id') -> U.is_subset u' u && U.is_subset u u') ulist then
@@ -190,7 +193,7 @@ module Make(D: Unrel.T) =
       let m1' = filter m1 in
       let m2' = filter m2 in
       List.fold_left one_check m1' m2'
-      
+
     let join m1 m2 =
       match m1, m2 with
       | BOT, m | m, BOT -> m
@@ -200,7 +203,7 @@ module Make(D: Unrel.T) =
          let m = remove_duplicates m1' m2' in
          (* check if the size of m exceeds the threshold *)
          if List.length m > !Config.kset_bound then
-           Val (merge (m1'@m2'))
+           Val ((merge m1' ) @ (merge m2'))
          else
            Val m
 
@@ -211,7 +214,7 @@ module Make(D: Unrel.T) =
           let u' = U.meet (fst u1) (fst u2) in
           if List.exists (fun (u, _) -> U.is_subset u' u && U.is_subset u u') m then m
           else
-            let id = Log.History.new_ [snd u1; snd u2] "meet" in
+            let id = Log.History.new_ [snd u1; snd u2] "" in
               (u', id)::m
         with Exceptions.Empty _ ->
           bot := true;
@@ -233,20 +236,16 @@ module Make(D: Unrel.T) =
            else
              Val m'
 
-    let widen prev_m m =
-      L.analysis (fun p -> p "************************ widening ************\n\n\n");
-      match prev_m, m with
+    let widen m1 m2 =
+      match m1, m2 with
       | BOT, m | m, BOT  -> m
-      | Val prev_m', Val m' ->
-         let mm1 = merge prev_m' in
-         let mm2 = merge m' in
+      | Val m1', Val m2' ->
+         let mm1 = merge m1' in
+         let mm2 = merge m2' in
          match mm1, mm2 with
          | [], _ | _, [] -> Val ([])
-         | (u1, id1)::_, (u2, id2)::_ ->
-            Val ([U.widen u1 u2, Log.History.new_ [id1 ; id2] "widen"])
+         | (u1, id1)::_, (u2, id2)::_ -> Val ([U.widen u1 u2, Log.History.new_ [id1 ; id2] ""])
 
-
-            
     let fold_on_taint m f =
       match m with
       | BOT -> BOT,  Taint.Set.singleton Taint.BOT
@@ -257,16 +256,16 @@ module Make(D: Unrel.T) =
                (u', id)::m, Taint.Set.add t' t) ([], Taint.Set.singleton Taint.U) m'
          in
          Val m', t'
-         
-    let set_memory_from_config a conf nb m check_address_validity: t * Taint.Set.t = 
+
+    let set_memory_from_config a conf nb m check_address_validity: t * Taint.Set.t =
       if nb > 0 then
         fold_on_taint m (U.set_memory_from_config a conf nb check_address_validity)
       else
         m, Taint.Set.singleton Taint.U
 
-         
+
     let set_register_from_config r conf m = fold_on_taint m (U.set_register_from_config r conf)
-         
+
     let taint_register_mask reg taint m = fold_on_taint m (U.taint_register_mask reg taint)
 
     let span_taint_to_register reg taint m = fold_on_taint m (U.span_taint_to_register reg taint)
@@ -276,7 +275,7 @@ module Make(D: Unrel.T) =
     let span_taint_to_addr a t m = fold_on_taint m (U.span_taint_to_addr a t)
 
     let taint_lval lv taint m check_address_validity = fold_on_taint m (U.taint_lval lv taint check_address_validity)
-                              
+
     let compare m check_address_validity e1 op e2 =
       L.debug2 (fun p -> p "compare: %s %s %s" (Asm.string_of_exp e1 true) (Asm.string_of_cmp op) (Asm.string_of_exp e2 true));
       match m with
@@ -284,7 +283,7 @@ module Make(D: Unrel.T) =
       | Val m' ->
          let bot = ref false in
          let mres, t = List.fold_left (fun (m', t) (u, msgs) ->
-                           try                            
+                           try
                              let ulist', tset' = U.compare u check_address_validity e1 op e2 in
                              List.fold_left (fun  m' u -> (u, msgs)::m') m' ulist', Taint.Set.singleton tset'
                            with Exceptions.Empty _ ->
@@ -309,7 +308,7 @@ module Make(D: Unrel.T) =
              try
                let addrs', t' = U.mem_to_addresses (fst u) e check_address_validity in
                Data.Address.Set.union addrs addrs', Taint.Set.add t' t
-             with _ -> addrs, t) (Data.Address.Set.empty, Taint.Set.singleton Taint.U) m' 
+             with _ -> addrs, t) (Data.Address.Set.empty, Taint.Set.singleton Taint.U) m'
 
     let taint_sources e m check_address_validity =
       match m with
@@ -332,7 +331,7 @@ module Make(D: Unrel.T) =
          match res with
          | Some o -> o
          | _ -> raise (Exceptions.Empty "Unrels.get_offset_from: undefined offset")
-            
+
     let get_bytes e cmp terminator (upper_bound: int) (sz: int) (m: t) check_address_validity =
           match m with
       | BOT -> raise (Exceptions.Empty "Unrels.get_bytes: environment is empty")
@@ -349,7 +348,7 @@ module Make(D: Unrel.T) =
                   else
                     raise (Exceptions.Empty "Unrels.get_bytes: incompatible set of bytes to return")
                 else
-                  raise (Exceptions.Empty "Unrels.get_bytes: incompatible set of bytes to return")       
+                  raise (Exceptions.Empty "Unrels.get_bytes: incompatible set of bytes to return")
              ) None m'
          in
          match res with
@@ -371,7 +370,7 @@ module Make(D: Unrel.T) =
                  match n with
                  | None -> Some n'
                  | Some n  ->
-                    if n = n' then Some n' 
+                    if n = n' then Some n'
                     else raise (Exceptions.Empty "diffrent lengths of  bytes copied in Unrels.copy_hex")
                in
                (u', msg)::acc, nn
@@ -394,7 +393,7 @@ module Make(D: Unrel.T) =
                  match n with
                  | None -> Some n'
                  | Some n  ->
-                    if n = n' then Some n' 
+                    if n = n' then Some n'
                     else raise (Exceptions.Empty "diffrent lengths of  bytes copied in Unrels.copy_int")
                in
                (u', msg)::acc, nn
@@ -406,10 +405,15 @@ module Make(D: Unrel.T) =
            | None -> raise (Exceptions.Empty "uncomputable length of  bytes copied in Unrels.copy_int")
          end
       | BOT -> BOT, 0
-             
+
     let print m arg sz check_address_validity =
+      L.info(fun p -> p "print-unrels");
       match m with
-      | Val m' -> List.iter (fun (u, _) -> U.print u arg sz check_address_validity) m'; m
+      | Val m' -> (
+        match m' with
+        | (u, _) :: _ -> U.print u arg sz check_address_validity
+        | _ ->  raise (Exceptions.Empty "Unrels.print: empty list")
+      ); m
       | BOT -> Log.Stdout.stdout (fun p -> p "_"); m
 
     let print_hex m src nb capitalise pad_option word_sz check_address_validity =
@@ -447,7 +451,7 @@ module Make(D: Unrel.T) =
        | BOT -> Log.Stdout.stdout (fun p -> p "_"); 0, BOT
        | Val m' ->
           match m' with
-          | [(u, msg)] ->
+          | (u, msg)::_ ->
              let len, u' = U.print_until u e terminator term_sz upper_bound with_exception pad_options check_address_validity in
              len, Val ([u', msg])
           | _ -> raise (Exceptions.Too_many_concrete_elements "U.print_until: implemented only for one unrel only")
@@ -459,17 +463,8 @@ module Make(D: Unrel.T) =
 
     let print_chars m src nb pad_options check_address_validity =
       match m with
-      | BOT ->
-         Log.Stdout.stdout (fun p -> p "_");
-         BOT, 0
-         
-      | Val ([u, msg]) ->
-         let u', len = U.print_chars u src nb pad_options check_address_validity in
-         Val ([u', msg]), len
-
-      | _ -> raise (Exceptions.Too_many_concrete_elements "U.print_chars: implemented only for one unrel only")
-         
-     
+      | Val m' -> Val (List.map (fun (u, msg) -> U.print_chars u src nb pad_options check_address_validity, msg) m')
+      | BOT -> Log.Stdout.stdout (fun p -> p "_"); BOT
 
     let copy_register r dst src =
       match src with
diff --git a/ocaml/src/domains/vector.ml b/ocaml/src/domains/vector.ml
index 52421ccd..f5907175 100644
--- a/ocaml/src/domains/vector.ml
+++ b/ocaml/src/domains/vector.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -56,11 +56,11 @@ sig
     (** abstract join *)
     val join: t -> t -> t
 
-    (** logical or on taint component only 
-        this function should only be called when the value of the 
+    (** logical or on taint component only
+        this function should only be called when the value of the
         two parameters are the same. No check done *)
     val taint_logor: t -> t -> t
-      
+
     (** abstract meet *)
     val meet: t -> t -> t
 
@@ -159,7 +159,7 @@ module type T =
 sig
     (** abstract data type *)
     type t
-      
+
     (** top on sz bit-width *)
     val top: int -> t
 
@@ -258,7 +258,7 @@ end
 module Make(V: Val) =
   (struct
     type t = V.t array (** bit order is big endian, ie v[0] is the most significant bit and v[Array.length v - 1] the least significant *)
-      
+
     let top sz = Array.make sz V.top
 
     let exists p v =
@@ -266,7 +266,7 @@ module Make(V: Val) =
         Array.iter (fun b -> if p b then raise Exit) v;
         false
       with Exit -> true
-        
+
     let exist2 p v1 v2 =
       let n = min (Array.length v1) (Array.length v2) in
       try
@@ -277,8 +277,8 @@ module Make(V: Val) =
       with
       | Exit -> true
       | _    -> false
-         
-         
+
+
     let for_all2 p v1 v2 =
       try
         for i = 0 to (Array.length v1)-1 do
@@ -287,15 +287,16 @@ module Make(V: Val) =
         true
       with
       | _-> false
-         
+
     let v_to_z conv v =
+      (* L.info(fun p -> p "V_to_Z"); *)
       let z = ref Z.zero in
       for i = 0 to (Array.length v) - 1 do
         let n = conv v.(i) in
         z := Z.add n (Z.shift_left !z 1)
       done;
       !z
-            
+
     let to_char (v: t): char =
       let l = Array.length v in
       if l <> 8 then
@@ -308,13 +309,13 @@ module Make(V: Val) =
           done;
           Char.chr !c
         end
-          
+
     let size v = Array.length v
-      
+
     let to_z v = v_to_z V.to_z v
     (* this function may raise an exception if one of the bits cannot be converted into a Z.t integer (one bit at BOT or TOP) *)
     let to_word conv v = Data.Word.of_int (v_to_z conv v) !Config.address_sz
-      
+
     let extract_strings v =
       let v' =
         if exists V.is_top v then
@@ -340,7 +341,7 @@ module Make(V: Val) =
           "0b"^Bytes.to_string taint_bytes
       in
       v', t
-        
+
     let to_string v =
       let v', t = extract_strings v in
       if String.compare t "0x0" == 0 then v'
@@ -358,17 +359,20 @@ module Make(V: Val) =
           v.(i) <- f v1.(i) v2.(i)
         done;
         v
-          
+
     let to_strings v = extract_strings v
-      
+
     let concat v1 v2 = Array.append v1 v2
-      
+
     let join v1 v2 = map2 V.join v1 v2
-      
+
     let meet v1 v2 = map2 V.meet v1 v2
-      
-    let widen v1 v2 = map2 V.widen v1 v2
-        
+
+    let widen v1 v2 =
+      if Z.compare (to_z v1) (to_z v2) <> 0 then
+        raise (Exceptions.Too_many_concrete_elements (Printf.sprintf "vector.widen with different vectors (v1=%s v2=%s)" (to_string v1) (to_string v2)))
+      else v1
+
     (* common utility to add and sub *)
     let core_add_sub op v1 v2 =
       let n = Array.length v1 and lv2 = (Array.length v2) in
@@ -394,9 +398,9 @@ module Make(V: Val) =
           | None   -> carry_borrow := c' (* correct as we know that we cannot have both cpred = Some ... and c' = Some ... *)
         done;
         v
-          
-          
-    let lt_core v1 v2 final is_signed =
+
+
+    let lt_core v1 v2 final =
       let lv1 = Array.length v1 in
       let lv2 = Array.length v2 in
       if lv1 <> lv2 then
@@ -410,22 +414,16 @@ module Make(V: Val) =
             | Some b -> b
             | None -> rec_lt v1 v2 (i+1)
         in
-        (* check whether v1 and v2 have the same sign *)
-        if not is_signed then
-          rec_lt v1 v2 0
-        else
-          (* correct as the comparison is performed only on bit values and not their taints, 
-             see Reduced_bit_taing.compare *)
-          if V.compare v1.(0) Asm.EQ v2.(0) then
-            rec_lt v1 v2 0
-          else
-            (* signs are different *)
-            V.is_one v1.(0)
-          
-    let lt v1 v2 is_signed = lt_core v1 v2 false is_signed
-    let leq v1 v2 is_signed = lt_core v1 v2 true is_signed
-    let gt v1 v2 = lt v2 v1 false
-    let geq v1 v2 is_signed = leq v2 v1 is_signed
+        let res = rec_lt v1 v2 0 in
+        L.debug2 (fun p -> p "lt_core %s %s %s = %b"
+          (to_string v1) (if final then "<=" else "<")
+          (to_string v2) res);
+        res
+
+    let lt v1 v2 = lt_core v1 v2 false
+    let leq v1 v2 = lt_core v1 v2 true
+    let gt v1 v2 = lt v2 v1
+    let geq v1 v2 = leq v2 v1
 
     let compare v1 op v2 =
       L.debug2 (fun p -> p "compare %s %s %s" (to_string v1) (Asm.string_of_cmp op) (to_string v2));
@@ -436,35 +434,34 @@ module Make(V: Val) =
       match op with
       | Asm.EQ  -> for_all2 (fun b1 b2 -> V.compare b1 op b2) v1 v2
       | Asm.NEQ -> exist2 (fun b1 b2 -> V.compare b1 op b2) v1 v2
-      | Asm.LT -> lt v1 v2 false
-      | Asm.LEQ -> leq v1 v2 false
+      | Asm.LT -> lt v1 v2
+      | Asm.LEQ -> leq v1 v2
       | Asm.GT -> gt v1 v2
-      | Asm.GEQ -> geq v1 v2 false
-      | Asm.LTS -> lt v1 v2 true
-      | Asm.GES -> geq v1 v2 true
-         
+      | Asm.GEQ -> geq v1 v2
+
+    (* let taint_sources v =
+      Array.fold_left (fun acc elt -> Taint.logor acc (V.get_taint elt)) (Taint.U) v *)
+
     let add v1 v2 =
       let res = core_add_sub V.add v1 v2 in
-      L.debug2 (fun p -> p "add(%s, %s) = %s"
-        (to_string v1) (to_string v2) (to_string res));
       res
-        
+
     let sub v1 v2 = core_add_sub V.sub v1 v2
-      
+
     let xor v1 v2 =
       let res = map2 V.xor v1 v2 in
       L.debug2 (fun p -> p "xor(%s, %s) = %s"
         (to_string v1) (to_string v2) (to_string res));
       res
-        
+
     let lognot v = Array.map V.lognot v
-      
+
     let neg v =
       let n = Array.length v in
       let one = Array.make n V.zero in
       one.(n-1) <- V.one;
       add (lognot v) one
-        
+
     let logand v1 v2 =
       let lv1 = (Array.length v1) and lv2 = (Array.length v2) in
       if lv1 <> lv2 then
@@ -486,7 +483,7 @@ module Make(V: Val) =
         L.debug2 (fun p -> p "logor(%s, %s)=%s"
           (to_string v1) (to_string v2) (to_string res));
         res
-          
+
     let sign_extend v i =
       let n = Array.length v in
       if n >= i then
@@ -504,7 +501,7 @@ module Make(V: Val) =
           done;
           v'
         end
-          
+
     let truncate v new_sz =
       let sz = Array.length v in
       L.debug (fun p -> p "truncate((%d)%s, %d)" sz (to_string v) new_sz);
@@ -517,7 +514,7 @@ module Make(V: Val) =
           res.(i) <- v.(i+sz-new_sz)
         done;
         res
-          
+
     let zero_extend v new_sz =
       let sz = Array.length v in
       L.debug2 (fun p -> p "zero_extend((%d)%s, %d)" sz (to_string v) new_sz);
@@ -542,7 +539,7 @@ module Make(V: Val) =
       L.debug2 (fun p -> p "ishl(%s, %d) = %s"
         (to_string v) shift (to_string res));
       res
-        
+
     let ishr v shift pad =
       let v_len = Array.length v in
       let res = Array.make v_len pad in
@@ -552,7 +549,7 @@ module Make(V: Val) =
       L.debug2 (fun p -> p "ishr(%s, %d) = %s"
         (to_string v) shift (to_string res));
       res
-        
+
     let irotate v shift =
       let v_len = Array.length v in
       let res = Array.make v_len V.zero in
@@ -562,8 +559,8 @@ module Make(V: Val) =
       L.debug2 (fun p -> p "irotate(%s,%d)=%s"
         (to_string v) shift (to_string res));
       res
-        
-        
+
+
     let shift_count_to_int v =
       let z_shift_count = to_z v in
       try
@@ -572,24 +569,24 @@ module Make(V: Val) =
         raise (Exceptions.Too_many_concrete_elements
                  (Printf.sprintf "vector.shr: shift count overflow: %s"
                     (Z.to_string z_shift_count)))
-          
-          
+
+
     let shl v1 v2 =
       let shift_count = shift_count_to_int v2 in
       ishl v1 shift_count
-        
+
     let shr v1 v2 =
       let shift_count = shift_count_to_int v2 in
       ishr v1 shift_count V.zero (* pad with zero *)
-        
+
     let _ashr v1 v2 =
       let shift_count = shift_count_to_int v2 in
       ishr v1 shift_count v1.(0) (* pad with high bit *)
-        
+
     let _rol v1 v2 =
       let shift_count = shift_count_to_int v2 in
       irotate v1 shift_count
-        
+
     let _ror v1 v2 =
       let shift_count = shift_count_to_int v2 in
       irotate v1 (-shift_count)
@@ -600,14 +597,14 @@ module Make(V: Val) =
       let nn   = 2*n in
       let v2_ext = zero_extend v2 nn    in
       let res = ref (Array.make nn V.zero) in
-      
+
       for i = 0 to n-1 do
         let v2_ext_shift = ishl v2_ext (n-i-1) in
         let v2_ext_shift_mul = Array.map (V.logand v1.(i)) v2_ext_shift in
         res := add !res v2_ext_shift_mul
       done;
       !res
-        
+
     let imul v1 v2 =
       L.debug2 (fun p -> p "imul((%d)%s, (%d)%s)"
         (Array.length v1) (to_string v1) (Array.length v2) (to_string v2));
@@ -620,7 +617,7 @@ module Make(V: Val) =
       let res = Array.sub fullres (v1_len*2) (v1_len*2) in
       L.debug2 (fun p -> p "imul return %s" (to_string res));
       res
-        
+
     (** return v1 / v2, modulo of v1 / v2 *)
     let core_div v1 v2 =
       let lv1   = Array.length v1    in
@@ -646,7 +643,7 @@ module Make(V: Val) =
             let rem = ref v1 in
             for i = !msb1 downto 0 do
               let sv2 = ishl v2_ext i in
-              if geq !rem sv2 false then
+              if geq !rem sv2 then
                 begin
                   rem := sub !rem sv2;
                   quo.(lv1-i-1) <- V.one;
@@ -660,7 +657,7 @@ module Make(V: Val) =
               (Array.length !rem) (to_string !rem));
             quo,!rem
         end
-          
+
     let is_neg v1 =
       V.is_one v1.(0) || V.is_top v1.(0)
 
@@ -700,28 +697,28 @@ module Make(V: Val) =
       | Asm.IMod -> imodulo v1 v2
       | Asm.Shl -> shl v1 v2
       | Asm.Shr -> shr v1 v2
-         
-         
+
+
     let unary op v =
       match op with
       | Asm.Not       -> lognot v
       | Asm.SignExt i -> sign_extend v i
       | Asm.ZeroExt i -> let res = zero_extend v i in L.debug2 (fun p -> p
         "zero_extend new length : %d" (Array.length res)); res
-        
+
     let untaint v = Array.map V.untaint v
-      
+
     let taint v = Array.map V.taint v
-      
+
     let span_taint v t = Array.map (V.update_taint t) v
-      
+
     let get_minimal_taint v =
       Array.fold_left (fun acc v -> Taint.min acc (V.get_taint v)) Taint.U v
-        
-        
+
+
     let nth_of_z_as_val v i = if Z.testbit v i then V.one else V.zero
     let nth_of_z v i = if Z.testbit v i then Z.one else Z.zero
-        
+
 
     (* real implementation of 'of_word' *)
     let of_word_real w =
@@ -749,12 +746,13 @@ module Make(V: Val) =
           Hashtbl.add !const_htbl w r;
           r
      end
-        
+
     let to_addresses r v =
+      L.debug2(fun p -> p "To Address V : %s" (to_string v));
       Data.Address.Set.singleton (r, to_word V.to_z v)
-      
+
     let is_subset v1 v2 = for_all2 V.is_subset v1 v2
-      
+
     let of_config c n =
       let v  = Array.make n V.top in
       let n' = n-1                in
@@ -805,11 +803,11 @@ module Make(V: Val) =
              else
                v.(n'-i) <- V.taint_logor v.(n'-i) v'
            done;
-           Taint.S (Taint.SrcSet.singleton (Taint.Src.Tainted tid)) 
-             
+           Taint.S (Taint.SrcSet.singleton (Taint.Src.Tainted tid))
+
         | Config.TBytes_Mask (b, m, tid) ->
            let get_byte s i = (Z.of_string_base 16 (String.sub s (i/4) 1)) in
-           for i = 0 to n' do           
+           for i = 0 to n' do
              if Z.testbit m i then
                let v' = V.forget_taint_src v.(n'-i) tid in
                if is_first then
@@ -824,7 +822,7 @@ module Make(V: Val) =
                  v.(n'-i) <- V.taint_logor v.(n'-i) v'
            done;
            Taint.S (Taint.SrcSet.singleton (Taint.Src.Tainted tid))
-             
+
         | Config.Taint (b, tid) ->
            for i = 0 to n' do
              let v' = V.taint_of_z (nth_of_z b i) v.(n'-i) tid in
@@ -835,7 +833,7 @@ module Make(V: Val) =
            done;
           if Z.compare b Z.zero = 0 then Taint.U
           else Taint.S (Taint.SrcSet.singleton (Taint.Src.Tainted tid))
-            
+
         | Config.Taint_all tid ->
            let n' =n-1 in
            for i = 0 to n' do
@@ -846,7 +844,7 @@ module Make(V: Val) =
                v.(n'-i) <- V.taint_logor v.(n'-i) v'
            done;
            Taint.S (Taint.SrcSet.singleton (Taint.Src.Tainted tid))
-             
+
         | Config.Taint_none ->
            let n' =n-1 in
            for i = 0 to n' do
@@ -857,7 +855,7 @@ module Make(V: Val) =
                v.(n'-i) <- V.taint_logor v.(n'-i) v'
            done;
            Taint.U
-             
+
         | Config.TMask (b, m, tid) ->
            let n' = n-1 in
            for i = 0 to n' do
@@ -872,7 +870,7 @@ module Make(V: Val) =
              else
                let v' = V.forget_taint_src v.(n'-i) tid in
                if is_first then
-                 v.(n'-i) <- v' 
+                 v.(n'-i) <- v'
                else
                v.(n'-i) <- V.taint_logor v.(n'-i) v'
            done;
@@ -887,7 +885,7 @@ module Make(V: Val) =
         v, taint'
       else
         v, Taint.U
-        
+
     let forget v opt =
       L.debug (fun (p: ('a, unit, string) format -> 'a) ->
         match opt with
@@ -930,6 +928,7 @@ module Make(V: Val) =
               v
             end
 
+
         let extract v low up =
           L.debug2 (fun p -> p "extract(%s, %d, %d), sz : %d" (to_string v) low up (Array.length v));
           let v' = Array.make (up-low+1) V.top in
@@ -956,6 +955,6 @@ module Make(V: Val) =
         let get_taint = taint_sources
 
         let forget_taint v =
-          Array.map (V.update_taint Taint.TOP) v       
-          
+          Array.map (V.update_taint Taint.TOP) v
+
     end: T)
diff --git a/ocaml/src/fixpoint/backward.ml b/ocaml/src/fixpoint/backward.ml
deleted file mode 100644
index 9dc4547d..00000000
--- a/ocaml/src/fixpoint/backward.ml
+++ /dev/null
@@ -1,198 +0,0 @@
-(*
-    This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
-
-    BinCAT is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Affero General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or (at your
-    option) any later version.
-
-    BinCAT is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Affero General Public License for more details.
-
-    You should have received a copy of the GNU Affero General Public License
-    along with BinCAT.  If not, see <http://www.gnu.org/licenses/>.
- *)
-
-
-module L = Log.Make(struct let name = "backward" end)
-open Asm
-   
-  
-module Make(D: Domain.T)(Cfa: Cfa.T with type domain = D.t)(Decoder: Decoder.T)
-         (Core:
-            sig
-              val cfa_iteration: (Cfa.t -> Cfa.State.t -> Data.Address.t -> Cfa.State.t list -> Cfa.State.t list) ->
-                                 (Cfa.t -> Cfa.State.t -> Cfa.State.t list) ->
-                                 (Cfa.t -> Cfa.State.t -> Cfa.State.t -> Cfa.State.t) ->
-                                 Cfa.t -> Cfa.State.t -> (Cfa.t -> unit) -> Cfa.t
-                
-              val update_abstract_value: Cfa.t -> Cfa.State.t -> (Cfa.State.t -> D.t) ->
-                                         Data.Address.t -> (Cfa.t -> Cfa.State.t -> Data.Address.t -> Cfa.State.t list) ->
-                                         Cfa.State.t list
-            end) =
-struct
-           
-    let shift_and_add shift len =
-      let one = Const (Data.Word.one len) in
-      let one' = Const (Data.Word.of_int (Z.of_int (len-1)) len) in
-      let shifted_one = BinOp (Asm.Shl, one, one') in
-      BinOp (Asm.Add, shift, shifted_one)
-      
-    let back_add_sub op dst e1 e2 d =
-      match e1, e2 with
-      | Lval lv1, Lval lv2 ->
-         if Asm.equal_lval lv1 lv2 then
-           if op = Asm.Sub then
-             let len = Asm.lval_length lv1 in
-             let shift = BinOp (Asm.Shr, Lval dst, Const (Data.Word.of_int (Z.of_int 1) len)) in
-             let d', taint =
-               try
-                 if Z.compare Z.one (D.value_of_exp d (Decoder.overflow_expression())) = 0 then
-                   D.set lv1 (shift_and_add shift len) d
-                 else
-                   D.set lv1 shift d
-               with _ ->
-                 let d1, taint1 = D.set lv1 shift d in
-                 let d2, taint2 = D.set lv1 (shift_and_add shift len) d in 
-                 D.join d1 d2, Taint.Set.union taint1 taint2
-             in
-             if Asm.with_lval dst (Lval lv1) then
-               d', taint
-             else D.forget_lval dst d', taint
-           else
-             D.forget_lval dst d, Taint.Set.singleton Taint.TOP
-         else
-           if (Asm.with_lval dst e1) || (Asm.with_lval dst e2) then 
-             D.set lv1 (BinOp (op, Lval dst, e2)) d
-           else D.forget_lval dst d, Taint.Set.singleton Taint.TOP
-        
-      | Lval lv, Const c | Const c, Lval lv ->
-         let d', taint = D.set lv (BinOp (op, Lval dst, Const c)) d in
-         if Asm.with_lval dst (Lval lv) then
-           d', taint
-         else D.forget_lval dst d', taint
-         
-      | Lval lv, e | e, Lval lv ->
-         if (Asm.with_lval dst e1) || (Asm.with_lval dst e2) then
-           D.set lv (BinOp (op, Lval dst, e)) d
-         else D.forget_lval dst d, Taint.Set.singleton Taint.TOP
-        
-      | _ ->  D.forget_lval dst d, Taint.Set.singleton Taint.TOP
-            
-            
-    let back_set (dst: Asm.lval) (src: Asm.exp) (d: D.t): (D.t * Taint.Set.t) =
-      match src with
-      | Lval lv ->
-         let d', taint = D.set lv (Lval dst) d in
-         if Asm.equal_lval lv dst then d', taint
-         else D.forget_lval dst d', taint
-         
-      | UnOp (Not, Lval lv) ->
-         let d', taint = D.set lv (UnOp (Not, Lval dst)) d in
-         if Asm.equal_lval lv dst then d', taint
-         else D.forget_lval dst d, taint
-         
-      | BinOp (Add, e1, e2)  -> back_add_sub Sub dst e1 e2 d
-      | BinOp (Sub, e1, e2) -> back_add_sub Add dst e1 e2 d
-                             
-      | _ -> D.forget_lval dst d, Taint.Set.singleton Taint.TOP
-           
-    (** backward transfert function on the given abstract value *)
-    let process (branch: bool option) (d: D.t) (stmt: Asm.stmt) : (D.t * Taint.Set.t) =
-      (* BE CAREFUL: this function does not apply to nested if statements *)
-      let rec back d stmt =
-        L.debug (fun p -> p "back of %s.........." (Asm.string_of_stmt stmt true));
-        match stmt with
-        | Call _
-        | Return
-        | Jmp _
-        | Nop -> d, Taint.Set.singleton Taint.U
-        | Directive (Forget _) -> d, Taint.Set.singleton Taint.U
-        | Directive (Remove r) -> D.add_register r d None, Taint.Set.singleton Taint.U
-        | Directive (Taint _) -> D.forget d, Taint.Set.singleton Taint.TOP
-        | Directive (Type _) -> D.forget d, Taint.Set.singleton Taint.U
-        | Directive (Unroll _) -> d, Taint.Set.singleton Taint.U
-        | Directive (Unroll_until _) -> d, Taint.Set.singleton Taint.U
-        | Directive Default_unroll -> d, Taint.Set.singleton Taint.U
-        | Directive (Stub _) -> d, Taint.Set.singleton Taint.U
-        | Directive (Skip _) -> d, Taint.Set.singleton Taint.U
-        | Directive (Handler _) -> d, Taint.Set.singleton Taint.U
-        | Set (dst, src) -> back_set dst src d
-        | Assert (_bexp, _msg) -> d, Taint.Set.singleton Taint.U (* TODO *)
-        | If (_e, istmts, estmts) ->
-           match branch with
-           | Some true ->
-              List.fold_left (fun (d, b) s -> let d', b' = back d s in d', Taint.Set.union b b'
-                ) (d, Taint.Set.singleton Taint.U) (List.rev istmts)
-             
-           | Some false ->
-              List.fold_left (fun (d, b) s -> let d', b' = back d s in d', Taint.Set.union b b'
-                ) (d, Taint.Set.singleton Taint.U) (List.rev estmts)
-
-           | None -> D.forget d, Taint.Set.singleton Taint.U
-      in                                                                                                         
-      back d stmt
-
-    let back_update_abstract_value (g:Cfa.t) (v: Cfa.State.t) (ip: Data.Address.t) (pred: Cfa.State.t): Cfa.State.t list =
-      let backward _g v _ip =                                     
-        let start_v =  
-	      match v.Cfa.State.back_v with 
-	      | Some d -> d
-	      | None -> raise (Exceptions.Empty "undefined abstract value used in backward mode")
-	    in 
-	    let d', taint_sources =
-          List.fold_left (fun (d, b) s ->
-              let d', b' = process v.Cfa.State.branch d s in
-              d', Taint.Set.union b b'
-            ) (start_v, Taint.Set.singleton Taint.U) (List.rev pred.Cfa.State.stmts)
-        in
-        let v' = D.meet pred.Cfa.State.v d' in
-        begin
-          match pred.Cfa.State.back_v, pred.Cfa.State.back_taint_sources with
-          | None, None -> 
-             pred.Cfa.State.back_v <- Some v';
-             pred.Cfa.State.back_taint_sources <- Some taint_sources
-             
-          | Some v2, Some t2 -> 
-             pred.Cfa.State.back_v <- Some (D.join v' v2);
-             pred.Cfa.State.back_taint_sources <- Some (Taint.Set.union t2 taint_sources)
-
-          | _, _ -> 
-             raise (Exceptions.Error "inconsistent state in backward mode")
-        end;
-        [pred]
-      in
-      let get_field v =
-        match v.Cfa.State.back_v with
-        | Some d -> d
-        | None -> raise (Exceptions.Error "Illegal call to get_field in interpreter")
-      in
-      Core.update_abstract_value g v get_field ip backward
-
-
-    let back_unroll g v pred =
-      if v.Cfa.State.final then
-        begin
-          v.Cfa.State.final <- false;
-          let new_pred = Cfa.copy_state g v in
-          new_pred.Cfa.State.back_loop <- true;
-          Cfa.remove_successor g pred v;
-          Cfa.add_state g new_pred;
-          Cfa.add_successor g pred new_pred;
-          Cfa.add_successor g new_pred v;
-          new_pred
-        end
-      else
-        pred
-      
-      
-    let from_cfa (g: Cfa.t) (s: Cfa.State.t) (dump: Cfa.t -> unit): Cfa.t =
-      Core.cfa_iteration (fun g v ip vert -> back_update_abstract_value g v ip (List.hd vert))
-        (fun g v -> [Cfa.pred g v]) back_unroll g s dump
-      
-
-
-  end
diff --git a/ocaml/src/fixpoint/forward.ml b/ocaml/src/fixpoint/forward.ml
deleted file mode 100644
index 117fba56..00000000
--- a/ocaml/src/fixpoint/forward.ml
+++ /dev/null
@@ -1,788 +0,0 @@
-(*
-    This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
-
-    BinCAT is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Affero General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or (at your
-    option) any later version.
-
-    BinCAT is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Affero General Public License for more details.
-
-    You should have received a copy of the GNU Affero General Public License
-    along with BinCAT.  If not, see <http://www.gnu.org/licenses/>.
-*)
-
-module L = Log.Make(struct let name = "forward" end)
-open Asm
-
-
- 
- 
-module Make(D: Domain.T)(Cfa: Cfa.T with type domain = D.t)(Stubs: Stubs.T with type domain_t = D.t)(Decoder: Decoder.T)
-         (Core:
-            sig
-              type ctx_t
-              val unroll_nb: int option ref
-              val fun_unroll_tbl: (Data.Address.t, int) Hashtbl.t
-              val unroll_tbl: ((Data.Address.t, int * D.t) Hashtbl.t) ref
-              val cfa_iteration: (Cfa.t -> Cfa.State.t -> Data.Address.t -> Cfa.State.t list -> Cfa.State.t list) ->
-                                 (Cfa.t -> Cfa.State.t -> Cfa.State.t list) ->
-                                 (Cfa.t -> Cfa.State.t -> Cfa.State.t -> Cfa.State.t) ->
-                                 Cfa.t -> Cfa.State.t -> (Cfa.t -> unit) -> Cfa.t
-              val update_abstract_value: Cfa.t -> Cfa.State.t -> (Cfa.State.t -> D.t) ->
-                                         Data.Address.t -> (Cfa.t -> Cfa.State.t -> Data.Address.t -> Cfa.State.t list) ->
-                                         Cfa.State.t list
-              val init: unit -> ctx_t
-              val parse: string -> Cfa.t -> ctx_t -> Cfa.State.t -> Data.Address.t -> Cfa.oracle -> (Cfa.State.t * Data.Address.t * ctx_t) option
-              val filter_vertices: bool -> Cfa.t -> Cfa.State.t list -> Cfa.State.t list
-            end) =
-  struct
-    type fun_stack_t = ((string * string) option * Data.Address.t * Cfa.State.t * (Data.Address.t, int * D.t) Hashtbl.t * Asm.stmt list) list ref
-
-    exception Jmp_exn
-    exception Handler of int * Data.Address.t
-                      
-    (** returns true whenever the given list of statements has a jump stmt (Jmp, Call, Return) *)
-    let rec has_jmp stmts =
-      match stmts with
-      | [] -> false
-      | s::stmts' ->
-         match s with
-         | Call _ | Return  | Jmp _ -> true
-         | If (_, tstmts, estmts) -> (has_jmp tstmts) || (has_jmp estmts)
-         | _ -> (has_jmp stmts');;
-              
-
-    (** opposite the given comparison operator *)
-    let inv_cmp (cmp: Asm.cmp): Asm.cmp =
-      match cmp with
-      | EQ  -> NEQ
-      | NEQ -> EQ
-      | LT  -> GEQ
-      | GEQ -> LT
-      | LEQ -> GT
-      | GT  -> LEQ
-      | GES -> LTS
-      | LTS -> GES;;
-             
-    let restrict (d: D.t) (e: Asm.bexp) (b: bool): (D.t * Taint.Set.t) =
-      L.debug (fun p -> p "restrict: e=%s b=%B" (Asm.string_of_bexp e true) b);
-      let rec process e b =
-        match e with
-        | BConst b' ->
-           if b = b' then d, Taint.Set.singleton Taint.U
-           else D.bot, Taint.Set.singleton Taint.BOT
-          
-        | BUnOp (LogNot, e) -> process e (not b)
-                             
-        | BBinOp (LogOr, e1, e2) ->
-           let v1, taint1 = process e1 b in
-           let v2, taint2 = process e2 b in
-           let taint_sources =
-             if b then Taint.Set.union taint1 taint2
-             else Taint.Set.inter taint1 taint2
-           in
-           if b then D.join v1 v2, taint_sources
-           else D.meet v1 v2, taint_sources
-             
-        | BBinOp (LogAnd, e1, e2) ->
-           let v1, taint1 = process e1 b in
-           let v2, taint2 = process e2 b in
-           let taint_sources =
-             if b then Taint.Set.inter taint1 taint2
-             else Taint.Set.union taint1 taint2
-           in
-           if b then D.meet v1 v2, taint_sources
-           else D.join v1 v2, taint_sources
-           
-        | Asm.Cmp (cmp, e1, e2) ->
-           let cmp' = if b then cmp else inv_cmp cmp in
-           D.compare d e1 cmp' e2
-      in
-      process e b;;
-      
-    let unroll_wrapper (f: unit -> int): unit =
-      try
-        match !Core.unroll_nb with
-        | Some _ -> ()
-        | None ->
-           let n = max (f ()) !Config.unroll in
-           Core.unroll_nb := Some n;
-           L.analysis (fun p -> p "automatic loop unrolling detection. Computed value is 0x%x" n)
-      with _ -> ();;
-              
-    let rec process_value (ip: Data.Address.t) (d: D.t) (s: Asm.stmt) (fun_stack: fun_stack_t) (node_id: int): D.t * Taint.Set.t =
-      L.debug2 (fun p -> p "process_value VVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\n%s\n---------\n%s\n---------"
-                           (String.concat " " (D.to_string d node_id)) (Asm.string_of_stmt s true));
-      try
-        let res, tainted =
-          match s with
-          | Nop -> d, Taint.Set.singleton Taint.U
-          | If (e, then_stmts, else_stmts) -> process_if ip d e then_stmts else_stmts fun_stack node_id
-          | Set (dst, src) -> D.set dst src d
-          | Directive (Remove r) ->
-             let d' = D.remove_register r d in
-             Register.remove r;
-             d', Taint.Set.singleton Taint.U
-             
-          | Directive (Forget lval) -> D.forget_lval lval d, Taint.Set.singleton Taint.U
-          | Directive (Unroll (e, bs)) ->
-             begin
-               try
-                 let f () = min ((Z.to_int (D.value_of_exp d e)) + 1) bs in
-                 unroll_wrapper f
-               with _ -> ()
-             end;
-             d, Taint.Set.singleton Taint.U
-             
-          | Directive (Default_unroll) ->
-             L.analysis (fun p -> p "set unroll parameter to its default value");
-             Core.unroll_nb := None;
-             d, Taint.Set.singleton Taint.U
-             
-          | Asm.Directive (Asm.Unroll_until (addr, cmp, terminator, upper_bound, sz)) ->
-             begin
-               try
-                 let f () =
-                   D.get_offset_from addr cmp terminator upper_bound sz d
-                 in
-                 unroll_wrapper f;
-               with _ -> ()
-             end;
-             d, Taint.Set.singleton Taint.U
-             
-          | Directive (Taint (e, lv)) ->
-             begin
-               match lv with
-               | V (T r) ->
-                  begin
-                    match e with
-                    | None ->
-                       let taint_src = Taint.new_src () in
-                       Hashtbl.add Dump.taint_src_tbl taint_src (Dump.R r);
-                       let mask = Config.Taint_all taint_src in
-                       D.taint_register_mask r mask d
-                    | Some c ->
-                       let taints = D.taint_sources c d in
-                       let taint' = Taint.Set.fold Taint.logor taints Taint.U in
-                       (* TODO: could be more precise here  but  taint_sources should be inlined in span_taint_to_register *)
-                       D.span_taint_to_register r taint' d
-                  end
-                 
-               | M (_, 8) ->
-                  begin
-                    try
-                      match Data.Address.Set.elements (fst (D.mem_to_addresses d (Lval lv))) with
-                      | [a] ->
-                         begin
-                           match e with
-                           | None ->
-                              let taint_src = Taint.new_src () in
-                              Hashtbl.add Dump.taint_src_tbl taint_src (Dump.M (a, 8));
-                              D.taint_address_mask a [Config.Taint (Z.of_int 0xff, taint_src)] d
-                           | Some c ->
-                              let taints = D.taint_sources c d  in
-                              let taint' = Taint.Set.fold Taint.logor taints Taint.U in
-                              (* TODO/ same remark on precision *)
-                              D.span_taint_to_addr a taint' d
-                         end
-                      | _ -> raise Exit
-                    with _ -> L.analysis (fun p -> p "Tainting directive ignored"); d, Taint.Set.singleton Taint.U
-                  end
-               | _ -> L.analysis (fun p -> p "Tainting directive for %s ignored" (Asm.string_of_lval lv false)); d, Taint.Set.singleton Taint.U
-             end
-          | Directive (Type (lv, t)) -> D.set_type lv t d, Taint.Set.singleton Taint.U
-                                      
-          | Directive (Skip (f, call_conv)) as skip_statement ->
-             L.analysis (fun p -> p "Skipping %s" (Asm.string_of_fun f));
-             (* TODO: optimize to avoid type switching *)
-             let f' =
-               match f with
-               | Asm.Fun_name s -> Config.Fun_name s
-               | Asm.Fun_addr a -> Config.Fun_addr (Data.Address.to_int a)
-             in                                   
-             let d',  taint, cleanup_stmts = Stubs.skip d f' call_conv in
-             let d', taint' =
-               Log.Trace.trace (Data.Address.global_of_int (Z.of_int 0))  (fun p -> p "%s" (string_of_stmts (skip_statement :: cleanup_stmts) true));
-               List.fold_left (fun (d, t) stmt ->
-                   let dd, tt = process_value ip d stmt fun_stack node_id in
-                   dd, Taint.Set.union t tt) (d', taint) cleanup_stmts
-             in
-             d', taint'
-             
-          | Directive (Stub (fun_name, call_conv)) as stub_statement ->
-             let prev_ip =
-               try
-                 let _, _, v, _, _ = List.hd !fun_stack in
-                 Some v.Cfa.State.ip
-               with Failure _ -> None
-             in
-             let d', taint', cleanup_stmts = Stubs.process ip prev_ip d fun_name call_conv in
-             let d', taint' =
-               Log.Trace.trace (Data.Address.global_of_int (Z.of_int 0))  (fun p -> p "%s" (string_of_stmts (stub_statement :: cleanup_stmts) true));
-               List.fold_left (fun (d, t) stmt ->
-                   let dd, tt = process_value ip d stmt fun_stack node_id in
-                   dd, Taint.Set.union t tt) (d', taint') cleanup_stmts
-             in
-             d', taint'
-             
-          | Directive (Handler (sig_nb, addr)) -> raise (Handler (sig_nb, addr))               
-               
-          | _ -> raise Jmp_exn
-               
-        in
-        res, tainted
-      with Exceptions.Empty _ -> D.bot, Taint.Set.singleton Taint.BOT
-                               
-    and process_if (ip: Data.Address.t) (d: D.t) (e: Asm.bexp) (then_stmts: Asm.stmt list) (else_stmts: Asm.stmt list) fun_stack (node_id: int) =
-      if has_jmp then_stmts || has_jmp else_stmts then
-        raise Jmp_exn
-      else
-        let dt, bt = List.fold_left (fun (d, b) s -> let d', b' = process_value ip d s fun_stack node_id in d', Taint.Set.union b b') (restrict d e true) then_stmts in
-        let de, be = List.fold_left (fun (d, b) s -> let d', b' = process_value ip d s fun_stack node_id in d', Taint.Set.union b b') (restrict d e false) else_stmts in
-        D.join dt de, Taint.Set.union bt be;;
-        
-    let forward_process (ip: Data.Address.t) (d: D.t) (stmt: Asm.stmt) (branch: bool option) (node_id: int): (D.t * Taint.Set.t) =
-      (* function stack *)
-      let fun_stack = ref [] in
-      let rec forward (d: D.t) (stmt: Asm.stmt): (D.t * Taint.Set.t) =
-        match stmt with
-        | Asm.Nop
-        | Asm.Directive (Asm.Forget _)
-        | Asm.Directive (Asm.Remove _)
-        | Asm.Directive (Asm.Taint _)
-        | Asm.Directive (Asm.Type _)
-        | Asm.Directive (Asm.Unroll _)
-        | Asm.Directive (Asm.Stub _)
-        | Asm.Directive (Asm.Skip _)
-        | Asm.Directive (Asm.Handler _)
-        | Asm.Directive (Asm.Unroll_until _)
-        | Asm.Directive Asm.Default_unroll
-        | Asm.Jmp (Asm.A _)
-        | Asm.Return
-        | Asm.Call (Asm.A _) -> d, Taint.Set.singleton Taint.U
-        | Asm.Set (dst, src) -> D.set dst src d
-        | Assert (_bexp, _msg) -> d, Taint.Set.singleton Taint.U (* TODO *)
-        | Asm.If (e, istmts, estmts) ->
-           begin
-             try process_if ip d e istmts estmts fun_stack node_id
-             with Jmp_exn ->
-               match branch with
-               | Some true -> List.fold_left (fun (d, b) stmt -> let d', b' = forward d stmt in d', Taint.Set.union b b') (restrict d e true) istmts
-               | Some false -> List.fold_left (fun (d, b) stmt -> let d', b' = forward d stmt in d', Taint.Set.union b b') (restrict d e false) estmts
-               | None -> L.abort (fun p -> p "Illegal call to Interpreter.forward_process")
-           end
-        | Asm.Call (Asm.R _) -> D.forget d, Taint.Set.singleton Taint.TOP
-        | Asm.Jmp (Asm.R _) -> D.forget d, Taint.Set.singleton Taint.TOP (* TODO may be more precise but check whether the target is really in the CFA. If not then go back to forward_bin for that branch *)
-      in
-      forward d stmt;;
-      
-   let forward_abstract_value (g:Cfa.t) (succ: Cfa.State.t) (ip: Data.Address.t) (v: Cfa.State.t): Cfa.State.t list =
-      let forward _g v _ip =
-        let d', taint_sources = List.fold_left (fun (d, b) s ->
-          let d', b' = forward_process v.Cfa.State.ip d s (succ.Cfa.State.branch) v.Cfa.State.id in
-          d', Taint.Set.union b b') (v.Cfa.State.v, Taint.Set.singleton Taint.U) (succ.Cfa.State.stmts)
-        in
-        succ.Cfa.State.v <- D.meet succ.Cfa.State.v d';
-        succ.Cfa.State.taint_sources <- taint_sources;
-        [succ]
-      in
-      Core.update_abstract_value g v (fun v -> v.Cfa.State.v) ip forward;;
-
-  let unroll g v succ =
-      if v.Cfa.State.final then
-        begin
-          v.Cfa.State.final <- false;
-          let new_succ = Cfa.copy_state g v in
-          new_succ.Cfa.State.forward_loop <- true;
-          Cfa.remove_successor g v succ;
-          Cfa.add_state g new_succ;
-          Cfa.add_successor g v new_succ;
-          Cfa.add_successor g new_succ succ;
-          new_succ
-        end
-      else
-        succ;;
-
-     let apply_after_call_stmts v stmts fun_stack =
-      let d', t' =
-        List.fold_left (fun (d, t) s ->
-            let d', t' = process_value v.Cfa.State.ip d s fun_stack v.Cfa.State.id in
-            d', Taint.Set.union t t') (v.Cfa.State.v,Taint.Set.singleton Taint.U) stmts
-      in
-      v.Cfa.State.v <- d';
-      v, t';;
-
-     
-    (** returns the result of the transfert function corresponding to the statement on the given abstract value *)
-    let skip_or_import_call vertices a fun_stack =     
-      (* will raise Not_found if no import or skip is found *)
-      L.debug2 (fun p -> p "skip_or_import_tbl at %s" (Data.Address.to_string a));
-      let fundec =
-        try
-          let import_desc = Hashtbl.find Decoder.Imports.tbl a in
-            Decoder.Imports.skip (Some import_desc) a
-        with
-        | Not_found -> Decoder.Imports.skip None a
-      in
-      let stmts = fundec.Asm.prologue @ fundec.Asm.stub @ fundec.Asm.epilogue in
-      let ret_addr_exp = fundec.Asm.ret_addr in
-      let t =
-        List.fold_left (fun t v ->             
-            let d', t' =
-              List.fold_left (fun (d, t) stmt ->
-                  try
-                    let d', t' = process_value a d stmt fun_stack v.Cfa.State.id in
-                    d', Taint.Set.union t t'
-                  with  Handler (sig_nb, handler_addr) -> (* TODO factorize this code with same pattern in process_vertices *)
-                    Hashtbl.replace (fst v.Cfa.State.handlers) sig_nb handler_addr;
-                    d, t
-                ) (v.Cfa.State.v, Taint.Set.singleton Taint.U) stmts
-              
-            in
-            v.Cfa.State.v <- d';
-            let addrs, _ = D.mem_to_addresses d' ret_addr_exp in
-            let a =
-              match Data.Address.Set.elements addrs with
-              | [a] -> a
-              | []  -> raise (Exceptions.Empty "no return address can be computed")
-              | _l  -> raise (Exceptions.Too_many_concrete_elements "multiple return addresses")
-            in
-            L.info2 (fun p -> p "returning from stub to %s" (Data.Address.to_string a));
-            v.Cfa.State.ip <- a;
-            Log.Trace.trace a (fun p -> p "%s"
-                                          (Asm.string_of_stmts [ Asm.Jmp(R ret_addr_exp) ] true));
-            Taint.Set.union t t') (Taint.Set.singleton Taint.U) vertices
-      in
-      vertices, t;;
-
-    let fold_to_target (apply: Data.Address.t -> Cfa.State.t -> fun_stack_t -> Data.Address.t -> unit) (vertices: Cfa.State.t list) (target: Asm.exp) (fun_stack: fun_stack_t) (ip: Data.Address.t): (Cfa.State.t list * Taint.Set.t) =
-        let import = ref false in
-        let vertices', t =
-          List.fold_left (fun (l, t) v ->
-              try
-                let addrs, taint_sources = D.mem_to_addresses v.Cfa.State.v target in
-                let addresses = Data.Address.Set.elements addrs in
-                match addresses with
-                | [a] ->
-                   begin
-                     L.debug (fun p->p "fold_to_target addr : %s" (Data.Address.to_string a));
-                     try
-                       let res = skip_or_import_call [v] a fun_stack in
-                       import := true;
-                       res
-                     with Not_found ->
-                       v.Cfa.State.ip <- a;
-                       apply a v fun_stack ip;
-                       v::l, Taint.Set.union t taint_sources
-                   end
-                  
-                | [] -> L.abort (fun p -> p "Unreachable jump target from ip = %s\n" (Data.Address.to_string v.Cfa.State.ip))
-                | l -> L.abort (fun p -> p "Please select between the addresses %s for jump target from %s\n"
-                                           (List.fold_left (fun s a -> s^(Data.Address.to_string a)) "" l) (Data.Address.to_string v.Cfa.State.ip))
-              with
-              | Exceptions.Too_many_concrete_elements _ as e ->
-                 L.exc_and_abort e (fun p -> p "Uncomputable set of address targets for jump at ip = %s\n" (Data.Address.to_string v.Cfa.State.ip))
-            ) ([], Taint.Set.singleton Taint.U) vertices
-        in
-        if !import then
-          begin
-            (* TODO: factorize with process_vertices, case Jmp_exn, subcase Jmp (A a) *)
-            let _, _, _, _, (stmts: Asm.stmt list) = List.hd !fun_stack in
-            let vertices', t' =
-              List.fold_left (fun (l, t) v ->
-                  let v', t' = apply_after_call_stmts v stmts fun_stack in
-                  v'::l, Taint.Set.union t t') ([], Taint.Set.singleton Taint.U) vertices'
-            in
-            begin
-              try
-                fun_stack := List.tl !fun_stack
-              with Failure _ -> ()
-            end;
-            vertices', Taint.Set.union t t'
-          end
-        else vertices, t;;
-
-    let add_to_fun_stack a v fun_stack ip =
-        begin
-          try
-            let n' = (Hashtbl.find Core.fun_unroll_tbl a) + 1 in
-            if n' <= !Config.fun_unroll then
-              Hashtbl.replace Core.fun_unroll_tbl a n'
-            else
-              L.abort (fun p -> p "function at %s has been analysed more than %d times. Analysis stops" (Data.Address.to_string a) !Config.fun_unroll)
-          with Not_found -> Hashtbl.add Core.fun_unroll_tbl a 1
-        end;
-        let f =
-          try
-            Some (Hashtbl.find Config.import_tbl (Data.Address.to_int a))
-          with Not_found -> None
-        in
-        fun_stack := (f, ip, v, !Core.unroll_tbl, [])::!fun_stack;
-        Core.unroll_tbl := Hashtbl.create 1000;;
-
-    let add_stmts_to_fun_stack stmts fun_stack =
-        try
-          let f, ip, v, unroll_tbl, prev_stmts = List.hd !fun_stack in
-          fun_stack := (f, ip, v, unroll_tbl, prev_stmts @ stmts)::(List.tl !fun_stack)
-        with _ -> raise (Exceptions.Error "unexpected empty function stack");;
-
-    let copy g v d branch is_pred =
-        (* TODO: optimize with Cfa.State.copy that copies every field and then here some are updated => copy them directly *)
-        let v' = Cfa.copy_state g v in
-        v'.Cfa.State.stmts <- [];
-        v'.Cfa.State.v <- d;
-        v'.Cfa.State.branch <- branch;
-        v'.Cfa.State.bytes <- [];
-        v'.Cfa.State.taint_sources <- Taint.Set.singleton Taint.U;
-        if is_pred then
-          Cfa.add_successor g v v'
-        else
-          Cfa.add_successor g (Cfa.pred g v) v';
-        v';;
-
-    let iprocess_ret ipstack v fun_stack ip =
-        let d = v.Cfa.State.v in
-        let sp = Register.stack_pointer () in
-        let ip_on_stack, taint_sources =
-          D.mem_to_addresses d (Asm.Lval (Asm.M (Asm.Lval (Asm.V (Asm.T sp)), (Register.size sp)))) in
-        match Data.Address.Set.elements (ip_on_stack) with
-        | [a] ->
-           let after_stmts = 
-             match ipstack with
-             | Some (ip', after_stmts) ->
-                if not (Data.Address.equal ip' a) then
-                  L.analysis (fun p -> p "computed instruction pointer %s differs from instruction pointer found on the stack %s at RET instruction"
-                                         (Data.Address.to_string ip') (Data.Address.to_string a));
-                after_stmts
-             | None -> []
-           in        
-           begin
-             try
-               let vert, t = skip_or_import_call [v] a fun_stack in
-               add_to_fun_stack a v fun_stack ip;
-               if after_stmts <> [] then
-                 let vert', t' = List.fold_left (fun (l, t) v' ->
-                                     let v', t' = apply_after_call_stmts v' after_stmts fun_stack in
-                                     v'::l, Taint.Set.union t t') ([], t) vert
-                 in
-                 Some vert', t'
-               else Some vert, t
-             with Not_found ->
-               v.Cfa.State.ip <- a;
-               Some [v], taint_sources
-           end
-        | [] -> raise (Exceptions.Empty "no valid instruction pointer at return can be retrieved")
-        | _ -> raise (Exceptions.Too_many_concrete_elements  "computed instruction pointer at return is imprecise");;
-
-    let process_ret (fun_stack: fun_stack_t) v ip: (Cfa.State.t list option * Taint.Set.t) =
-      try
-        let _f, ipstack, _v, prev_unroll_tbl, after_ret_stmts = List.hd !fun_stack in
-        fun_stack := List.tl !fun_stack;
-        Core.unroll_tbl := prev_unroll_tbl;
-        iprocess_ret (Some (ipstack, after_ret_stmts)) v fun_stack ip
-      with Failure _ ->
-        L.analysis (fun p -> p "RET without previous CALL at address %s" (Data.Address.to_string v.Cfa.State.ip));
-        iprocess_ret None v fun_stack ip;;
-          
-    let process_stmts fun_stack g (v: Cfa.State.t) (ip: Data.Address.t): Cfa.State.t list =
-      let rec process_branch vertices stmts branch (e: Asm.bexp) =
-        let vertices', b =
-          List.fold_left (fun (l, b) v ->
-               try
-                 let d, taint_sources = restrict v.Cfa.State.v e branch in
-                 if D.is_bot d then
-                   l, b
-                 else
-                   (copy g v d (Some true) false)::l, Taint.Set.union b taint_sources
-               with Exceptions.Empty "Interpreter.process_if_with_jmp" -> l, b) ([], Taint.Set.singleton Taint.U) vertices
-        in
-        let vert, b', _after_call_stmts = process_list vertices' stmts in
-        vert, Taint.Set.union b b'
-        
-      and process_if_with_jmp (vertices: Cfa.State.t list) (e: Asm.bexp) (istmts: Asm.stmt list) (estmts: Asm.stmt list) =  
-        let then', bt = process_branch vertices istmts true e in
-        let else', be = process_branch vertices estmts false e in
-        List.iter (fun v -> Cfa.remove_state g v) vertices;
-        then' @ else', Taint.Set.union be bt
-          
-        and process_vertices (vertices: Cfa.State.t list) (s: Asm.stmt) : (Cfa.State.t list * Taint.Set.t) * bool =
-          try
-            List.fold_left (fun (l, b) v ->
-                let d, b' =
-                  try process_value v.Cfa.State.ip v.Cfa.State.v s fun_stack v.Cfa.State.id
-                  with
-                    Handler (sig_nb, handler_addr') ->
-                    Hashtbl.replace (fst v.Cfa.State.handlers) sig_nb handler_addr';
-                    v.Cfa.State.v, b
-                in
-                v.Cfa.State.v <- d;
-                let taint = Taint.Set.union b b' in
-                (*v.Cfa.State.taint_sources <- taint;*)
-                v::l, taint) ([], Taint.Set.singleton Taint.U) vertices, false
-          with
-          | Jmp_exn ->
-             match s with
-             | If (e, then_stmts, else_stmts) -> process_if_with_jmp vertices e then_stmts else_stmts, false 
-                                               
-             | Jmp (A a) ->
-                begin
-                  try
-                    let _, _, _, _, stmts = List.hd !fun_stack in
-                    let vertices, t = skip_or_import_call vertices a fun_stack in
-                    let vertices', t' =
-                      List.fold_left (fun (l, t) v ->
-                          let v', t' = apply_after_call_stmts v stmts fun_stack in
-                          v'::l, Taint.Set.union t t') ([], Taint.Set.singleton Taint.U) vertices
-                    in
-                    fun_stack := List.tl !fun_stack;
-                    (vertices', Taint.Set.union t t'), false
-                  with _ ->
-                    (List.map (fun v -> v.Cfa.State.ip <- a; v) vertices, Taint.Set.singleton Taint.U), false
-                end
-
-             | Jmp (R target) ->
-                let res =
-                    match target with
-                    | Lval (M (Const c, _)) ->
-                       begin
-                         let a = Data.Address.of_word c in
-                         try
-                           let res = skip_or_import_call vertices a fun_stack in
-                           fun_stack := List.tl !fun_stack;
-                           res
-                         with Not_found ->
-                           List.map (fun v -> v.Cfa.State.ip <- a; v) vertices, Taint.Set.singleton Taint.U
-                       end
-                      
-                    | target -> fold_to_target (fun _a _v _fstack _ip -> ()) vertices target fun_stack ip
-                in
-                res, false
-               
-             | Call (A a) ->
-                add_to_fun_stack a v fun_stack ip;
-                begin
-                  try
-                    skip_or_import_call vertices a fun_stack, true
-                  with Not_found ->
-                    List.iter (fun v -> v.Cfa.State.ip <- a) vertices;
-                    (vertices, Taint.Set.singleton Taint.U), true
-                end
-                
-             | Call (R target) -> fold_to_target add_to_fun_stack vertices target fun_stack ip, false
-                                
-             | Return ->
-                List.fold_left (fun (l, b) v ->
-                    let v', b' = process_ret fun_stack v ip in
-                    match v' with
-                    | None -> l, Taint.Set.union b b'
-                    | Some v -> v@l, Taint.Set.union b b') ([], Taint.Set.singleton Taint.U) vertices, false
-               
-             | _       -> (vertices, Taint.Set.singleton Taint.U), false
-                        
-        and process_list (vertices: Cfa.State.t list) (stmts: Asm.stmt list): Cfa.State.t list * Taint.Set.t * Asm.stmt list =
-          match stmts with
-          | s::stmts ->
-             begin
-               try
-                 let ((new_vertices: Cfa.State.t list), (t: Taint.Set.t)), (has_call_inside: bool) = process_vertices vertices s in
-                 if has_call_inside then new_vertices, t, stmts
-                 else
-                   let vert, t', stmts' = process_list new_vertices stmts in
-                   vert, Taint.Set.union t t', stmts'
-               with Exceptions.Bot_deref -> [], Taint.Set.singleton Taint.BOT, [] (* in case of undefined dereference corresponding vertices are no more explored. They are not added to the waiting list neither *)
-             end
-          | [] -> vertices, Taint.Set.singleton Taint.U, []
-        in
-        let vstart = copy g v v.Cfa.State.v None true in
-        vstart.Cfa.State.ip <- ip;
-        (* check if the instruction has to be skiped *)
-        let ia = Data.Address.to_int v.Cfa.State.ip in
-        if not (Config.SAddresses.mem ia !Config.nopAddresses) then
-          let vertices, taint, after_call_stmts = process_list [vstart] v.Cfa.State.stmts in
-          begin
-            try
-              v.Cfa.State.taint_sources <- taint;
-              if after_call_stmts <> [] then
-                add_stmts_to_fun_stack after_call_stmts fun_stack;
-              List.iter (fun (_f, _ip, v, _tbl, _after_call_stmts) ->
-                  v.Cfa.State.taint_sources <- Taint.Set.union v.Cfa.State.taint_sources taint
-                ) !fun_stack;
-            with _  -> ()
-          end;
-          vertices
-        else
-          begin
-            Log.Trace.trace v.Cfa.State.ip (fun p -> p "nop ; forced by config");
-            L.analysis (fun p -> p "Instruction at address %s nopped by config"
-                                  (Data.Address.to_string v.Cfa.State.ip));
-          [vstart]
-        end;;
-
-       
-    
-(** fixpoint iterator to build the CFA corresponding to the provided code starting from the initial state s.
-     g is the initial CFA reduced to the singleton s *)
-let from_bin (mapped_mem: Mapped_mem.t) (g: Cfa.t) (s: Cfa.State.t) (dump: Cfa.t -> unit): Cfa.t =
-  let module Vertices = Set.Make(Cfa.State) in
-  (* check whether the instruction pointer is in the black list of addresses to decode *)
-  if Config.SAddresses.mem (Data.Address.to_int s.Cfa.State.ip) !Config.blackAddresses then
-    L.abort (fun p -> p "Interpreter not started as the entry point belongs to the cut off branches\n");
-  (* boolean variable used as condition for exploration of the CFA *)
-  let continue = ref true in
-  (* set of waiting nodes in the CFA waiting to be processed *)
-  let waiting  = ref (Vertices.singleton s) in
-  (* set d to the initial internal state of the decoder *)
-  let d = ref (Core.init ()) in
-  (* function stack *)
-  let fun_stack = ref [] in
-  let hash_add_or_append htbl key rules =
-    try
-      let existing = Hashtbl.find htbl key in
-      Hashtbl.replace htbl key (rules @ existing)
-    with Not_found -> Hashtbl.add htbl key rules
-  in
-  (* compute override rules to apply *)
-  let overrides = Hashtbl.create 5 in
-  Hashtbl.iter (fun z rules ->
-      let ip = Data.Address.of_int Data.Address.Global z !Config.address_sz in
-      let rules' =
-        List.map (fun (rname, rfun) ->
-            let reg = Register.of_name rname in
-            let rule = rfun reg in
-            Init_check.check_register_init reg rule;
-            D.set_register_from_config reg rule) rules
-      in
-      hash_add_or_append overrides ip rules'
-    ) Config.reg_override;
-  
-  
-  List.iter (fun (tbl, region) ->
-      Hashtbl.iter (fun z rules ->
-          let ip = Data.Address.of_int Data.Address.Global z !Config.address_sz in
-          let rules' =
-            List.map (fun ((addr, nb), rule) ->
-                L.analysis (fun p -> p "Adding override rule for address 0x%x" (Z.to_int addr));
-                Init_check.check_mem rule None;
-                let addr' = Data.Address.of_int region addr !Config.address_sz in
-                match rule with
-                | (Some _, _) -> D.set_memory_from_config addr' rule nb
-                | (None, t) -> D.taint_address_mask addr' t
-              ) rules
-          in
-          hash_add_or_append overrides ip rules'
-          
-        ) tbl)
-    [Config.mem_override, Data.Address.Global ];
-  
-  Hashtbl.iter (fun z rules ->
-      let ip = Data.Address.of_int Data.Address.Global z !Config.address_sz in
-      try
-        let rules' =
-          List.map (fun (((id, offset), nb), rule) ->
-              let id' = Z.to_int id in
-              L.analysis (fun p -> p "Adding override rule for heap id %d" id');
-              let heap_sz = Data.Address.size_of_heap_region id' in
-              Init_check.check_mem rule (Some heap_sz);
-              let addr' = Data.Address.of_int (Data.Address.Heap(id', heap_sz)) offset !Config.address_sz in
-              match rule with
-              | (Some _, _) -> D.set_memory_from_config addr' rule nb
-              | (None, t) -> D.taint_address_mask addr' t
-            ) rules
-        in
-        hash_add_or_append overrides ip rules'
-      with _ -> raise (Exceptions.Error "id of heap is too large")
-    ) Config.heap_override;
-  
-  while !continue do
-    (* a waiting node is randomly chosen to be explored *)
-    let v = Vertices.choose !waiting in
-    waiting := Vertices.remove v !waiting;
-    begin
-      try
-        L.info2 (fun p -> p "################### %s" (Data.Address.to_string v.Cfa.State.ip));
-        Log.current_address := Some v.Cfa.State.ip;
-        (* the subsequence of instruction bytes starting at the offset provided the field ip of v is extracted *)
-        let text'        = Mapped_mem.string_from_addr mapped_mem v.Cfa.State.ip !Config.max_instruction_size in
-        (* the corresponding instruction is decoded and the successor state of v are computed and added to    *)
-        (* the CFA                                                                                             *)
-        (* except the abstract value field which is set to v.Cfa.State.value. The right value will be          *)
-        (* computed next step                                                                                  *)
-        (* the new instruction pointer (offset variable) is also returned                                      *)
-        let r =
-          match text' with
-          | Some text'' ->  Core.parse text'' g !d v v.Cfa.State.ip (new Cfa.oracle v.Cfa.State.v v.Cfa.State.handlers)
-          | None -> L.abort (fun p -> p "Could not retrieve %i bytes at %s to decode next instruction"
-                                        !Config.max_instruction_size (Data.Address.to_string v.Cfa.State.ip) )
-        in
-        begin
-          match r with
-          | Some (v', ip', d') ->
-             Log.Trace.trace v.Cfa.State.ip (fun p -> p "%s" (Asm.string_of_stmts v.Cfa.State.stmts true));
-             (* add overrides if needed *)               
-             begin
-               try
-                 let rules = Hashtbl.find overrides v'.Cfa.State.ip in
-                 L.analysis (fun p -> p "applied %d override(s)" (List.length rules));
-                 let d', taint =
-                   List.fold_left (fun (d, taint) rule -> let d', taint' = rule d in d', Taint.Set.union taint taint'
-                     ) (v.Cfa.State.v, v.Cfa.State.taint_sources) rules
-                 in
-                 v.Cfa.State.v <- d';
-                 v.Cfa.State.taint_sources <- taint
-               with
-                 Not_found -> ()
-             end;
-             (* these vertices are updated by their right abstract values and the new ip  *)
-             let new_vertices = Core.update_abstract_value g v' (fun v -> v.Cfa.State.v) ip' (process_stmts fun_stack) in
-             (* among these computed vertices only new are added to the waiting set of vertices to compute *)
-             let vertices'  = Core.filter_vertices true g new_vertices in
-             List.iter (fun v ->
-                 Cfa.update_ips g v;
-                 waiting := Vertices.add v !waiting) vertices';
-             (* udpate the internal state of the decoder *)
-             d := d'
-          | None -> ()
-        end;
-        Log.latest_finished_address := Some v.Cfa.State.ip;  (* v.Cfa.State.ip can change because of calls and jumps *)
-        
-      with
-      | Exceptions.Too_many_concrete_elements msg ->
-         L.analysis (fun p -> p "%s" msg);
-         
-         
-      | Exceptions.Use_after_free msg ->
-         L.analysis (fun p -> p "possible use after free in alloc %s, at: %s" msg (Data.Address.to_string v.Cfa.State.ip));
-         
-         
-      | Exceptions.Undefined_free msg ->
-         L.analysis (fun p -> p "undefined free detected here: %s" msg);
-         
-         
-      | Exceptions.Double_free ->
-         L.analysis (fun p -> p "possible double free detected");
-         
-         
-      | Exceptions.Stop msg ->
-         L.analysis (fun p -> p "analysis stopped for the current context: %s" msg)
-        
-      | e -> L.exc e (fun p -> p "Unexpected exception"); dump g; raise e
-    end;
-    (* boolean condition of loop iteration is updated *)
-    continue := not (Vertices.is_empty !waiting);
-  done;
-  g
-    
-let from_cfa (g: Cfa.t) (s: Cfa.State.t) (dump: Cfa.t -> unit): Cfa.t =
-  let f_iter (g: Cfa.t) (v: Cfa.State.t) (ip: Data.Address.t) (vert: Cfa.State.t list) =
-    List.fold_left (fun l v' -> (forward_abstract_value g v ip v')@l) [] vert
-  in
-    Core.cfa_iteration f_iter Cfa.succs unroll g s dump
-  
-    
-end
-    
diff --git a/ocaml/src/fixpoint/interpreter.ml b/ocaml/src/fixpoint/interpreter.ml
index 84038980..7fb6fdbf 100644
--- a/ocaml/src/fixpoint/interpreter.ml
+++ b/ocaml/src/fixpoint/interpreter.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -20,33 +20,105 @@
 
 module L = Log.Make(struct let name = "interpreter" end)
 
-module Make(D: Domain.T)(Decoder: Decoder.Make)(Stubs: Stubs.T with type domain_t = D.t) =
+module Make(D: Domain.T)(Decoder: Decoder.Make) =
 struct
 
-  module Decoder = Decoder(D)(Stubs)
-  module Cfa = Decoder.Cfa
- 
-
- (* Hash table to know when a widening has to be processed, that is when the associated value reaches the threshold Config.unroll *)
-  let unroll_tbl: ((Data.Address.t, int * D.t) Hashtbl.t) ref = ref (Hashtbl.create 1000)
-                                                              
-  (* Hash table to store number of times a function has been analysed *)
-  let fun_unroll_tbl: (Data.Address.t, int) Hashtbl.t = Hashtbl.create 10
-                                                      
-  (* current unroll value *)
-  (* None is for the default value set in Config *)
-  let unroll_nb = ref None
-
-  (** widen the given state with all previous vertices that have the same ip as v *)
-  let widen prev v =
-    v.Cfa.State.final <- true;
-    v.Cfa.State.v <- D.widen prev v.Cfa.State.v
-    
+    (** stubs *)
+    module Stubs = Stubs.Make(D)
+
+    (** Decoder *)
+    module Decoder = Decoder(D)(Stubs)
+
+    type import_attrib_t = {
+      mutable ia_name: string;
+      mutable ia_addr: Z.t option;
+      mutable ia_typing_rule: bool;
+      mutable ia_tainting_rule: bool;
+      mutable ia_stub: bool;
+    }
+
+
+    (** Control Flow Automaton *)
+    module Cfa = Decoder.Cfa
+
+
+    open Asm
+
+    (* Hash table to know when a widening has to be processed, that is when the associated value reaches the threshold Config.unroll *)
+    let unroll_tbl: ((Data.Address.t, int * D.t) Hashtbl.t) ref = ref (Hashtbl.create 1000)
+
+    (* Hash table to store number of times a function has been analysed *)
+    let fun_unroll_tbl: (Data.Address.t, int) Hashtbl.t = Hashtbl.create 10
+
+    (* current unroll value *)
+    (* None is for the default value set in Config *)
+    let unroll_nb = ref None
+
+    (** opposite the given comparison operator *)
+    let inv_cmp (cmp: Asm.cmp): Asm.cmp =
+      match cmp with
+      | EQ  -> NEQ
+      | NEQ -> EQ
+      | LT  -> GEQ
+      | GEQ -> LT
+      | LEQ -> GT
+      | GT  -> LEQ
+
+    let restrict (d: D.t) (e: Asm.bexp) (b: bool): (D.t * Taint.Set.t) =
+      L.debug (fun p -> p "restrict: e=%s b=%B" (Asm.string_of_bexp e true) b);
+      let rec process e b =
+        match e with
+        | BConst b'           -> if b = b' then d, Taint.Set.singleton Taint.U else D.bot, Taint.Set.singleton Taint.BOT
+        | BUnOp (LogNot, e)  -> process e (not b)
+
+        | BBinOp (LogOr, e1, e2)  ->
+           let v1, taint1 = process e1 b in
+           let v2, taint2 = process e2 b in
+           let taint_sources =
+             if b then Taint.Set.union taint1 taint2
+             else Taint.Set.inter taint1 taint2
+           in
+           if b then D.join v1 v2, taint_sources
+           else D.meet v1 v2, taint_sources
+
+        | BBinOp (LogAnd, e1, e2) ->
+           let v1, taint1 = process e1 b in
+           let v2, taint2 = process e2 b in
+           let taint_sources =
+             if b then Taint.Set.inter taint1 taint2
+             else Taint.Set.union taint1 taint2 in
+           if b then D.meet v1 v2, taint_sources
+           else D.join v1 v2, taint_sources
+
+        | Asm.Cmp (cmp, e1, e2)   ->
+           let cmp' = if b then cmp else inv_cmp cmp in
+           D.compare d e1 cmp' e2
+      in
+      process e b
+
+
+    (** widen the given state with all previous vertices that have the same ip as v *)
+    let widen prev v =
+      let join_v = D.join prev v.Cfa.State.v in
+      v.Cfa.State.final <- true;
+      v.Cfa.State.v <- D.widen prev join_v
+
+
     (** update the abstract value field of the given vertices wrt to their list of statements and the abstract value of their predecessor
-    the widening may be also launched if the threshold is reached *)    
-  let update_abstract_value (g: Cfa.t) (v: Cfa.State.t) (get_field: Cfa.State.t -> D.t) (ip: Data.Address.t) (process_stmts: Cfa.t -> Cfa.State.t -> Data.Address.t -> Cfa.State.t list): Cfa.State.t list =
+    the widening may be also launched if the threshold is reached *)
+    let update_abstract_value (g: Cfa.t) (v: Cfa.State.t) (get_field: Cfa.State.t -> D.t) (ip: Data.Address.t) (process_stmts: Cfa.t -> Cfa.State.t -> Data.Address.t -> Cfa.State.t list): Cfa.State.t list =
       try
+        let old_ip = v.Cfa.State.ip in
         let l = process_stmts g v ip in
+        List.iter (fun v ->
+          let d = get_field v in
+          try
+            let n', jd' = Hashtbl.find !unroll_tbl ip in
+            let d' = D.join jd' d in
+            Hashtbl.replace !unroll_tbl ip (n'+1, d');
+          with Not_found ->
+            Hashtbl.add !unroll_tbl v.Cfa.State.ip (1, d)
+        ) l;
         List.iter (fun v ->
           let d = get_field v in
           let n, jd =
@@ -58,7 +130,7 @@ struct
               Hashtbl.add !unroll_tbl v.Cfa.State.ip (1, d);
               1, d
           in
-          let nb_max = 
+          let nb_max =
             match !unroll_nb with
             | None -> !Config.unroll
             | Some n -> n
@@ -71,30 +143,492 @@ struct
               widen jd v
             end
         ) l;
+
+        L.info(fun p -> p "Addr: %s/%s" (Data.Address.to_string old_ip) (Data.Address.to_string ip));
+        try
+          (* Update the list of new states according to the Config Table *)
+          let _, addr_list = Hashtbl.find Config.cfgTbl (Data.Address.to_int old_ip) in
+          match l with
+            | [v] -> (
+              let new_states = (List.fold_left(fun (l':Cfa.State.t list) addr ->
+                let v' = Cfa.copy_state g v in
+                L.info(fun p -> p "State id is %d with ip %s" v'.Cfa.State.id (Data.Address.to_string v'.Cfa.State.ip));
+                v'.Cfa.State.ip <- Data.Address.global_of_int addr;
+                (* let reg = Register.of_name reg_name in
+                 *)
+                (* v'.Cfa.State. ; *) (* UPDATE ALSO REGISTER *)
+                Cfa.add_successor g v v';
+                L.info(fun p -> p "Add state with ip: %x" (Z.to_int addr));
+                v'::l'
+              ) [] addr_list) in
+              Cfa.remove_state g v;
+              new_states
+            )
+            | _ -> l;
+        with Not_found ->
+          ();
+
         List.fold_left (fun l' v ->
-          if D.is_bot (get_field v) then
+          if D.is_bot (get_field v) || (Cfa.has_ip g v) then
             begin
-              L.analysis (fun p -> p "unreachable state at address %s" (Data.Address.to_string ip));
+              if Cfa.has_ip g v then (
+                L.info(fun p -> p "Unreachable state because already explored")
+              ) else (
+                L.info(fun p -> p "Unreachable state because is bot")
+              );
               Cfa.remove_state g v; l'
             end
-          else v::l') [] l (* TODO: optimize by avoiding creating a state then removing it if its abstract value is bot *)
+          else (
+            v::l'
+          )
+          ) [] l (* TODO: optimize by avoiding creating a state then removing it if its abstract value is bot *)
       with Exceptions.Empty _ -> L.analysis (fun p -> p "No new reachable states from %s\n" (Data.Address.to_string ip)); []
 
-  let is_subset prev v' =
-    Data.Address.equal prev.Cfa.State.ip v'.Cfa.State.ip && (* TODO: optimize as normally is_subset is called on same ip addresses *)
-      prev.Cfa.State.ctx.Cfa.State.addr_sz = v'.Cfa.State.ctx.Cfa.State.addr_sz &&
-        prev.Cfa.State.ctx.Cfa.State.op_sz = v'.Cfa.State.ctx.Cfa.State.op_sz &&        
-                                                   (* fixpoint reached *)
-          D.is_subset v'.Cfa.State.v prev.Cfa.State.v
 
- (** [filter_vertices subsuming g vertices] returns vertices in _vertices_ that are not already in _g_ 
-     (same address and same decoding context and subsuming abstract value if subsuming = true) *)
+    (*************************** Forward from binary file ************************)
+    (*****************************************************************************)
+
+
+    (** returns true whenever the given list of statements has a jump stmt (Jmp, Call, Return) *)
+    let rec has_jmp stmts =
+        match stmts with
+        | [] -> false
+        | s::stmts' ->
+             match s with
+             | Call _ | Return  | Jmp _ -> true
+             | If (_, tstmts, estmts)   -> (has_jmp tstmts) || (has_jmp estmts)
+             | _                -> (has_jmp stmts')
+
+    let unroll_wrapper (f: unit -> int): unit =
+      try
+        match !unroll_nb with
+        | Some _ -> ()
+        | None ->
+           let n = max (f ()) !Config.unroll in
+           unroll_nb := Some n;
+           L.analysis (fun p -> p "automatic loop unrolling detection. Computed value is 0x%x" n)
+      with _ -> ()
+
+    exception Jmp_exn
+
+    type fun_stack_t = ((string * string) option * Data.Address.t * Cfa.State.t * (Data.Address.t, int * D.t) Hashtbl.t) list ref
+
+    let rec process_value (ip: Data.Address.t) (d: D.t) (s: Asm.stmt) (fun_stack: fun_stack_t) (node_id: int): D.t * Taint.Set.t =
+        L.debug2 (fun p -> p "process_value VVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\n%s\n---------\n%s\n---------" (String.concat " " (D.to_string d node_id)) (Asm.string_of_stmt s true));
+      try
+        let res, tainted =
+            match s with
+            | Nop                -> d, Taint.Set.singleton Taint.U
+            | If (e, then_stmts, else_stmts) -> process_if ip d e then_stmts else_stmts fun_stack node_id
+            | Set (dst, src)         -> D.set dst src d
+            | Directive (Remove r)       -> let d' = D.remove_register r d in Register.remove r; d', Taint.Set.singleton Taint.U
+            | Directive (Forget lval)        -> D.forget_lval lval d, Taint.Set.singleton Taint.U
+            | Directive (Unroll (e, bs)) ->
+               begin
+                 try
+                   let f () = min ((Z.to_int (D.value_of_exp d e)) + 1) bs in
+                   unroll_wrapper f
+                 with _ -> ()
+               end;
+              d, Taint.Set.singleton Taint.U
+
+            | Directive (Default_unroll) ->
+               L.analysis (fun p -> p "set unroll parameter to its default value");
+              unroll_nb := None;
+              d, Taint.Set.singleton Taint.U
+
+            | Asm.Directive (Asm.Unroll_until (addr, cmp, terminator, upper_bound, sz)) ->
+               begin
+                 try
+                   let f () =
+                     D.get_offset_from addr cmp terminator upper_bound sz d
+                   in
+                   unroll_wrapper f;
+                 with _ -> ()
+               end;
+               d, Taint.Set.singleton Taint.U
+
+            | Directive (Taint (e, lv))      ->
+                begin
+                 match lv with
+                 | V (T r) ->
+                    begin
+                      match e with
+                      | None ->
+                         let taint_src = Taint.new_src () in
+                         Hashtbl.add Dump.taint_src_tbl taint_src (Dump.R r);
+                         let mask = Config.Taint_all taint_src in
+                         D.taint_register_mask r mask d
+                      | Some c ->
+                         let taints = D.taint_sources c d in
+                         let taint' = Taint.Set.fold Taint.logor taints Taint.U in
+                         (* TODO: could be more precise here  but  taint_sources should be inlined in span_taint_to_register *)
+                         D.span_taint_to_register r taint' d
+                    end
+
+                 | M (_, 8) ->
+                    begin
+                      try
+
+                        match Data.Address.Set.elements (fst (D.mem_to_addresses d (Lval lv))) with
+                        | [a] ->
+                           begin
+                             match e with
+                             | None ->
+                                let taint_src = Taint.new_src () in
+                                Hashtbl.add Dump.taint_src_tbl taint_src (Dump.M (a, 8));
+                                D.taint_address_mask a [Config.Taint (Z.of_int 0xff, taint_src)] d
+                             | Some c ->
+                                let taints = D.taint_sources c d  in
+                                let taint' = Taint.Set.fold Taint.logor taints Taint.U in
+                                (* TODO/ same remark on precision *)
+                                D.span_taint_to_addr a taint' d
+                           end
+                        | _ -> raise Exit
+                      with _ -> L.analysis (fun p -> p "Tainting directive ignored"); d, Taint.Set.singleton Taint.U
+                    end
+                 | _ -> L.analysis (fun p -> p "Tainting directive for %s ignored" (Asm.string_of_lval lv false)); d, Taint.Set.singleton Taint.U
+               end
+            | Directive (Type (_lv, _t)) -> L.debug(fun p -> p "Type directive is ignored"); d, Taint.Set.singleton Taint.U
+
+            | Directive (Skip (f, call_conv)) as skip_statement ->
+               L.analysis (fun p -> p "Skipping %s" (Asm.string_of_fun f));
+               (* TODO: optimize to avoid type switching *)
+               let f' =
+                 match f with
+                 | Asm.Fun_name s -> Config.Fun_name s
+                 | Asm.Fun_addr a -> Config.Fun_addr (Data.Address.to_int a)
+               in
+               let d',  taint, cleanup_stmts = Stubs.skip d f' call_conv in
+               let d', taint' =
+                 Log.Trace.trace (Data.Address.global_of_int (Z.of_int 0))  (fun p -> p "%s" (string_of_stmts (skip_statement :: cleanup_stmts) true));
+                 List.fold_left (fun (d, t) stmt ->
+                     let dd, tt = process_value ip d stmt fun_stack node_id in
+                     dd, Taint.Set.union t tt) (d', taint) cleanup_stmts
+               in
+               d', taint'
+
+            | Directive (Stub (fun_name, call_conv)) as stub_statement ->
+               let prev_ip =
+                 try
+                   let _, _, v, _ = List.hd !fun_stack in
+                   Some v.Cfa.State.ip
+                 with Failure _ -> None
+               in
+               let d', taint', cleanup_stmts = Stubs.process ip prev_ip d fun_name call_conv in
+               let d', taint' =
+                 Log.Trace.trace (Data.Address.global_of_int (Z.of_int 0))  (fun p -> p "%s" (string_of_stmts (stub_statement :: cleanup_stmts) true));
+                 List.fold_left (fun (d, t) stmt ->
+                     let dd, tt = process_value ip d stmt fun_stack node_id in
+                     dd, Taint.Set.union t tt) (d', taint') cleanup_stmts
+               in
+               d', taint'
+
+            | _ -> raise Jmp_exn
+
+        in
+        res, tainted
+      with Exceptions.Empty _ -> D.bot, Taint.Set.singleton Taint.BOT
+
+    and process_if (ip: Data.Address.t) (d: D.t) (e: Asm.bexp) (then_stmts: Asm.stmt list) (else_stmts: Asm.stmt list) fun_stack (node_id: int) =
+      if has_jmp then_stmts || has_jmp else_stmts then
+             raise Jmp_exn
+           else
+             let dt, bt = List.fold_left (fun (d, b) s -> let d', b' = process_value ip d s fun_stack node_id in d', Taint.Set.union b b') (restrict d e true) then_stmts in
+             let de, be = List.fold_left (fun (d, b) s -> let d', b' = process_value ip d s fun_stack node_id in d', Taint.Set.union b b') (restrict d e false) else_stmts in
+             D.join dt de, Taint.Set.union bt be
+
+    (** returns the result of the transfert function corresponding to the statement on the given abstract value *)
+    let skip_or_import_call vertices a fun_stack =
+      (* will raise Not_found if no import or skip is found *)
+      L.debug2 (fun p -> p "skip_or_import_tbl at %s" (Data.Address.to_string a));
+      let fundec =
+        try
+          let import_desc = Hashtbl.find Decoder.Imports.tbl a in
+            Decoder.Imports.skip (Some import_desc) a
+        with
+        | Not_found -> Decoder.Imports.skip None a
+      in
+        let stmts = fundec.Asm.prologue @ fundec.Asm.stub @ fundec.Asm.epilogue in
+        let ret_addr_exp = fundec.Asm.ret_addr in
+        let t =
+            List.fold_left (fun t v ->
+                let d', t' =
+                  List.fold_left (fun (d, t) stmt ->
+                      let d', t' = process_value a d stmt fun_stack v.Cfa.State.id in
+                      d', Taint.Set.union t t') (v.Cfa.State.v, Taint.Set.singleton Taint.U) stmts
+                in
+                v.Cfa.State.v <- d';
+                let addrs, _ = D.mem_to_addresses d' ret_addr_exp in
+                let a =
+                  match Data.Address.Set.elements addrs with
+                  | [a] -> a
+                  | []  -> L.abort (fun p->p "no return address")
+                  | _l  -> L.abort (fun p->p "multiple return addresses")
+                in
+                L.analysis (fun p -> p "returning from stub to %s" (Data.Address.to_string a));
+                v.Cfa.State.ip <- a;
+                Log.Trace.trace a (fun p -> p "%s"
+                                              (Asm.string_of_stmts [ Asm.Jmp(R ret_addr_exp) ] true));
+                Taint.Set.union t t') (Taint.Set.singleton Taint.U) vertices
+        in
+        vertices, t
+
+
+    let process_stmts fun_stack g (v: Cfa.State.t) (ip: Data.Address.t): Cfa.State.t list =
+
+      let fold_to_target (apply: Data.Address.t -> unit) (vertices: Cfa.State.t list) (target: Asm.exp) : (Cfa.State.t list * Taint.Set.t) =
+        let import = ref false
+        in
+        let res = List.fold_left (fun (l, t) v ->
+          try
+            let addrs, taint_sources = D.mem_to_addresses v.Cfa.State.v target in
+            let addresses = Data.Address.Set.elements addrs in
+            match addresses with
+            | [a] ->
+              begin
+                  L.debug (fun p->p "fold_to_target addr : %s" (Data.Address.to_string a));
+                  try
+                    let res = skip_or_import_call [v] a fun_stack in
+                    import := true;
+                    (* apply a; *)  (* TODO(dm) I guess that could do it ?*)
+                    res
+                  with Not_found -> (
+                    v.Cfa.State.ip <- a;
+                    apply a;
+                    v::l, Taint.Set.union t taint_sources
+                  )
+              end
+            | [] -> (L.error (fun p -> p "Unreachable jump target from ip = %s\n" (Data.Address.to_string v.Cfa.State.ip));
+                    raise Exceptions.Jump_target)
+            | l -> L.abort (fun p -> p "Please select between the addresses %s for jump target from %s\n"
+                                  (List.fold_left (fun s a -> s^(Data.Address.to_string a)) "" l) (Data.Address.to_string v.Cfa.State.ip))
+          with
+          | Exceptions.Too_many_concrete_elements _ as e ->
+              L.exc_and_abort e (fun p -> p "Uncomputable set of address targets for jump at ip = %s\n" (Data.Address.to_string v.Cfa.State.ip))
+        ) ([], Taint.Set.singleton Taint.U) vertices
+        in
+        if !import && (List.length !fun_stack) > 0 then
+          fun_stack := List.tl !fun_stack;
+        res
+        in
+
+        let add_to_fun_stack a =
+          begin
+            try
+              let n' = (Hashtbl.find fun_unroll_tbl a) + 1 in
+              (* if n' <= !Config.fun_unroll then *)
+              Hashtbl.replace fun_unroll_tbl a n'
+              (* else
+                L.abort (fun p -> p "function at %s has been analysed more than %d times. Analysis stops" (Data.Address.to_string a) !Config.fun_unroll) *)
+            with Not_found -> Hashtbl.add fun_unroll_tbl a 1
+          end;
+          let f =
+            try
+              Some (Hashtbl.find Config.import_tbl (Data.Address.to_int a))
+            with Not_found -> None
+        in
+        fun_stack := (f, ip, v, !unroll_tbl)::!fun_stack;
+        L.info2(fun p -> p "Lenght of fun_stack: %d" (List.length !fun_stack));
+        unroll_tbl := Hashtbl.create 1000
+        in
+
+        let copy v d branch is_pred =
+          (* TODO: optimize with Cfa.State.copy that copies every field and then here some are updated => copy them directly *)
+          let v' = Cfa.copy_state g v in
+            L.info(fun p -> p "Copy state %d" v'.Cfa.State.id);
+            v'.Cfa.State.stmts <- [];
+            v'.Cfa.State.v <- d;
+            v'.Cfa.State.branch <- branch;
+            v'.Cfa.State.bytes <- [];
+            v'.Cfa.State.taint_sources <- Taint.Set.singleton Taint.U;
+            if is_pred then
+              Cfa.add_successor g v v'
+            else
+              Cfa.add_successor g (Cfa.pred g v) v';
+            v'
+        in
+
+        let iprocess_ret ipstack v fun_stack =
+          let d = v.Cfa.State.v in
+          let sp = Register.stack_pointer () in
+          let ip_on_stack, taint_sources = D.mem_to_addresses d (Asm.Lval (Asm.M (Asm.Lval (Asm.V (Asm.T sp)), (Register.size sp)))) in
+          match Data.Address.Set.elements (ip_on_stack) with
+          | [a] ->
+            begin
+              match ipstack with
+              | Some ip' ->
+                  if not (Data.Address.equal ip' a) then
+                    L.analysis (fun p -> p "computed instruction pointer %s differs from instruction pointer found on the stack %s at RET instruction"
+                                          (Data.Address.to_string ip') (Data.Address.to_string a))
+              | None -> ()
+            end;
+
+            begin
+              try
+                add_to_fun_stack a;
+                let vert, t = skip_or_import_call [v] a fun_stack in
+                Some vert, t
+              with Not_found ->
+                v.Cfa.State.ip <- a;
+                Some [v], taint_sources
+            end
+          | _ -> L.abort (fun p -> p "computed instruction pointer at return instruction is either undefined or imprecise")
+
+        in
+
+        let process_ret (fun_stack: fun_stack_t) v =
+          try
+            let _f, ipstack, _v, prev_unroll_tbl = List.hd !fun_stack in
+            fun_stack := List.tl !fun_stack;
+            unroll_tbl := prev_unroll_tbl;
+            iprocess_ret (Some ipstack) v fun_stack
+          with Failure _ ->
+            L.analysis (fun p -> p "RET without previous CALL at address %s" (Data.Address.to_string v.Cfa.State.ip));
+            iprocess_ret None v fun_stack
+        in
+
+        let rec process_if_with_jmp (vertices: Cfa.State.t list) (e: Asm.bexp) (istmts: Asm.stmt list) (estmts: Asm.stmt list) =
+          let process_branch stmts branch =
+            let vertices', b = (List.fold_left (fun (l, b) v ->
+              try
+                let d, taint_sources = restrict v.Cfa.State.v e branch in
+                if D.is_bot d then
+                  l, b
+                else
+                  (copy v d (Some true) false)::l, Taint.Set.union b taint_sources
+              with Exceptions.Empty "Interpreter.process_if_with_jmp" -> l, b) ([], Taint.Set.singleton Taint.U) vertices)
+            in
+            let vert, b' = process_list vertices' stmts in
+            vert, Taint.Set.union b b'
+          in
+          let then', bt = process_branch istmts true in
+          let else', be = process_branch estmts false in
+          List.iter (fun v ->
+            L.info(fun p -> p "Old State id %d is with ip %s" v.Cfa.State.id (Data.Address.to_string v.Cfa.State.ip) );
+            Cfa.remove_state g v;
+            Cfa.update_states g v.Cfa.State.ip
+          ) vertices;
+          (* Cfa.update_states g v.Cfa.State.ip; *)
+          then' @ else', Taint.Set.union be bt
+
+      and process_vertices (vertices: Cfa.State.t list) (s: Asm.stmt) : (Cfa.State.t list * Taint.Set.t) =
+        try
+          List.fold_left (fun (l, b) v -> let d, b' = process_value v.Cfa.State.ip v.Cfa.State.v s fun_stack v.Cfa.State.id in v.Cfa.State.v <- d;
+
+          let taint = Taint.Set.union b b' in
+                                          (*v.Cfa.State.taint_sources <- taint;*)
+              v::l, taint) ([], Taint.Set.singleton Taint.U) vertices
+
+        with Jmp_exn ->
+          match s with
+            | If (e, then_stmts, else_stmts) -> process_if_with_jmp vertices e then_stmts else_stmts
+
+            | Jmp (A a) ->
+              begin
+                try
+                  let res = skip_or_import_call vertices a fun_stack in
+                  begin (* Try to reduce the stack but it may be wrong *)
+                    try fun_stack := List.tl !fun_stack; with Failure _ -> ();
+                  end;
+                  res
+                with Not_found ->
+                  List.map (fun v -> v.Cfa.State.ip <- a; v) vertices, Taint.Set.singleton Taint.U
+              end
+
+            | Jmp (R target) ->
+              begin
+                match target with
+                | Lval (M (Const c, _)) ->
+                    begin
+                      let a = Data.Address.of_word c in
+                      try
+                        let res = skip_or_import_call vertices a fun_stack in
+                        fun_stack := List.tl !fun_stack;
+                        res
+                      with Not_found ->
+                        List.map (fun v -> v.Cfa.State.ip <- a; v) vertices, Taint.Set.singleton Taint.U
+                    end
+
+                | target -> fold_to_target (fun _a -> ()) vertices target
+              end
+
+             | Call (A a) ->
+                add_to_fun_stack a;
+                begin
+                  try
+                    skip_or_import_call vertices a fun_stack
+                  with Not_found ->
+                    List.iter (fun v -> v.Cfa.State.ip <- a) vertices;
+                    vertices, Taint.Set.singleton Taint.U
+                end
+
+             | Call (R target) ->
+              L.info(fun p -> p "Call a target with a register");
+              fold_to_target add_to_fun_stack vertices target
+
+             | Return ->
+                List.fold_left (fun (l, b) v ->
+                    let v', b' = process_ret fun_stack v in
+                    match v' with
+                    | None -> l, Taint.Set.union b b'
+                    | Some v -> v@l, Taint.Set.union b b') ([], Taint.Set.singleton Taint.U) vertices
+
+             | _       -> vertices, Taint.Set.singleton Taint.U
+
+      and process_list (vertices: Cfa.State.t list) (stmts: Asm.stmt list): Cfa.State.t list * Taint.Set.t =
+        match stmts with
+        | s::stmts ->
+           let new_vert, tainted =
+             begin
+               try
+                 let (new_vertices: Cfa.State.t list), (t: Taint.Set.t) = process_vertices vertices s in
+                 let vert, t' = process_list new_vertices stmts in
+                 vert, Taint.Set.union t t'
+               with Exceptions.Bot_deref -> [], Taint.Set.singleton Taint.BOT (* in case of undefined dereference corresponding vertices are no more explored. They are not added to the waiting list neither *)
+             end
+           in
+
+           new_vert, tainted
+        | []       -> vertices, Taint.Set.singleton Taint.U
+      in
+
+      let vstart = copy v v.Cfa.State.v None true in
+      L.info2(fun p -> p "Update ip here (old)? %s" (Data.Address.to_string v.Cfa.State.ip));
+      vstart.Cfa.State.ip <- ip;
+      L.info2(fun p -> p "Update ip here (new? %s" (Data.Address.to_string vstart.Cfa.State.ip));
+      (* check if the instruction has to be skiped *)
+      let ia = Data.Address.to_int v.Cfa.State.ip in
+      if not (Config.SAddresses.mem ia !Config.nopAddresses) then
+        let vertices, taint = process_list [vstart] v.Cfa.State.stmts in
+        begin
+          try
+            v.Cfa.State.taint_sources <- taint;
+            List.iter (fun (_f, _ip, v, _tbl) -> v.Cfa.State.taint_sources <- Taint.Set.union v.Cfa.State.taint_sources taint) !fun_stack;
+          with _ as e -> raise e;
+        end;
+        vertices
+      else
+        begin
+          Log.Trace.trace v.Cfa.State.ip (fun p -> p "nop ; forced by config");
+          L.analysis(fun p -> p "Instruction at address %s nopped by config"
+                                (Data.Address.to_string v.Cfa.State.ip));
+          [vstart]
+        end
+
+
+    (** [filter_vertices subsuming g vertices] returns vertices in _vertices_ that are not already in _g_ (same address and same decoding context and subsuming abstract value if subsuming = true) *)
     let filter_vertices (subsuming: bool) g vertices =
+      (* TODO(dm) Change this to only allow new IPs *)
       (* predicate to check whether a new state has to be explored or not *)
-     
-      let res =
-        List.fold_left (fun l v ->
-            L.debug (fun p -> p "examining (%d)" v.Cfa.State.id);
+      let same prev v' =
+          prev.Cfa.State.ctx.Cfa.State.addr_sz = v'.Cfa.State.ctx.Cfa.State.addr_sz &&
+            prev.Cfa.State.ctx.Cfa.State.op_sz = v'.Cfa.State.ctx.Cfa.State.op_sz &&
+            prev.Cfa.State.ip = v'.Cfa.State.ip && (* both ips should be the same otherwise it has no sense *)
+              (* fixpoint reached *)
+              D.is_subset v'.Cfa.State.v prev.Cfa.State.v
+      in
+      List.fold_left (fun l v ->
           try
             (* filters on cutting instruction pointers *)
             if Config.SAddresses.mem (Data.Address.to_int v.Cfa.State.ip) !Config.blackAddresses then
@@ -104,7 +638,7 @@ struct
               raise Exit
               end
             else
-              
+
               (* explore if a greater abstract state of v has already been explored *)
               if subsuming then
                 begin
@@ -112,28 +646,444 @@ struct
                       if v.Cfa.State.id = prev.Cfa.State.id then
                         ()
                       else
-                        if is_subset prev v then
-                          begin
-                            L.analysis (fun p -> p "fixed point reached between (%d) and (%d)" prev.Cfa.State.id v.Cfa.State.id);
-                            raise Exit
-                          end
-                   
-                    ) g v.Cfa.State.ip;
-                  v::l
-                end
-              else v::l
+                        if same prev v then raise Exit
+                    ) g v.Cfa.State.ip
+                end;
+            v::l
           with
             Exit -> l
           ) [] vertices
+
+
+    (** fixpoint iterator to build the CFA corresponding to the provided code starting from the initial state s.
+     g is the initial CFA reduced to the singleton s *)
+    let forward_bin (mapped_mem: Mapped_mem.t) (g: Cfa.t) (s: Cfa.State.t) (dump: Cfa.t -> unit): Cfa.t =
+      let module Vertices = Set.Make(Cfa.State) in
+      (* check whether the instruction pointer is in the black list of addresses to decode *)
+      if Config.SAddresses.mem (Data.Address.to_int s.Cfa.State.ip) !Config.blackAddresses then
+        L.abort (fun p -> p "Interpreter not started as the entry point belongs to the cut off branches\n");
+      (* boolean variable used as condition for exploration of the CFA *)
+      let continue = ref true             in
+      (* set of waiting nodes in the CFA waiting to be processed *)
+      let waiting  = ref (Vertices.singleton s) in
+      (* set d to the initial internal state of the decoder *)
+      let d = ref (Decoder.init ())             in
+      (* function stack *)
+      let fun_stack = ref []                    in
+      let hash_add_or_append htbl key rules =
+        try
+        let existing = Hashtbl.find htbl key in
+            Hashtbl.replace htbl key (rules @ existing)
+        with Not_found -> Hashtbl.add htbl key rules
       in
-      L.debug (fun p -> p "at filter_vertices: %d new vertices to explore. Before filter: %d vertices" (List.length (res)) (List.length vertices));
-      if List.length res > 0 then
+      (* compute override rules to apply *)
+      let overrides = Hashtbl.create 5 in
+      Hashtbl.iter (fun z rules ->
+        let ip = Data.Address.of_int Data.Address.Global z !Config.address_sz in
+        let rules' =
+          List.map (fun (rname, rfun) ->
+              let reg = Register.of_name rname in
+              let rule = rfun reg in
+            Init_check.check_register_init reg rule;
+            D.set_register_from_config reg rule) rules
+        in
+        hash_add_or_append overrides ip rules'
+      ) Config.reg_override;
+      if L.log_info () then
         begin
-          List.iter(fun rv -> L.debug (fun p -> p "remaining vertice to explore: %d" rv.Cfa.State.id) ) res;
+          let empty_desc = {
+              ia_name = "n/a";
+              ia_addr = None;
+              ia_typing_rule = false;
+              ia_tainting_rule = false;
+              ia_stub = false;
+            } in
+          let yesno b = if b then "YES" else "no" in
+          let itbl = Hashtbl.create 5 in
+          Hashtbl.iter (fun a (libname, fname) ->
+            let func_desc = { empty_desc with
+              ia_name = libname ^ "." ^ fname;
+              ia_addr = Some a;
+            } in
+            Hashtbl.add itbl fname func_desc) Config.import_tbl;
+          Hashtbl.iter (fun name _typing_rule ->
+            let func_desc =
+              try
+                Hashtbl.find itbl name
+              with Not_found -> { empty_desc with ia_name = "?." ^ name } in
+            Hashtbl.replace itbl name { func_desc with ia_typing_rule=true })  Config.typing_rules;
+          Hashtbl.iter (fun  (libname, name) (_callconv, _taint_ret, _taint_args) ->
+            let func_desc =
+              try
+                Hashtbl.find itbl name
+              with Not_found -> { empty_desc with ia_name = libname ^ "." ^ name } in
+            Hashtbl.replace itbl name { func_desc with ia_tainting_rule=true })  Config.tainting_rules;
+          Hashtbl.iter (fun name _ ->
+            let func_desc =
+              try
+                Hashtbl.find itbl name
+              with Not_found -> { empty_desc with ia_name = "?." ^ name } in
+            Hashtbl.replace itbl name { func_desc with ia_stub=true })  Stubs.stubs;
+
+          let addr_to_str x = match x with
+            | Some a ->
+               begin (* too bad we can't format "%%0%ix" to make a new format *)
+                 match !Config.address_sz with
+                 | 16 -> Printf.sprintf "%04x" (Z.to_int a)
+                 | 32 -> Printf.sprintf "%08x" (Z.to_int a)
+                 | 64 -> Printf.sprintf "%016x" (Z.to_int a)
+                 | _ ->  Printf.sprintf "%x" (Z.to_int a)
+               end
+            | None -> "?"
+          in
+          Hashtbl.iter (fun _name func_desc ->
+            L.info (fun p -> p "| IMPORT %-30s addr=%-16s typing=%-3s tainting=%-3s stub=%-3s"
+              func_desc.ia_name (addr_to_str func_desc.ia_addr)
+              (yesno func_desc.ia_typing_rule) (yesno func_desc.ia_tainting_rule) (yesno func_desc.ia_stub)))
+            itbl;
+          (* Hashtbl.iter (fun z (reg_name, addr_list) ->
+            let ip = Data.Address.of_int Data.Address.Global z !Config.address_sz in
+            let addr_str = List.fold_left (fun acc s -> (Z.to_string s)^","^acc) "" addr_list in
+            L.info(fun p -> p "Going further with addr %s with reg_name %s and addr list %s" (Data.Address.to_string ip) reg_name addr_str);
+            (* (fun src acc -> (Src.to_string src)^", "^acc) srcs "" *)
+          ) Config.cfgTbl; *)
         end;
-      res
-     
-                
+
+      List.iter (fun (tbl, region) ->
+        Hashtbl.iter (fun z rules ->
+            let ip = Data.Address.of_int Data.Address.Global z !Config.address_sz in
+            let rules' =
+              List.map (fun ((addr, nb), rule) ->
+                  L.analysis (fun p -> p "Adding override rule for address 0x%x" (Z.to_int addr));
+                  Init_check.check_mem rule None;
+                  let addr' = Data.Address.of_int region addr !Config.address_sz in
+                  match rule with
+                       | (Some _, _) -> D.set_memory_from_config addr' rule nb
+                       | (None, t) -> D.taint_address_mask addr' t
+                ) rules
+            in
+            hash_add_or_append overrides ip rules'
+
+        ) tbl)
+        [Config.mem_override, Data.Address.Global ];
+
+        Hashtbl.iter (fun z rules ->
+          let ip = Data.Address.of_int Data.Address.Global z !Config.address_sz in
+          try
+            let rules' =
+              List.map (fun (((id, offset), nb), rule) ->
+                let id' = Z.to_int id in
+                L.analysis (fun p -> p "Adding override rule for heap id %d" id');
+                let heap_sz = Data.Address.size_of_heap_region id' in
+                Init_check.check_mem rule (Some heap_sz);
+                let addr' = Data.Address.of_int (Data.Address.Heap(id', heap_sz)) offset !Config.address_sz in
+                match rule with
+                | (Some _, _) -> D.set_memory_from_config addr' rule nb
+                | (None, t) -> D.taint_address_mask addr' t
+              ) rules
+            in
+            hash_add_or_append overrides ip rules'
+              with _ -> raise (Exceptions.Error "id of heap is too large")
+        ) Config.heap_override;
+
+      while !continue do
+        (* a waiting node is randomly chosen to be explored *)
+        let v = Vertices.choose !waiting in
+        waiting := Vertices.remove v !waiting;
+        begin
+          try
+            L.info2 (fun p -> p "################### %s (with id %d)" (Data.Address.to_string v.Cfa.State.ip) v.Cfa.State.id);
+            Log.current_address := Some v.Cfa.State.ip;
+            (* the subsequence of instruction bytes starting at the offset provided the field ip of v is extracted *)
+            let text'        = Mapped_mem.string_from_addr mapped_mem v.Cfa.State.ip !Config.max_instruction_size in
+            (* the corresponding instruction is decoded and the successor state of v are computed and added to    *)
+            (* the CFA                                                                                             *)
+            (* except the abstract value field which is set to v.Cfa.State.value. The right value will be          *)
+            (* computed next step                                                                                  *)
+            (* the new instruction pointer (offset variable) is also returned                                      *)
+            let r =
+              match text' with
+                | Some text'' ->  Decoder.parse text'' g !d v v.Cfa.State.ip (new Cfa.oracle v.Cfa.State.v)
+                | None ->
+                  L.error(fun p -> p "Could not retrieve %i bytes at %s to decode next instruction" !Config.max_instruction_size (Data.Address.to_string v.Cfa.State.ip) );
+                  None
+            in
+            begin
+              match r with
+                | Some (v', ip', d') ->
+                  Log.Trace.trace v.Cfa.State.ip (fun p -> p "%s" (Asm.string_of_stmts v.Cfa.State.stmts true));
+                  (* add overrides if needed *)
+                  begin
+                    try
+                      let rules = Hashtbl.find overrides v'.Cfa.State.ip in
+                      let d', taint =
+                          List.fold_left (fun (d, taint) rule -> let d', taint' = rule d in d', Taint.Set.union taint taint'
+                              ) (v.Cfa.State.v, v.Cfa.State.taint_sources) rules
+                      in
+                      v.Cfa.State.v <- d';
+                      v.Cfa.State.taint_sources <- taint
+                    with
+                      Not_found -> ()
+                  end;
+                  begin
+                    try
+                      (* these vertices are updated by their right abstract values and the new ip  *)
+                      let new_vertices = update_abstract_value g v' (fun v -> v.Cfa.State.v) ip' (process_stmts fun_stack) in
+                      (* among these computed vertices only new are added to the waiting set of vertices to compute       *)
+                      let vertices'  = filter_vertices true g new_vertices in
+                      List.iter (fun v -> waiting := Vertices.add v !waiting) vertices';
+                          (* udpate the internal state of the decoder *)
+                          d := d'
+                    with
+                      Exceptions.Jump_target -> ()
+                  end;
+                | None -> ()
+            end;
+            Log.latest_finished_address := Some v.Cfa.State.ip;  (* v.Cfa.State.ip can change because of calls and jumps *)
+
+          with
+          | Exceptions.Too_many_concrete_elements msg ->
+             L.analysis (fun p -> p "%s" msg);
+
+
+          | Exceptions.Use_after_free msg ->
+            L.analysis (fun p -> p "possible use after free in alloc %s, at: %s" msg (Data.Address.to_string v.Cfa.State.ip));
+
+
+          | Exceptions.Undefined_free msg ->
+             L.analysis (fun p -> p "undefined free detected here: %s" msg);
+
+
+          | Exceptions.Double_free ->
+              L.analysis (fun p -> p "possible double free detected");
+
+
+          | Exceptions.Stop msg ->
+             L.analysis (fun p -> p "analysis stopped for the current context: %s" msg)
+
+          | e             -> L.exc e (fun p -> p "Unexpected exception"); dump g; raise e
+        end;
+        (* boolean condition of loop iteration is updated *)
+        continue := not (Vertices.is_empty !waiting);
+      done;
+      g
+
+
+    (******************** BACKWARD *******************************)
+    (*************************************************************)
+
+    let shift_and_add shift len =
+      let one = Const (Data.Word.one len) in
+      let one' = Const (Data.Word.of_int (Z.of_int (len-1)) len) in
+      let shifted_one = BinOp (Asm.Shl, one, one') in
+      BinOp (Asm.Add, shift, shifted_one)
+
+    let back_add_sub op dst e1 e2 d =
+      match e1, e2 with
+      | Lval lv1, Lval lv2 ->
+        if Asm.equal_lval lv1 lv2 then
+            if op = Asm.Sub then
+             let len = Asm.lval_length lv1 in
+             let shift = BinOp (Asm.Shr, Lval dst, Const (Data.Word.of_int (Z.of_int 1) len)) in
+             let d', taint =
+               try
+                 if Z.compare Z.one (D.value_of_exp d (Decoder.overflow_expression())) = 0 then
+                   D.set lv1 (shift_and_add shift len) d
+                 else
+                   D.set lv1 shift d
+               with _ ->
+                 let d1, taint1 = D.set lv1 shift d in
+                 let d2, taint2 = D.set lv1 (shift_and_add shift len) d in
+                 D.join d1 d2, Taint.Set.union taint1 taint2
+             in
+             if Asm.with_lval dst (Lval lv1) then
+               d', taint
+             else D.forget_lval dst d', taint
+           else
+             D.forget_lval dst d, Taint.Set.singleton Taint.TOP
+         else
+          if (Asm.with_lval dst e1) || (Asm.with_lval dst e2) then
+            D.set lv1 (BinOp (op, Lval dst, e2)) d
+          else D.forget_lval dst d, Taint.Set.singleton Taint.TOP
+
+      | Lval lv, Const c | Const c, Lval lv ->
+         let d', taint = D.set lv (BinOp (op, Lval dst, Const c)) d in
+         if Asm.with_lval dst (Lval lv) then
+           d', taint
+         else D.forget_lval dst d', taint
+
+      | Lval lv, e | e, Lval lv ->
+           if (Asm.with_lval dst e1) || (Asm.with_lval dst e2) then
+             D.set lv (BinOp (op, Lval dst, e)) d
+           else D.forget_lval dst d, Taint.Set.singleton Taint.TOP
+
+      | _ ->  D.forget_lval dst d, Taint.Set.singleton Taint.TOP
+
+
+    let back_set (dst: Asm.lval) (src: Asm.exp) (d: D.t): (D.t * Taint.Set.t) =
+      match src with
+      | Lval lv ->
+         let d', taint = D.set lv (Lval dst) d in
+         if Asm.equal_lval lv dst then d', taint
+         else D.forget_lval dst d', taint
+
+      | UnOp (Not, Lval lv) ->
+        let d', taint = D.set lv (UnOp (Not, Lval dst)) d in
+        if Asm.equal_lval lv dst then d', taint
+        else D.forget_lval dst d, taint
+
+      | BinOp (Add, e1, e2)  -> back_add_sub Sub dst e1 e2 d
+      | BinOp (Sub, e1, e2) -> back_add_sub Add dst e1 e2 d
+
+      | _ -> D.forget_lval dst d, Taint.Set.singleton Taint.TOP
+
+    (** backward transfert function on the given abstract value *)
+    let backward_process (branch: bool option) (d: D.t) (stmt: Asm.stmt) : (D.t * Taint.Set.t) =
+      (* BE CAREFUL: this function does not apply to nested if statements *)
+      let rec back d stmt =
+        L.debug (fun p -> p "back of %s.........." (Asm.string_of_stmt stmt true));
+        match stmt with
+        | Call _
+        | Return
+        | Jmp _
+        | Nop -> d, Taint.Set.singleton Taint.U
+        | Directive (Forget _) -> d, Taint.Set.singleton Taint.U
+        | Directive (Remove r) -> D.add_register r d, Taint.Set.singleton Taint.U
+        | Directive (Taint _) -> D.forget d, Taint.Set.singleton Taint.TOP
+        | Directive (Type _) -> D.forget d, Taint.Set.singleton Taint.U
+        | Directive (Unroll _) -> d, Taint.Set.singleton Taint.U
+        | Directive (Unroll_until _) -> d, Taint.Set.singleton Taint.U
+        | Directive Default_unroll -> d, Taint.Set.singleton Taint.U
+        | Directive (Stub _) -> d, Taint.Set.singleton Taint.U
+        | Directive (Skip _) -> d, Taint.Set.singleton Taint.U
+        | Set (dst, src) -> back_set dst src d
+        | Assert (_bexp, _msg) -> d, Taint.Set.singleton Taint.U (* TODO *)
+        | If (_e, istmts, estmts) ->
+           match branch with
+           | Some true -> List.fold_left (fun (d, b) s -> let d', b' = back d s in d', Taint.Set.union b b') (d, Taint.Set.singleton Taint.U) (List.rev istmts)
+           | Some false -> List.fold_left (fun (d, b) s -> let d', b' = back d s in d', Taint.Set.union b b') (d, Taint.Set.singleton Taint.U) (List.rev estmts)
+           | None -> D.forget d, Taint.Set.singleton Taint.U
+      in
+      back d stmt
+
+    let back_update_abstract_value (g:Cfa.t) (v: Cfa.State.t) (ip: Data.Address.t) (pred: Cfa.State.t): Cfa.State.t list =
+      let backward _g v _ip =
+        let start_v =
+          match v.Cfa.State.back_v with
+          | Some d -> d
+          | None -> raise (Exceptions.Empty "undefined abstract value used in backward mode")
+        in
+        let d', taint_sources =
+          List.fold_left (fun (d, b) s ->
+            let d', b' = backward_process v.Cfa.State.branch d s in
+            d', Taint.Set.union b b'
+          ) (start_v, Taint.Set.singleton Taint.U) (List.rev pred.Cfa.State.stmts)
+        in
+        let v' = D.meet pred.Cfa.State.v d' in
+        begin
+          match pred.Cfa.State.back_v, pred.Cfa.State.back_taint_sources with
+          | None, None ->
+             pred.Cfa.State.back_v <- Some v';
+            pred.Cfa.State.back_taint_sources <- Some taint_sources
+          | Some v2, Some t2 ->
+             pred.Cfa.State.back_v <- Some (D.join v' v2);
+            pred.Cfa.State.back_taint_sources <- Some (Taint.Set.union t2 taint_sources)
+          | _, _ ->
+             raise (Exceptions.Error "inconsistent state in backward mode")
+        end;
+        [pred]
+      in
+      let get_field v =
+        match v.Cfa.State.back_v with
+        | Some d -> d
+        | None -> raise (Exceptions.Error "Illegal call to get_field in interpreter")
+      in
+      update_abstract_value g v get_field ip backward
+
+
+    let back_unroll g v pred =
+      if v.Cfa.State.final then
+        begin
+          v.Cfa.State.final <- false;
+          let new_pred = Cfa.copy_state g v in
+          new_pred.Cfa.State.back_loop <- true;
+          Cfa.remove_successor g pred v;
+          Cfa.add_state g new_pred;
+          Cfa.add_successor g pred new_pred;
+          Cfa.add_successor g new_pred v;
+          new_pred
+        end
+      else
+        pred
+
+    (*************************************)
+    (* FORWARD AUXILARY FUNCTIONS ON CFA *)
+    (*************************************)
+    let unroll g v succ =
+      if v.Cfa.State.final then
+        begin
+          v.Cfa.State.final <- false;
+          let new_succ = Cfa.copy_state g v in
+          new_succ.Cfa.State.forward_loop <- true;
+          Cfa.remove_successor g v succ;
+          Cfa.add_state g new_succ;
+          Cfa.add_successor g v new_succ;
+          Cfa.add_successor g new_succ succ;
+          new_succ
+        end
+      else
+        succ
+
+
+    let forward_process (ip: Data.Address.t) (d: D.t) (stmt: Asm.stmt) (branch: bool option) (node_id: int): (D.t * Taint.Set.t) =
+      (* function stack *)
+      let fun_stack = ref [] in
+      let rec forward (d: D.t) (stmt: Asm.stmt): (D.t * Taint.Set.t) =
+        match stmt with
+        | Asm.Nop
+        | Asm.Directive (Asm.Forget _)
+        | Asm.Directive (Asm.Remove _)
+        | Asm.Directive (Asm.Taint _)
+        | Asm.Directive (Asm.Type _)
+        | Asm.Directive (Asm.Unroll _)
+        | Asm.Directive (Asm.Stub _)
+        | Asm.Directive (Asm.Skip _)
+        | Asm.Directive (Asm.Unroll_until _)
+        | Asm.Directive Asm.Default_unroll
+        | Asm.Jmp (Asm.A _)
+        | Asm.Return
+        | Asm.Call (Asm.A _) -> d, Taint.Set.singleton Taint.U
+        | Asm.Set (dst, src) -> D.set dst src d
+        | Assert (_bexp, _msg) -> d, Taint.Set.singleton Taint.U (* TODO *)
+        | Asm.If (e, istmts, estmts) ->
+           begin
+             try process_if ip d e istmts estmts fun_stack node_id
+             with Jmp_exn ->
+               match branch with
+               | Some true -> List.fold_left (fun (d, b) stmt -> let d', b' = forward d stmt in d', Taint.Set.union b b') (restrict d e true) istmts
+               | Some false -> List.fold_left (fun (d, b) stmt -> let d', b' = forward d stmt in d', Taint.Set.union b b') (restrict d e false) estmts
+               | None -> L.abort (fun p -> p "Illegal call to Interpreter.forward_process")
+           end
+        | Asm.Call (Asm.R _) -> D.forget d, Taint.Set.singleton Taint.TOP
+        | Asm.Jmp (Asm.R _) -> D.forget d, Taint.Set.singleton Taint.TOP (* TODO may be more precise but check whether the target is really in the CFA. If not then go back to forward_bin for that branch *)
+      in
+      forward d stmt
+
+    let forward_abstract_value (g:Cfa.t) (succ: Cfa.State.t) (ip: Data.Address.t) (v: Cfa.State.t): Cfa.State.t list =
+      let forward _g v _ip =
+        let d', taint_sources = List.fold_left (fun (d, b) s ->
+          let d', b' = forward_process v.Cfa.State.ip d s (succ.Cfa.State.branch) v.Cfa.State.id in
+          d', Taint.Set.union b b') (v.Cfa.State.v, Taint.Set.singleton Taint.U) (succ.Cfa.State.stmts)
+        in
+        succ.Cfa.State.v <- D.meet succ.Cfa.State.v d';
+        succ.Cfa.State.taint_sources <- taint_sources;
+        [succ]
+      in
+      update_abstract_value g v (fun v -> v.Cfa.State.v) ip forward
+
+    (****************************)
+    (* FIXPOINT ON CFA *)
+    (****************************)
     let cfa_iteration (update_abstract_value: Cfa.t -> Cfa.State.t -> Data.Address.t -> Cfa.State.t list -> Cfa.State.t list)
         (next: Cfa.t -> Cfa.State.t -> Cfa.State.t list)
         (unroll: Cfa.t -> Cfa.State.t -> Cfa.State.t -> Cfa.State.t) (g: Cfa.t) (s: Cfa.State.t) (dump: Cfa.t -> unit): Cfa.t =
@@ -151,14 +1101,10 @@ struct
             let v = Vertices.choose !waiting in
             waiting := Vertices.remove v !waiting;
             let v' = next g v in
-            let new_vertices =
-              List.fold_left (fun l v' -> (update_abstract_value g v v'.Cfa.State.ip [v'])@l) [] v'
-            in
+            let new_vertices = List.fold_left (fun l v' -> (update_abstract_value g v v'.Cfa.State.ip [v'])@l) [] v' in
             let new_vertices' = List.map (unroll g v) new_vertices in
             let vertices' = filter_vertices false g new_vertices' in
-            List.iter (fun v ->
-                Cfa.update_ips g v;
-                waiting := Vertices.add v !waiting) vertices';
+            List.iter (fun v -> waiting := Vertices.add v !waiting) vertices';
             continue := not (Vertices.is_empty !waiting);
           done;
           g
@@ -166,31 +1112,25 @@ struct
         | Invalid_argument _ -> L.analysis (fun p -> p "entry node of the CFA reached"); g
         | e -> dump g; raise e
 
-    module Core =
-      struct
-        type ctx_t = Decoder.ctx_t
-        let unroll_nb = unroll_nb
-        let cfa_iteration = cfa_iteration
-        let update_abstract_value = update_abstract_value
-        let parse = Decoder.parse
-        let init = Decoder.init
-        let unroll_tbl = unroll_tbl
-        let fun_unroll_tbl = fun_unroll_tbl
-        let filter_vertices = filter_vertices
-      end
-      
-    module Forward = Forward.Make(D)(Cfa)(Stubs)(Decoder)(Core)
-    module Backward = Backward.Make(D)(Cfa)(Decoder)(Core)
-   
+    let backward (g: Cfa.t) (s: Cfa.State.t) (dump: Cfa.t -> unit): Cfa.t =
+      cfa_iteration (fun g v ip vert -> back_update_abstract_value g v ip (List.hd vert))
+        (fun g v -> [Cfa.pred g v]) back_unroll g s dump
+
+    let forward_cfa (g: Cfa.t) (s: Cfa.State.t) (dump: Cfa.t -> unit): Cfa.t =
+      cfa_iteration (fun g v ip vert -> List.fold_left (fun l v' -> (forward_abstract_value g v ip v')@l) [] vert)
+        Cfa.succs unroll g s dump
+
     (************* INTERLEAVING OF FORWARD/BACKWARD ANALYSES *******)
+    (***************************************************************)
+
     let interleave_from_cfa (g: Cfa.t) (dump: Cfa.t -> unit): Cfa.t =
       L.analysis (fun p -> p "entering interleaving mode");
       let process mode cfa =
         Hashtbl.clear !unroll_tbl;
         List.fold_left (fun g s0 -> mode g s0 dump) cfa (Cfa.sinks cfa)
       in
-      let g_bwd = process Backward.from_cfa g in
-      process Forward.from_cfa g_bwd
-      
+      let g_bwd = process backward g in
+      process forward_cfa g_bwd
     let make_registers () = Decoder.init_registers ()
 end
+
diff --git a/ocaml/src/fixpoint/stubs.ml b/ocaml/src/fixpoint/stubs.ml
index b97a6fa5..4facd4fc 100644
--- a/ocaml/src/fixpoint/stubs.ml
+++ b/ocaml/src/fixpoint/stubs.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -22,20 +22,21 @@ module type T =
 sig
   type domain_t
 
-  val process : Data.Address.t -> Data.Address.t option -> domain_t -> string -> Asm.calling_convention_t -> 
+  val process : Data.Address.t -> Data.Address.t option -> domain_t -> string -> Asm.calling_convention_t ->
     domain_t * Taint.Set.t * Asm.stmt list
 
   val skip: domain_t -> Config.fun_t -> Asm.calling_convention_t -> domain_t *  Taint.Set.t * Asm.stmt list
-    
+
   val init: unit -> unit
 
-  val default_handler: int -> Asm.stmt list
-    
   val stubs : (string, (Data.Address.t -> Data.Address.t option -> domain_t -> Asm.lval -> (int -> Asm.lval) ->
+
                          domain_t * Taint.Set.t) * int) Hashtbl.t
 end
 
-module Make(D: Domain.T) = struct
+
+module Make (D: Domain.T) : (T with type domain_t := D.t)  =
+struct
 
     type domain_t = D.t
 
@@ -49,20 +50,18 @@ module Make(D: Domain.T) = struct
         let d' = D.allocate_on_heap d id in
         let zero = Data.Word.zero !Config.address_sz in
         let addr = region, zero in
-        let success_msg = "successfull heap allocation " in
-        let failure_msg = "heap allocation failed  " in
-        let postfix =
-          match calling_ip with
-          | Some ip -> let ip_str = Data.Address.to_string ip in "at " ^ ip_str
-          | None -> ""
-        in
-        let success_msg = success_msg ^ postfix in
-        let failure_msg = failure_msg ^ postfix in
-        D.set_lval_to_addr ret [ (addr, success_msg) ; (Data.Address.of_null (), failure_msg) ] d'
+          let success_msg = "successful heap allocation " in
+          let failure_msg = "heap allocation failed  " in
+          let postfix =
+            match calling_ip with
+            | Some ip -> let ip_str = Data.Address.to_string ip in "at " ^ ip_str
+            | None -> ""
+          in
+          let success_msg = success_msg ^ postfix in
+          let failure_msg = failure_msg ^ postfix in
+          D.set_lval_to_addr ret [ (addr, success_msg) ; (Data.Address.of_null (), failure_msg) ] d'
       with Z.Overflow -> raise (Exceptions.Too_many_concrete_elements "heap allocation: imprecise size to allocate")
 
-
-
     let check_free (ip: Data.Address.t) (a: Data.Address.t): Data.Address.heap_id_t =
       match a with
       | Data.Address.Heap (id, _), o ->
@@ -79,29 +78,29 @@ module Make(D: Domain.T) = struct
                   (Printf.sprintf "at instruction %s: base address (%s) to free not in the heap or NULL"
                   (Data.Address.to_string ip)
                   (Data.Address.to_string a)))
-           
+
     let heap_deallocator (ip: Data.Address.t) _ (d: domain_t) _ret args: domain_t * Taint.Set.t =
       let mem = Asm.Lval (args 0) in
       try
         let addrs, taint = D.mem_to_addresses d mem in
-        let addrs' = Data.Address.Set.elements addrs in 
+        let addrs' = Data.Address.Set.elements addrs in
         match addrs' with
         | [a] ->
            let id = check_free ip a in
            L.debug2 (fun p -> p "check_free");
            D.deallocate d id, taint
-             
+
         | _::_ ->
            let ids = List.fold_left (fun ids a -> (check_free ip a)::ids) [] addrs' in
            D.weak_deallocate d ids, taint
-             
+
         | [] ->
            let msg = Printf.sprintf "Illegal dereference of %s (null)" (Asm.string_of_lval (args 0) true) in
            raise (Exceptions.Null_deref msg)
       with
-        Exceptions.Too_many_concrete_elements _  ->
+        Exceptions.Too_many_concrete_elements _ ->
           raise (Exceptions.Too_many_concrete_elements "Stubs: too many addresses to deallocate")
-      
+
     let strlen (_ip: Data.Address.t) _ (d: domain_t) ret args: domain_t * Taint.Set.t =
       let zero = Asm.Const (Data.Word.zero 8) in
       let len = D.get_offset_from (Asm.Lval (args 0)) Asm.EQ zero 10000 8 d in
@@ -130,24 +129,20 @@ module Make(D: Domain.T) = struct
         let n = Z.to_int (D.value_of_exp d sz) in
         let lv1 = Asm.M (Asm.Lval (args 0), 8*n) in
         let lv2 = Asm.M (Asm.Lval (args 1), 8*n) in
-        let taint =
-          try
-            Taint.join (D.get_taint lv1 d) (D.get_taint lv2 d)
-          with _ -> Taint.TOP
-        in
         let v1 = D.value_of_exp d (Asm.Lval lv1) in
         let v2 = D.value_of_exp d (Asm.Lval lv2) in
         let res = Asm.Const (Data.Word.of_int (Z.sub v1 v2) !Config.operand_sz) in
         let d' = fst (D.set ret res d) in
+        let taint = Taint.join (D.get_taint lv1 d') (D.get_taint lv2 d') in
         D.taint_lval ret taint d'
-      with _ -> D.forget_lval ret d, Taint.Set.singleton Taint.TOP
-      
+      with _ -> D.forget_lval ret d, Taint.Set.singleton Taint.TOP (* TODO: check soundness of the returned taint *)
+
     let memset (_ip: Data.Address.t) _ (d: domain_t) ret args: domain_t * Taint.Set.t =
       let arg0 = args 0 in
       let dst = Asm.Lval arg0 in
       let src = args 1 in
       let nb = Asm.Lval (args 2) in
-      
+
       try
         let nb' = D.value_of_exp d nb in
         let byte =
@@ -166,14 +161,14 @@ module Make(D: Domain.T) = struct
             fst (D.set (Asm.M(addr, 8)) byte_exp d) (* we ignore taint as the source is a constant *)
           else
             d
-        in            
+        in
         let rec set_loop d i = if Z.sign i < 0 then d
                                else let d'=one_set d i in set_loop d' (Z.pred i) in
         let d' = set_loop d nb' in
         (* result is tainted if the destination to copy the byte is tainted *)
         D.set ret dst d'
       with _ -> L.abort (fun p -> p "too large number of bytes to copy in memset stub")
-        
+
     let print (d: domain_t) ret format_addr va_args (to_buffer: Asm.exp option): domain_t * Taint.Set.t =
         (* ret has to contain the number of bytes stored in dst ;
            format_addr is the address of the format string ;
@@ -181,7 +176,7 @@ module Make(D: Domain.T) = struct
         try
             let zero = Asm.Const (Data.Word.of_int Z.zero 8) in
             let str_len, format_string = D.get_bytes format_addr Asm.EQ zero 1000 8 d in
-            L.info (fun p -> p "(s)printf stub, format string: \"%s\"" (String.escaped (Bytes.to_string format_string)));
+            L.info (fun p -> p "(s)printf stub, format string: \"%s\" (%d)" (String.escaped (Bytes.to_string format_string)) str_len);
             let format_num d dst_off c fmt_pos arg pad_char pad_left: int * int * domain_t =
               let rec compute digit_nb fmt_pos =
                 let c = Bytes.get format_string fmt_pos in
@@ -223,7 +218,7 @@ module Make(D: Domain.T) = struct
                        let d', dst_off' = copy arg digit_nb (Char.compare c 'X' = 0) (Some (pad_char, pad_left)) !Config.operand_sz in
                        fmt_pos+1, dst_off', d'
 
-                       
+
                     | 's' ->
                       let dump =
                           match to_buffer with
@@ -231,7 +226,7 @@ module Make(D: Domain.T) = struct
                             let dst' = Asm.BinOp (Asm.Add, dst, Asm.Const (Data.Word.of_int (Z.of_int dst_off) !Config.stack_width))
                             in
                             D.copy_chars d dst'
-                          | _ -> (fun arg1 arg2 arg3 -> fst (D.print_chars d arg1 arg2 arg3))
+                          | _ -> D.print_chars d
                       in
                       fmt_pos+1, digit_nb, dump arg digit_nb (Some (pad_char, pad_left))
 
@@ -285,14 +280,15 @@ module Make(D: Domain.T) = struct
                 | _ -> L.abort (fun p -> p "Unknown format or modifier in format string: %c" c)
             in
             let rec copy_char d c (fmt_pos: int) dst_off arg_nb: int * domain_t =
-                let src = (Asm.Const (Data.Word.of_int (Z.of_int (Char.code c)) 8)) in
+                let src = (L.info(fun p->p "here-6"); Asm.Const (Data.Word.of_int (Z.of_int (Char.code c)) 8)) in
                 let dump =
                     match to_buffer with
-                    | Some dst ->  D.copy d (Asm.BinOp (Asm.Add, dst, Asm.Const (Data.Word.of_int (Z.of_int dst_off) !Config.address_sz)))
-                    | _ -> D.print d
+                    | Some dst ->  (L.info(fun p->p "here-5"); D.copy d (Asm.BinOp (Asm.Add, dst, Asm.Const (Data.Word.of_int (Z.of_int dst_off) !Config.address_sz))))
+                    | _ -> (L.info(fun p -> p "here-2"); D.print d)
                 in
-                let d' = dump src 8 in
-                    fill_buffer d' (fmt_pos+1) 0 (dst_off+1) arg_nb
+                let d' = dump src 8 in (
+                  L.info(fun p->p "here-4 %d" fmt_pos);
+                    fill_buffer d' (fmt_pos+1) 0 (dst_off+1) arg_nb)
             (* state machine for format string parsing *)
             and fill_buffer (d: domain_t) (fmt_pos: int) (state_id: int) (dst_off: int) arg_nb: int * domain_t =
                 if fmt_pos < str_len then
@@ -300,8 +296,8 @@ module Make(D: Domain.T) = struct
                     | 0 -> (* look for % *)
                       begin
                           match Bytes.get format_string fmt_pos with
-                          | '%' -> fill_buffer d (fmt_pos+1) 1 dst_off arg_nb
-                          | c -> copy_char d c fmt_pos dst_off arg_nb
+                          | '%' -> (L.info(fun p->p "here-3"); fill_buffer d (fmt_pos+1) 1 dst_off arg_nb)
+                          | c -> begin L.info(fun p -> p "here-1 %d" fmt_pos); copy_char d c fmt_pos dst_off arg_nb end;
                       end
                     | 1 -> (* % found, do we have %% ? *)
                       let c = Bytes.get format_string fmt_pos in
@@ -311,9 +307,10 @@ module Make(D: Domain.T) = struct
                           | _ -> fill_buffer d fmt_pos 2 dst_off arg_nb
                       end
                     | _ (* = 2 ie previous char is % *) ->
+                      (L.info(fun p -> p "here-7");
                       let arg = Asm.Lval (va_args arg_nb) in
                       let fmt_pos', buf_len, d' = format_arg d fmt_pos dst_off arg in
-                      fill_buffer d' fmt_pos' 0 (dst_off+buf_len) (arg_nb+1)
+                      fill_buffer d' fmt_pos' 0 (dst_off+buf_len) (arg_nb+1))
                 else
                     (* add a zero to the end of the buffer *)
                     match to_buffer with
@@ -354,55 +351,19 @@ module Make(D: Domain.T) = struct
       let d', is_tainted = print d ret format_addr va_args None in
       d', is_tainted
 
-    let printf_chk (ip: Data.Address.t) calling_ip d ret args = printf ip calling_ip d ret (shift args 1) 
+    let printf_chk (ip: Data.Address.t) calling_ip d ret args = printf ip calling_ip d ret (shift args 1)
 
     let puts (_ip: Data.Address.t) _ d ret args =
       let str = Asm.Lval (args 0) in
+      L.info (fun p -> p "puts output:");
       let len, d' = D.print_until d str (Asm.Const (Data.Word.of_int Z.zero 8)) 8 10000 true None in
       let d', taint = D.set ret (Asm.Const (Data.Word.of_int (Z.of_int len) !Config.operand_sz)) d' in
-      Log.Stdout.stdout (fun p -> p "\n");
+      L.info (fun p -> p "--- end of puts--");
       d', taint
 
-
-    let write _ip _ d ret args =
-      let fd =
-        try
-         Z.to_int (D.value_of_exp d (Asm.Lval (args 0)))
-        with _ -> L.abort (fun p -> p "imprecise file descriptor as argument of write")
-      in
-      if fd = 1 then
-        let buf = Asm.Lval (args 1) in
-        try
-          let char_nb = Z.to_int (D.value_of_exp d (Asm.Lval (args 2))) in
-          let d', len = D.print_chars d buf char_nb None in
-          let d', taint = D.set ret (Asm.Const (Data.Word.of_int (Z.of_int len) !Config.operand_sz)) d' in
-          d', taint
-        with Exceptions.Too_many_concrete_elements _ -> L.abort (fun p -> p "imprecise number of char to write")
-      else
-        L.abort (fun p -> p "write output implemented only for stdout")
-      
-    let stubs = Hashtbl.create 5
-
-    let signal_process d call_conv: domain_t * Taint.Set.t * Asm.stmt list =
-      let args = call_conv.Asm.arguments in
-      let d, taint, stmts =
-        try
-        let int_nb = Z.to_int (D.value_of_exp d (Asm.Lval (args 0))) in
-        let addrs, taint = D.mem_to_addresses d (Asm.Lval (args 1)) in
-        (* int_nb and addr has to be concrete values *)
-        match Data.Address.Set.elements addrs with
-        | [a] -> d, taint, [Asm.Directive (Asm.Handler (int_nb, a))]
-        | _ -> raise (Exceptions.Too_many_concrete_elements "several possible handler addresses")
-        with Exceptions.Too_many_concrete_elements _ ->
-          L.warn (fun p -> p "uncomputable argument of signal call (signal number or handler address). Skipped");
-          d, Taint.Set.singleton Taint.U, []
-      in
-      let cleanup_stmts = (call_conv.Asm.callee_cleanup 2) in
-      d, taint, stmts@cleanup_stmts
-
-             
     let putchar (_ip) _ d ret args =
       let str = Asm.Lval (args 0) in
+      L.info (fun p -> p "putchar output:");
       let d' = D.print d str !Config.operand_sz in
       D.set ret (Asm.Const (Data.Word.of_int Z.one !Config.operand_sz)) d'
 
@@ -414,16 +375,15 @@ module Make(D: Domain.T) = struct
         D.taint_lval ret taint_mask d'
       else
         d', Taint.Set.singleton Taint.U
-      
+
     let getchar = getc
-                                                 
+
     let bin_exit (_ip) _ _d _ret _args =
       raise (Exceptions.Stop "on exit call")
 
+    let stubs = Hashtbl.create 5
+
     let process ip calling_ip d fun_name call_conv: domain_t * Taint.Set.t * Asm.stmt list =
-       if String.compare fun_name "signal" = 0 then
-        signal_process d call_conv 
-      else     
       let apply_f, arg_nb =
         try Hashtbl.find stubs fun_name
         with Not_found -> L.abort (fun p -> p "No stub available for function [%s]" fun_name)
@@ -432,7 +392,7 @@ module Make(D: Domain.T) = struct
         try apply_f ip calling_ip d call_conv.Asm.return call_conv.Asm.arguments
         with
         | Exit -> d, Taint.Set.singleton Taint.U
-        | Exceptions.Use_after_free _ as e -> raise e 
+        | Exceptions.Use_after_free _ as e -> raise e
         | Exceptions.Double_free -> raise Exceptions.Double_free
         | Exceptions.Null_deref _ as e  -> raise e
         | Exceptions.Stop _ as e -> raise e
@@ -440,15 +400,12 @@ module Make(D: Domain.T) = struct
         | e ->
           L.exc e (fun p -> p "error while processing stub [%s]" fun_name);
           L.warn (fun p -> p "uncomputable stub for [%s]. Skipped." fun_name);
-          d, Taint.Set.singleton Taint.U 
-           
+          d, Taint.Set.singleton Taint.U
+
       in
       let cleanup_stmts = (call_conv.Asm.callee_cleanup arg_nb) in
       d', taint, cleanup_stmts
 
-
-  
-        
     let skip d f call_conv: domain_t * Taint.Set.t * Asm.stmt list =
       let arg_nb, ret_val = Hashtbl.find Config.funSkipTbl f in
       let d, taint =
@@ -457,67 +414,32 @@ module Make(D: Domain.T) = struct
         | Some ret_val' ->
            let sz = Config.size_of_config ret_val' in
            match call_conv.Asm.return with
-           | Asm.V (Asm.T r)  when Register.size r = sz -> D.set_register_from_config r ret_val' d 
+           | Asm.V (Asm.T r)  when Register.size r = sz -> D.set_register_from_config r ret_val' d
            | Asm.M (e, n) when sz = n ->
               let addrs, _ = D.mem_to_addresses d e in
               let d', taint' =
                 match Data.Address.Set.elements addrs with
-                | [a] ->     
+                | [a] ->
                    D.set_memory_from_config a  ret_val' 1 d
                 | _ -> D.forget d, Taint.Set.singleton Taint.TOP (* TODO: be more precise *)
               in
               d', taint'
-              
+
            | _ -> D.forget d, Taint.Set.singleton Taint.TOP (* TODO: be more precise *)
       in
       let cleanup_stmts = call_conv.Asm.callee_cleanup (Z.to_int arg_nb) in
       d,taint, cleanup_stmts
 
-    let default_handler sig_nb =
-      (* see man 7 signal. Implementation of POSIX.1-2001 *)
-      let ignore_sig sig_text =
-        L.analysis (fun p -> p "Handling signal %s: ignored" sig_text);
-        []
-      in
-      let abort sig_text =
-        L.analysis (fun p -> p "Handling signal %s: analysis stops" sig_text);
-        L.abort (fun p -> p "see above")
-      in
-      match sig_nb with
-      | 1 (* SIGHUP *) -> abort "SIGHUP"
-      | 2 (* SIGINT *) -> abort "SIGINT"                        
-      | 3 (* SIGQUIT *) -> abort "SIGQUIT"
-      | 4 (* SIGIL *) -> abort "SIGIL"
-      | 5 (* SIGTRAP *) -> abort "SIGTRAP"
-      | 6 (* SIGABRT *) -> abort "SIGABRT"
-      | 7 | 10 (* SIGBUS *) -> abort "SIGBUS"
-      | 8 (* SIGFPE *) -> abort "SIGFPE"
-      | 9 (* SIGKILL *) -> abort "SIGKILL"
-      | 11 (* SIGSEGV *) -> abort "SIGSEGV"
-      | 12 | 31 (* SIGSYS *) -> abort "SIGSYS"
-      | 13 (* SIGPIPE *) -> abort "SIGPIPE"
-      | 14 (* SIGALRM *) -> ignore_sig "SIGALRM"
-      | 15 (* SIGTERM *) -> abort "SIGTERM"
-      | 16 (* SIGUSR1 *) -> ignore_sig "SIGUSR1"
-      | 17 | 18 (* SIGCHLD *) -> abort "SIGCHLD"
-      | 19 | 25 (* SIGCONT *) -> ignore_sig "SIGCONT"
-      | 20 | 24 (* SIGTSTP *) -> ignore_sig "SIGSTP"
-      | 26 (* SIGTTIN *) -> ignore_sig "SIGTTIN"
-      | 27 (* SIGTTOU *) -> ignore_sig "SIGTTOU"
-      | _ -> L.analysis (fun p -> p "received Illegal signal %d. Ignored" sig_nb); []
-      
     let init () =
       Hashtbl.replace stubs "memcpy"        (memcpy,      3);
       Hashtbl.replace stubs "memcmp"        (memcmp,      3);
       Hashtbl.replace stubs "memset"        (memset,      3);
       Hashtbl.replace stubs "sprintf"       (sprintf,     0);
       Hashtbl.replace stubs "printf"        (printf,      0);
-      Hashtbl.replace stubs "write" (write, 3);
       Hashtbl.replace stubs "__sprintf_chk" (sprintf_chk, 0);
       Hashtbl.replace stubs "__printf_chk"  (printf_chk,  0);
       Hashtbl.replace stubs "puts"          (puts,        1);
       Hashtbl.replace stubs "strlen"        (strlen,      1);
-      Hashtbl.replace stubs "signal"        ((fun _ _ _ _ _ -> raise (Exceptions.Stop "on signal that stops execution of the program")),  0); (* special treatment for signal see signal_process *)
       Hashtbl.replace stubs "putchar"        (putchar,      1);
       Hashtbl.replace stubs "getchar" (getchar, 0);
       Hashtbl.replace stubs "getc" (getc, 1);
diff --git a/ocaml/src/frontend/lexer.mll b/ocaml/src/frontend/lexer.mll
index 9b6d7783..3cf9ca1c 100644
--- a/ocaml/src/frontend/lexer.mll
+++ b/ocaml/src/frontend/lexer.mll
@@ -47,8 +47,6 @@ let _ =
     "PPC"    , POWERPC;
     "RV32I", RV32I;
     "RV64I", RV64I;
-    "rv32i", RV32I;
-    "rv64i", RV64I;
     "processor_version", PROCESSOR_VERSION;
     "endianness", ENDIANNESS;
     "little", LITTLE;
@@ -71,9 +69,6 @@ let _ =
     "svr", SVR;
     "sysv", SYSV;
     "ms", MS;
-    "riscv", RISCV;
-    "RISCV", RISCV;
-    "RiscV", RISCV;
     (* analyzer tokens *)
     "ini_version", INI_VERSION;
     "unroll", UNROLL;
@@ -119,6 +114,7 @@ let _ =
     "forward_binary", FORWARD_BIN;
     "forward_cfa", FORWARD_CFA;
     "backward", BACKWARD;
+    "cfg", CFG;
     (* misc left operands *)
     "headers", HEADER;
     "override", OVERRIDE;
@@ -127,13 +123,7 @@ let _ =
     "TAINT_ALL", TAINT_ALL;
     "TAINT_NONE", TAINT_NONE;
     "null", NULL;
-    "os", OS;
-    "linux", LINUX;
-    "windows", WINDOWS;
     "taint_input", TAINT_INPUT;
-    "MPX", MPX;
-    "enabled", ENABLED;
-    "disabled", DISABLED;
     ]
 
 let strip_int s =
diff --git a/ocaml/src/frontend/parser.mly b/ocaml/src/frontend/parser.mly
index 4ea0eb3e..6ecb97de 100644
--- a/ocaml/src/frontend/parser.mly
+++ b/ocaml/src/frontend/parser.mly
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -118,9 +118,9 @@
 
       (** check that the version matches the one we support *)
       let check_ini_version input_version =
-        let supported_version = 4 in
-        if input_version != supported_version then
-          L.abort (fun p->p "Invalid configuration version: '%d', expected: '%d'" input_version supported_version);;
+    let supported_version = 4 in
+    if input_version != supported_version then
+      L.abort (fun p->p "Invalid configuration version: '%d', expected: '%d'" input_version supported_version);;
 
       (** footer function *)
       let check_context () =
@@ -154,7 +154,7 @@
           List.iter add (List.rev funs)
         in
         Hashtbl.iter add_tainting_rules libraries;
-        (* complete the table of function rules with type information *)
+    (* complete the table of function rules with type information *)
         List.iter (fun header ->
         try
           L.debug (fun p -> p "Open npk file [%s]" header);
@@ -162,25 +162,21 @@
           List.iter (fun (s, f) ->
             L.debug (fun p -> p "  - loaded type for [%s]" s);
         Hashtbl.add Config.typing_rules s f.TypedC.function_type) p.TypedC.function_declarations
-        with e -> L.exc e (fun p -> p "failed to load header %s" header)) !npk_headers;
-      (* update the os type *)
-        if !Config.format = Config.PE then
-          Config.os := Config.Windows
+        with _e -> L.error (fun p -> p "failed to load header %s" header)) !npk_headers
     ;;
 
     %}
 %token EOF LEFT_SQ_BRACKET RIGHT_SQ_BRACKET EQUAL REG MEM STAR AT
-%token CALL_CONV CDECL FASTCALL STDCALL AAPCS RISCV MEM_MODEL MEM_SZ OP_SZ STACK_WIDTH
+%token CALL_CONV CDECL FASTCALL STDCALL AAPCS MEM_MODEL MEM_SZ OP_SZ STACK_WIDTH
 %token ANALYZER INI_VERSION UNROLL FUN_UNROLL DS CS SS ES FS GS FS_BASE GS_BASE FLAT SEGMENTED STATE
 %token FORMAT RAW MANUAL PE ELF ELFOBJ ENTRYPOINT FILEPATH MASK MODE REAL PROTECTED
 %token LANGLE_BRACKET RANGLE_BRACKET LPAREN RPAREN COMMA UNDERSCORE
-%token GDT CUT ASSERT IMPORTS CALL U T STACK HEAP SEMI_COLON PROGRAM
+%token GDT CUT ASSERT IMPORTS CALL U T STACK HEAP SEMI_COLON PROGRAM CFG
 %token ANALYSIS FORWARD_BIN FORWARD_CFA BACKWARD STORE_MCFA IN_MCFA_FILE OUT_MCFA_FILE HEADER
 %token OVERRIDE TAINT_NONE TAINT_ALL SECTION SECTIONS LOGLEVEL ARCHITECTURE X86 ARMV7 ARMV8
 %token ENDIANNESS LITTLE BIG EXT_SYM_MAX_SIZE NOP LOAD_ELF_COREDUMP FUN_SKIP KSET_BOUND
 %token POWERPC SVR SYSV MS PROCESSOR_VERSION NULL X64 LOAD_PE_CRASHDUMP RV32I RV64I
-%token IGNORE_UNKNOWN_RELOCATIONS OS WINDOWS LINUX IDA TAINT_INPUT
-%token MPX ENABLED DISABLED
+%token IGNORE_UNKNOWN_RELOCATIONS IDA TAINT_INPUT
 %token <string> STRING
 %token <string> HEX_BYTES
 %token <string> HEAP_HEX_BYTES
@@ -208,6 +204,7 @@
     | LEFT_SQ_BRACKET l=libname RIGHT_SQ_BRACKET lib=library { l; lib }
     | LEFT_SQ_BRACKET ASSERT RIGHT_SQ_BRACKET r=assert_rules { r }
     | LEFT_SQ_BRACKET IMPORTS RIGHT_SQ_BRACKET i=imports     { i }
+    | LEFT_SQ_BRACKET CFG RIGHT_SQ_BRACKET c=cfg  { c }
     | LEFT_SQ_BRACKET OVERRIDE RIGHT_SQ_BRACKET o=overrides     { o }
     | LEFT_SQ_BRACKET ARMV7 RIGHT_SQ_BRACKET a=armv7_section     { a }
     | LEFT_SQ_BRACKET ARMV8 RIGHT_SQ_BRACKET a=armv8_section     { a }
@@ -284,6 +281,19 @@
                                                  Hashtbl.replace Config.import_tbl a (libname, fname);
                                                  Hashtbl.replace Config.import_tbl_rev fname a
                                                }
+    cfg:
+    | { () }
+    | c=cfg_entry l=cfg { c ; l }
+
+
+    //{ List.iter (fun a -> Config.nopAddresses := Config.SAddresses.add a !Config.nopAddresses) l }
+    cfg_entry:
+    | addr=INT EQUAL regname=STRING LPAREN addrs=addresses RPAREN {
+      Hashtbl.replace Config.cfgTbl addr (regname, addrs)
+    }
+
+    // addr_list:
+    //   arg_list = delimited (LPAREN, separated_list (COMMA, INT), RPAREN) { arg_list }
 
       npk:
     | { [] }
@@ -323,9 +333,7 @@
     | ARCHITECTURE EQUAL a=architecture  { update_mandatory ARCHITECTURE; Config.architecture := a }
     | FILEPATH EQUAL f=QUOTED_STRING     { update_mandatory FILEPATH; Config.binary := f }
     | FORMAT EQUAL f=format      { update_mandatory FORMAT; Config.format := f }
-    | NULL EQUAL v=INT { Config.null_cst := v }
-    | OS EQUAL s=os_kind { Config.os := s }
-    | MPX EQUAL b=mpx_enabled { Config.mpx := b }
+    | NULL EQUAL v=INT { Config.null_cst := v}
 
       format:
     | PE  { Config.PE }
@@ -341,8 +349,7 @@
     | AAPCS    { Config.AAPCS }
     | SVR      { Config.SVR }
     | SYSV     { Config.SYSV }
-    | MS       { Config.MS }
-    | RISCV    { Config.RISCVI }
+    | MS      { Config.MS }
 
     mmode:
     | PROTECTED { Config.Protected }
@@ -372,13 +379,7 @@
     | GS_BASE EQUAL i=init       { update_x64_mandatory GS_BASE; init_register "gs_base" i }
     | GDT LEFT_SQ_BRACKET i=INT RIGHT_SQ_BRACKET EQUAL v=INT { update_x64_mandatory GDT; Hashtbl.replace Config.gdt i v }
 
-    os_kind:
-    | WINDOWS { Config.Windows }
-    | LINUX { Config.Linux }
 
-    mpx_enabled:
-    | ENABLED { true }
-    | DISABLED { false }
     memmodel:
     | FLAT  { Config.Flat }
     | SEGMENTED { Config.Segmented }
@@ -473,7 +474,7 @@
 
     fun_skip:
     | s=STRING LPAREN p=pair_skip RPAREN { Config.Fun_name s, p }                        
-    | i = INT LPAREN p=pair_skip RPAREN { Config.Fun_addr i, p }
+    | i=INT LPAREN p=pair_skip RPAREN { Config.Fun_addr i, p }
       
     pair_skip:
     | bytes=INT COMMA ret=init { bytes, Some ret }
diff --git a/ocaml/src/loaders/elf.ml b/ocaml/src/loaders/elf.ml
index d00cdc98..6f259e11 100644
--- a/ocaml/src/loaders/elf.ml
+++ b/ocaml/src/loaders/elf.ml
@@ -21,6 +21,7 @@
 
 open Mapped_mem
 open Elf_core
+open Custom_section
 
 module L = Log.Make(struct let name = "elf" end)
 
@@ -166,16 +167,25 @@ let make_mapped_mem filepath entrypoint =
     let sym_name = sym.Elf_core.p_st_name in
     L.analysis (fun p -> p "REL COPY: %s: no lib to copy value from => ignored" sym_name) in
 
+  let reloc_simple _sym _offset _addend =
+    (* DM: Implementation of RELOC_X86_64 | RELOC_X86_64_32 *)
+    (* let value = Z.add offset addend in
+    let addr = offset in
+    L.debug(fun p -> p "REL SIMPLE: write %s at %s " (Log.zaddr_to_string value) (Log.zaddr_to_string addr));
+    patch_elf elf mapped_file sections addr value in *)
+    () in
+
   let get_reloc_func = function
     | R_ARM_JUMP_SLOT | R_386_JUMP_SLOT | R_AARCH64_JUMP_SLOT | R_X86_64_JUMP_SLOT
       -> reloc_jump_slot (Z.of_int (!Config.address_sz/8))
     | R_ARM_GLOB_DAT | R_386_GLOB_DAT | R_AARCH64_GLOB_DAT | R_X86_64_GLOB_DAT
-      | R_PPC_GLOB_DAT -> reloc_glob_dat (Z.of_int (!Config.address_sz/8))
+      | R_PPC_GLOB_DAT | R_ARM_ABS32 -> reloc_glob_dat (Z.of_int (!Config.address_sz/8))
     | R_386_TLS_TPOFF
     | R_386_32 -> reloc_obj (Z.of_int (!Config.external_symbol_max_size))
     | R_386_PC32 -> reloc_obj_rel (Z.of_int (!Config.external_symbol_max_size))
     | R_386_RELATIVE | R_X86_64_RELATIVE | R_PPC_RELATIVE -> reloc_relative Z.zero
-    | R_ARM_RELATIVE -> fun _ _ _ -> L.debug(fun p -> p "do nothing")
+    | R_X86_64_32 | R_X86_64_64 -> reloc_simple
+    | R_ARM_RELATIVE -> fun _ _ _ -> ()
     | R_PPC_ADDR32 -> reloc_obj_rel (Z.of_int (!Config.external_symbol_max_size))
     | R_PPC_JMP_SLOT -> reloc_jump_slot (Z.of_int (!Config.address_sz/8))
     | R_386_COPY | R_ARM_COPY | R_X86_64_COPY | R_AARCH64_COPY | R_PPC_COPY
@@ -184,7 +194,7 @@ let make_mapped_mem filepath entrypoint =
        let reltype = reloc_type_to_string rt in
        begin
          if (!Config.ignore_unknown_relocations)
-         then
+         then (* R_X86_64_PLT32 *)
            begin
              L.analysis (fun p-> p "Ignored unsupported relocation type [%s]" reltype);
              fun _ _ _ -> ()
@@ -216,7 +226,8 @@ let make_mapped_mem filepath entrypoint =
     raw_size = Z.zero ;
     name = "relocations" ;
   } in
+  L.info(fun p -> p "Min Addr is %s" (Z.to_string min_addr'));
   {
-    sections  = sections @ [ reloc_sec ] ;
+    sections  = sections @ [ reloc_sec ] @ get_custom_sections filepath mapped_file !reloc_external_addr;
     entrypoint = entrypoint ;
   }
diff --git a/ocaml/src/loaders/elf_core.ml b/ocaml/src/loaders/elf_core.ml
index 6f1438e0..cdc2f80b 100644
--- a/ocaml/src/loaders/elf_core.ml
+++ b/ocaml/src/loaders/elf_core.ml
@@ -687,7 +687,7 @@ type reloc_type_t =
  | R_X86_64_32S | R_X86_64_16 | R_X86_64_PC16 | R_X86_64_8 | R_X86_64_PC8 | R_X86_64_PC64
  | R_X86_64_GOTOFF64 | R_X86_64_GOTPC32 | R_X86_64_SIZE32 | R_X86_64_SIZE64 | R_X86_64_IRELATIV
   (* ARM relocation types *)
-  | R_ARM_NONE | R_ARM_COPY | R_ARM_GLOB_DAT | R_ARM_JUMP_SLOT | R_ARM_RELATIVE
+  | R_ARM_NONE | R_ARM_COPY | R_ARM_GLOB_DAT | R_ARM_JUMP_SLOT | R_ARM_RELATIVE | R_ARM_ABS32
   (* AARCH64 relocation types *)
   | R_AARCH64_COPY | R_AARCH64_GLOB_DAT | R_AARCH64_JUMP_SLOT | R_AARCH64_RELATIVE
   | R_AARCH64_TLS_DTPREL64 | R_AARCH64_TLS_DTPMOD64 | R_AARCH64_TLS_TPREL64
@@ -726,6 +726,7 @@ let to_reloc_type r hdr =
        begin
          match r with
          | 0 -> R_ARM_NONE
+         | 2 -> R_ARM_ABS32
          | 20 -> R_ARM_COPY
          | 21 -> R_ARM_GLOB_DAT
          | 22 -> R_ARM_JUMP_SLOT
@@ -781,7 +782,7 @@ let reloc_type_to_string rel =
   | R_X86_64_GOTPC32 -> "R_X86_64_GOTPC32"    | R_X86_64_SIZE32 -> "R_X86_64_SIZE32"        | R_X86_64_SIZE64 -> "R_X86_64_SIZE64"
   | R_X86_64_IRELATIV -> "R_X86_64_IRELATIV"
   | R_ARM_NONE -> "R_ARM_NONE"
-  | R_ARM_COPY -> "R_ARM_COPY" | R_ARM_GLOB_DAT -> "R_ARM_GLOB_DAT"  | R_ARM_JUMP_SLOT -> "R_ARM_JUMP_SLOT" | R_ARM_RELATIVE -> "R_ARM_RELATIVE"
+  | R_ARM_COPY -> "R_ARM_COPY" | R_ARM_GLOB_DAT -> "R_ARM_GLOB_DAT"  | R_ARM_JUMP_SLOT -> "R_ARM_JUMP_SLOT" | R_ARM_RELATIVE -> "R_ARM_RELATIVE" | R_ARM_ABS32 -> "R_ARM_ABS32"
   | R_AARCH64_COPY -> "R_AARCH64_COPY"                 | R_AARCH64_GLOB_DAT -> "R_AARCH64_GLOB_DAT"
   | R_AARCH64_JUMP_SLOT -> "R_AARCH64_JUMP_SLOT"       | R_AARCH64_RELATIVE -> "R_AARCH64_RELATIVE"
   | R_AARCH64_TLS_DTPREL64 -> "R_AARCH64_TLS_DTPREL64" | R_AARCH64_TLS_DTPMOD64 -> "R_AARCH64_TLS_DTPMOD64"
diff --git a/ocaml/src/loaders/manual.ml b/ocaml/src/loaders/manual.ml
index 25a5c538..86b3a540 100644
--- a/ocaml/src/loaders/manual.ml
+++ b/ocaml/src/loaders/manual.ml
@@ -21,27 +21,11 @@
 module L = Log.Make(struct let name = "loader.manual" end)
 
 open Mapped_mem
-
-
-let section_from_config_entry filename mapped_file config_section_entry =
-  match config_section_entry
-  with (lvirt_addr, lvirt_size, lraw_addr, lraw_size, lname) ->
-    {
-      mapped_file_name = filename ;
-      mapped_file = mapped_file ;
-      virt_addr = Data.Address.global_of_int lvirt_addr ;
-      virt_addr_end = Data.Address.global_of_int (Z.add lvirt_addr lvirt_size) ;
-      virt_size = lvirt_size;
-      raw_addr = lraw_addr;
-      raw_addr_end = Z.add lraw_addr lraw_size;
-      raw_size = lraw_size;
-      name = lname;
-    }
+open Custom_section
 
 let make_mapped_mem filepath entrypoint =
   let mapped_file = map_file filepath in
-  let sections = List.map (fun s -> section_from_config_entry filepath mapped_file s) !Config.sections in
   {
-    sections  = sections ;
+    sections  = get_custom_sections filepath mapped_file Z.zero;
     entrypoint = entrypoint ;
-  }
+  }
\ No newline at end of file
diff --git a/ocaml/src/main.ml b/ocaml/src/main.ml
index 9d74fef5..5eee41ae 100644
--- a/ocaml/src/main.ml
+++ b/ocaml/src/main.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -18,107 +18,8 @@
 
 module L = Log.Make(struct let name = "main" end)
 
-(** internal auxilliary functor to setup the environment before lauching the interpreter itself *) 
-module IEnv(Stubs: Stubs.T) = struct
+(** Entry points of the library *)
 
-  type import_attrib_t = {
-      mutable ia_name: string;
-      mutable ia_addr: Z.t option;
-      mutable ia_typing_rule: bool;
-      mutable ia_tainting_rule: bool;
-      mutable ia_stub: bool;
-    }
-
-  let dump () =
-    let empty_desc = {
-        ia_name = "n/a";
-        ia_addr = None;
-        ia_typing_rule = false;
-        ia_tainting_rule = false;
-        ia_stub = false;
-      }
-    in
-    let yesno b = if b then "YES" else "no" in
-    let itbl = Hashtbl.create 5 in
-    Hashtbl.iter (fun a (libname, fname) ->
-        let func_desc = { empty_desc with
-                          ia_name = libname ^ "." ^ fname;
-                          ia_addr = Some a;
-                        }
-        in
-        Hashtbl.add itbl fname func_desc) Config.import_tbl;
-    Hashtbl.iter (fun name _typing_rule ->
-        let func_desc =
-          try
-            Hashtbl.find itbl name
-          with Not_found -> { empty_desc with ia_name = "?." ^ name } in
-        Hashtbl.replace itbl name { func_desc with ia_typing_rule=true })  Config.typing_rules;
-    Hashtbl.iter (fun  (libname, name) (_callconv, _taint_ret, _taint_args) ->
-        let func_desc =
-          try
-            Hashtbl.find itbl name
-          with Not_found -> { empty_desc with ia_name = libname ^ "." ^ name } in
-        Hashtbl.replace itbl name { func_desc with ia_tainting_rule=true })  Config.tainting_rules;
-    Hashtbl.iter (fun name _ ->
-        let func_desc =
-          try
-            Hashtbl.find itbl name
-          with Not_found -> { empty_desc with ia_name = "?." ^ name } in
-        Hashtbl.replace itbl name { func_desc with ia_stub=true })  Stubs.stubs;
-    
-    let addr_to_str x = match x with
-      | Some a ->
-         begin (* too bad we can't format "%%0%ix" to make a new format *)
-           match !Config.address_sz with
-           | 16 -> Printf.sprintf "%04x" (Z.to_int a)
-           | 32 -> Printf.sprintf "%08x" (Z.to_int a)
-           | 64 -> Printf.sprintf "%016x" (Z.to_int a)
-           | _ ->  Printf.sprintf "%x" (Z.to_int a)
-         end
-      | None -> "?"
-    in
-    L.info (fun p -> p "Dumping state of imports");
-    Hashtbl.iter (fun _name func_desc ->
-        L.info (fun p -> p "| IMPORT %-30s addr=%-16s typing=%-3s tainting=%-3s stub=%-3s"
-                           func_desc.ia_name (addr_to_str func_desc.ia_addr)
-                           (yesno func_desc.ia_typing_rule) (yesno func_desc.ia_tainting_rule) (yesno func_desc.ia_stub)))
-      itbl;
-      L.info (fun p -> p "End of dump")
-      
-  let mapped_infos () =
-    let do_map_file =
-      match !Config.format with
-      | Config.PE -> L.abort (fun p -> p "PE file format not implemented yet")
-      | Config.ELF | Config.ELFOBJ -> Elf.make_mapped_mem
-      | Config.RAW -> Raw.make_mapped_mem
-      | Config.MANUAL -> Manual.make_mapped_mem
-    in
-    let exe_map = do_map_file !Config.binary (Data.Address.global_of_int !Config.ep) in
-    let complete_map = Elf_coredump.add_coredumps exe_map !Config.dumps in
-    Mapped_mem.current_mapping := Some complete_map;
-    if L.log_info2 () then
-      begin
-        L.info2(fun p -> p "-- Dump of mapped sections");
-        List.iter
-          (fun sec ->
-            L.info2 (
-                fun p -> p "Mapped section vaddr=%s-%s (0x%s bytes) paddr=%s->%s (0x%s bytes) %-15s %s"
-                           (Log.zaddr_to_string (Data.Address.to_int sec.Mapped_mem.virt_addr))
-                           (Log.zaddr_to_string (Data.Address.to_int sec.Mapped_mem.virt_addr_end))
-                           (Log.zaddr_to_string sec.Mapped_mem.virt_size)
-                           (Log.zaddr_to_string sec.Mapped_mem.raw_addr)
-                           (Log.zaddr_to_string sec.Mapped_mem.raw_addr_end)
-                           (Log.zaddr_to_string sec.Mapped_mem.raw_size)
-                           sec.Mapped_mem.name
-                           sec.Mapped_mem.mapped_file_name))
-          complete_map.Mapped_mem.sections;
-        L.info2(fun p -> p "-- End of mapped sections dump")
-        end
-    
-end
-                           
-
-                           
 (** [process cfile rfile lfile] launches an analysis run such that:
     - [configfile] is the name of the configuration file
     - [resultfile] is the name of the result file
@@ -129,6 +30,7 @@ let process (configfile:string) (resultfile:string) (logfile:string): unit =
   Taint.clear();
   Dump.clear();
   Register.clear();
+  (* setting the log file *)
   Log.init logfile;
   L.info (fun m -> m "BinCAT version %s" Bincat_ver.version_string);
   try
@@ -171,14 +73,38 @@ let process (configfile:string) (resultfile:string) (logfile:string): unit =
     (* override config with arguments from command line *)
     Config.apply_arg_options();
 
-    
-
     (* generating modules needed for the analysis wrt to the provided configuration *)
-    
+    let do_map_file =
+      match !Config.format with
+      | Config.PE -> L.abort (fun p -> p "PE file format not implemented yet")
+      | Config.ELF | Config.ELFOBJ -> Elf.make_mapped_mem
+      | Config.RAW -> Raw.make_mapped_mem
+      | Config.MANUAL -> Manual.make_mapped_mem
+    in
+    let exe_map = do_map_file !Config.binary (Data.Address.global_of_int !Config.ep) in
+    let complete_map = Elf_coredump.add_coredumps exe_map !Config.dumps in
+    Mapped_mem.current_mapping := Some complete_map;
+    if L.log_info2 () then
+      begin
+        L.info2(fun p -> p "-- Dump of mapped sections");
+        List.iter
+          (fun sec ->
+            L.info2 (
+                fun p -> p "Mapped section vaddr=%s-%s (0x%s bytes) paddr=%s->%s (0x%s bytes) %-15s %s"
+                           (Log.zaddr_to_string (Data.Address.to_int sec.Mapped_mem.virt_addr))
+                           (Log.zaddr_to_string (Data.Address.to_int sec.Mapped_mem.virt_addr_end))
+                           (Log.zaddr_to_string sec.Mapped_mem.virt_size)
+                           (Log.zaddr_to_string sec.Mapped_mem.raw_addr)
+                           (Log.zaddr_to_string sec.Mapped_mem.raw_addr_end)
+                           (Log.zaddr_to_string sec.Mapped_mem.raw_size)
+                           sec.Mapped_mem.name
+                           sec.Mapped_mem.mapped_file_name))
+              complete_map.Mapped_mem.sections;
+        L.info2(fun p -> p "-- End of mapped sections dump");
+      end;
     let module Vector    = Vector.Make(Reduced_bit_tainting) in
     let module Pointer   = Pointer.Make(Vector) in
     let module Domain   = Reduced_unrel_typenv_heap.Make(Pointer) in
-   
     let decoder =
       match !Config.architecture with
       | Config.X86 -> (module Core_x86.Make(Core_x86.X86): Decoder.Make)
@@ -186,16 +112,10 @@ let process (configfile:string) (resultfile:string) (logfile:string): unit =
       | Config.ARMv7 -> (module Armv7.Make: Decoder.Make)
       | Config.ARMv8 -> (module Armv8A.Make: Decoder.Make)
       | Config.POWERPC -> (module Powerpc.Make: Decoder.Make)
-      | Config.RV32I -> (module Risc_v.Make(Risc_v.I32): Decoder.Make)
-      | Config.RV64I -> (module Risc_v.Make(Risc_v.I64): Decoder.Make) 
+      | _ -> failwith "Decoder still in progress"
     in
     let module Decoder = (val decoder: Decoder.Make) in
-    let module Stubs = Stubs.Make(Domain) in
-    let module Interpreter = Interpreter.Make(Domain)(Decoder)(Stubs) in
-    let module IEnv = IEnv(Stubs) in
-
-    IEnv.mapped_infos();
-    IEnv.dump();
+    let module Interpreter = Interpreter.Make(Domain)(Decoder) in
     (* defining the dump function to provide to the fixpoint engine *)
     let dump cfa = Interpreter.Cfa.print resultfile cfa in
 
@@ -224,13 +144,13 @@ let process (configfile:string) (resultfile:string) (logfile:string): unit =
           (* 6: generate code *)
          (* 7: generate the initial cfa with only an initial state *)
          let ep' = Data.Address.of_int Data.Address.Global !Config.ep !Config.address_sz in
-         let init_reg = Interpreter.make_registers() in
-         let s = Interpreter.Cfa.init_state ep' init_reg Stubs.default_handler in
+         Interpreter.make_registers();
+         let s = Interpreter.Cfa.init_state ep' in
          let g = Interpreter.Cfa.create () in
          Interpreter.Cfa.add_state g s;
          let cfa =
            match !Mapped_mem.current_mapping with
-            | Some mm -> Interpreter.Forward.from_bin mm g s dump
+            | Some mm -> Interpreter.forward_bin mm g s dump
             | None -> L.abort(fun p -> p "File to be analysed not mapped")
           in
           (* launch an interleaving of backward/forward if an inferred property can be backward propagated *)
@@ -240,10 +160,10 @@ let process (configfile:string) (resultfile:string) (logfile:string): unit =
             cfa
 
       (* forward analysis from a CFA *)
-      | Config.Forward Config.Cfa -> from_cfa Interpreter.Forward.from_cfa
+      | Config.Forward Config.Cfa -> from_cfa Interpreter.forward_cfa
 
       (* backward analysis from a CFA *)
-      | Config.Backward -> from_cfa Interpreter.Backward.from_cfa
+      | Config.Backward -> from_cfa Interpreter.backward
     in
 
     (* dumping results *)
diff --git a/ocaml/src/npk/Makefile b/ocaml/src/npk/Makefile
index 702a8c0b..45db5675 100644
--- a/ocaml/src/npk/Makefile
+++ b/ocaml/src/npk/Makefile
@@ -4,17 +4,9 @@ GITVERSION:=$(shell git describe --dirty)
 LIBDIR=$(DESTDIR)/$(PREFIX)/lib/
 BINDIR=$(DESTDIR)/$(PREFIX)/bin/
 
-CAMLC   ?=ocamlc
-CAMLOPT ?=ocamlopt
-CAMLLEX ?=ocamllex
-MENHIR  =menhir --explain
-CAMLDEP ?=ocamldep
-CAMLDOC ?=ocamldoc
-CAMLFIND ?=ocamlfind
-
-CPPO_VER=-V OCAML:$(shell $(CAMLC) -vnum)
+CPPO_VER=-V OCAML:$(shell ocamlc -vnum)
 CPPO="cppo $(CPPO_VER)"
-CAMLLIBDIR:=$(shell $(CAMLC) -where)
+CAMLLIBDIR:=$(shell ocamlc -where)
 
 
 ML=\
@@ -23,6 +15,7 @@ ML=\
   utils/listUtils.ml\
   utils/strSet.ml\
   newspeak/conf.ml\
+  newspeak/eBigInt.ml\
   newspeak/temps.ml\
   newspeak/newspeak.ml\
   newspeak/npkcontext.ml\
@@ -78,6 +71,7 @@ MLI=\
   newspeak/conf.mli\
   newspeak/lowspeak.mli\
   newspeak/x2newspeak.mli\
+  newspeak/eBigInt.mli\
   newspeak/npkil.mli\
   newspeak/linker.mli\
   newspeak/npk2lpk.mli\
@@ -89,15 +83,21 @@ OPTS-newspeak := -w -7
 OPTS-lowspeak := -w -7
 OPTS-npk2lpk := -w -7
 
-EXTLIB := str unix graph zarith bigarray
-PACKAGES := ocamlgraph zarith
+EXTLIB := nums str unix graph zarith bigarray
+PACKAGES := ocamlgraph zarith num
 
-EXTLIBINCL := $(foreach P,$(PACKAGES), -I $(shell $(CAMLFIND) query $(P)))
+EXTLIBINCL := $(foreach P,$(PACKAGES), -I $(shell ocamlfind query $(P)))
 LIBINCL = $(EXTLIBINCL) -I utils -I newspeak -I c2newspeak
 
 
 CAMLOPTIONS = -g -w Ael -warn-error +a-3-7-50-42-44-58-26
 
+CAMLC   =ocamlc
+CAMLOPT =ocamlopt
+CAMLLEX =ocamllex
+MENHIR  =menhir --explain
+CAMLDEP =ocamldep
+CAMLDOC =ocamldoc
 
 
 ifeq ($(BYTECODE), 1)
diff --git a/ocaml/src/npk/c2newspeak/compiler.ml b/ocaml/src/npk/c2newspeak/compiler.ml
index bcb5456e..d9cb3b99 100644
--- a/ocaml/src/npk/c2newspeak/compiler.ml
+++ b/ocaml/src/npk/c2newspeak/compiler.ml
@@ -25,11 +25,11 @@ let process lexer_name lexbuf =
   NpkLexer.init lexer_name lexbuf;
   Synthack.init_tbls ();
   try NpkParser.parse NpkLexer.token lexbuf
-  with NpkParser.Error ->
+  with Parsing.Parse_error -> 
     let src_file = "Compiler.parse" in
     let lexeme 	 = Lexing.lexeme lexbuf in
     let msg 	 = "syntax error: unexpected token: "^lexeme in
-    let advice 	 = ", please check code validity" in
+    let advice 	 = ", rewrite your code" in
     let pos 	 = Lexing.lexeme_start_p lexbuf in
     let loc 	 = 
       (pos.Lexing.pos_fname, pos.Lexing.pos_lnum, 
diff --git a/ocaml/src/npk/newspeak/cir.ml b/ocaml/src/npk/newspeak/cir.ml
index 14ef8c8e..82f3a084 100644
--- a/ocaml/src/npk/newspeak/cir.ml
+++ b/ocaml/src/npk/newspeak/cir.ml
@@ -148,7 +148,7 @@ let string_of_ftyp (args_t, ret_t) =
 
 let rec string_of_exp margin e =
   match e with
-      Const (CInt i) -> Big_int_Z.string_of_big_int (Npk.Nat.to_z i)
+      Const (CInt i) -> EBigInt.string_of_big_int (Npk.Nat.to_big_int i)
     | Const _ -> "cst"
     | Lval (lv, _) -> string_of_lv margin lv
     | AddrOf (lv, t) -> "&("^(string_of_lv margin lv)^")_"^(string_of_typ t)
@@ -484,7 +484,7 @@ let rec mask e1 e2 =
       | e1, Unop(Npkil.BNot _, e2') -> e1, e2'
       | _, _ -> Npkcontext.report_error "Cir.eval_exp" "static expression expected"
   in
-  let n1 = Npk.Nat.to_z (eval_exp e1) in
+  let n1 = Npk.Nat.to_big_int (eval_exp e1) in
   let n2 = 
     try 
       Npk.Nat.to_int (eval_exp e2) 
@@ -498,51 +498,51 @@ let rec mask e1 e2 =
 	    268435455; 536870911; 1073741823 ]
   in
   if List.mem n2 l then
-    let m = Big_int_Z.big_int_of_int (n2+1)  in
-      Big_int_Z.mult_big_int (Big_int_Z.div_big_int n1 m) m
+    let m = EBigInt.big_int_of_int (n2+1)  in
+      EBigInt.mult_big_int (EBigInt.div_big_int n1 m) m
   else Npkcontext.report_error "Cir.eval_exp" "static expression expected"
 
 and eval_exp e =
   let apply_bop op v1 v2 =
     match op with
-	Npk.PlusI -> Big_int_Z.add_big_int v1 v2
-      | Npk.MinusI -> Big_int_Z.sub_big_int v1 v2
-      | Npk.MultI -> Big_int_Z.mult_big_int v1 v2
+	Npk.PlusI -> EBigInt.add_big_int v1 v2
+      | Npk.MinusI -> EBigInt.sub_big_int v1 v2
+      | Npk.MultI -> EBigInt.mult_big_int v1 v2
       | Npk.DivI -> 
-	  if (Big_int_Z.compare_big_int v2 Big_int_Z.zero_big_int = 0) 
+	  if (EBigInt.compare_big_int v2 EBigInt.zero_big_int = 0) 
 	  then Npkcontext.report_error "Cir.eval_exp" "division by zero";
-	  Big_int_Z.div_big_int v1 v2
+	  EBigInt.div_big_int v1 v2
       | Npk.Shiftlt -> 
-	  let p = Big_int_Z.power_int_positive_big_int 2 v2 in
-	    Big_int_Z.mult_big_int v1 p
+	  let p = EBigInt.power_int_positive_big_int 2 v2 in
+	    EBigInt.mult_big_int v1 p
       | Npk.Shiftrt -> 
-	  let p = Big_int_Z.power_int_positive_big_int 2 v2 in
-	    Big_int_Z.div_big_int v1 p
+	  let p = EBigInt.power_int_positive_big_int 2 v2 in
+	    EBigInt.div_big_int v1 p
       | Npk.Eq (Npk.Int _) ->
-	  if Big_int_Z.compare_big_int v1 v2 = 0 then Big_int_Z.unit_big_int
-	  else Big_int_Z.zero_big_int
+	  if EBigInt.compare_big_int v1 v2 = 0 then EBigInt.unit_big_int
+	  else EBigInt.zero_big_int
       | Npk.Gt (Npk.Int _) -> 
-	  if Big_int_Z.compare_big_int v1 v2 > 0 then Big_int_Z.unit_big_int
-	  else Big_int_Z.zero_big_int
-      | Npk.PlusPI -> Big_int_Z.add_big_int v1 v2
+	  if EBigInt.compare_big_int v1 v2 > 0 then EBigInt.unit_big_int
+	  else EBigInt.zero_big_int
+      | Npk.PlusPI -> EBigInt.add_big_int v1 v2
       | Npk.BAnd _ ->
-	  if Big_int_Z.sign_big_int v1 < 0 || Big_int_Z.sign_big_int v2 < 0 then 
+	  if EBigInt.sign_big_int v1 < 0 || EBigInt.sign_big_int v2 < 0 then 
 	    Npkcontext.report_error "Cir.eval_exp" "static expression expected";
-	  Big_int_Z.and_big_int v1 v2
+	  EBigInt.and_big_int v1 v2
       | Npk.BOr _ -> 
-	  if Big_int_Z.sign_big_int v1 < 0 || Big_int_Z.sign_big_int v2 < 0 then
+	  if EBigInt.sign_big_int v1 < 0 || EBigInt.sign_big_int v2 < 0 then
 	    Npkcontext.report_error "Cir.eval_exp" "static expression expected"; 
-	  Big_int_Z.or_big_int v1 v2
+	  EBigInt.or_big_int v1 v2
       | Npk.BXor _ -> 
-	  if Big_int_Z.sign_big_int v1 < 0 || Big_int_Z.sign_big_int v2 < 0 then 
+	  if EBigInt.sign_big_int v1 < 0 || EBigInt.sign_big_int v2 < 0 then 
 	    Npkcontext.report_error "Cir.eval_exp" "static expression expected";
-	      Big_int_Z.xor_big_int v1 v2
+	      EBigInt.xor_big_int v1 v2
       | _ -> 
 	  Npkcontext.report_error "Cir.eval_exp" "static expression expected"
   in
   let rec eval_exp (e: exp) =
     match e with
-	Const (CInt i) -> Npk.Nat.to_z i
+	Const (CInt i) -> Npk.Nat.to_big_int i
       | Binop (op, e1, e2) -> 
 	  if is_mask op e1 e2 then mask e1 e2
 	  else apply_bop op (eval_exp e1) (eval_exp e2)
@@ -550,7 +550,7 @@ and eval_exp e =
       | Unop (Npkil.Cast (Npk.Int _, Npk.Ptr), e) -> eval_exp e
       | Unop (Npkil.Coerce b, e) -> 
 	  let i = eval_exp e in
-	    if Newspeak.belongs (Npk.Nat.of_z i) b then i 
+	    if Newspeak.belongs (Npk.Nat.of_big_int i) b then i 
 	    else Npkcontext.report_error "Cir.eval_exp" "integer overflow"
       | _ -> 
 	  Npkcontext.report_error "Cir.eval_exp" "static expression expected"
@@ -560,7 +560,7 @@ and eval_exp e =
       Npkcontext.report_error "Cir.eval_exp" 
 	"expression without side-effects expected"
     end;
-    Npk.Nat.of_z (eval_exp e)
+    Npk.Nat.of_big_int (eval_exp e)
 
 module Int =
 struct
diff --git a/ocaml/src/npk/newspeak/newspeak.ml b/ocaml/src/npk/newspeak/newspeak.ml
index 6fc5a34a..c062871e 100644
--- a/ocaml/src/npk/newspeak/newspeak.ml
+++ b/ocaml/src/npk/newspeak/newspeak.ml
@@ -1,7 +1,7 @@
 (*
   C2Newspeak: compiles C code into Newspeak. Newspeak is a minimal language 
   well-suited for static analysis.
-  Copyright (C) 2007-2021  Charles Hymans, Sarah Zennou
+  Copyright (C) 2007-2011  Charles Hymans, Sarah Zennou
   
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
@@ -32,54 +32,54 @@ struct
       
   let zero = "0"
   let one = "1"
-  let of_z = Z.to_string
-  let to_z = Z.of_string
+  let of_big_int = EBigInt.string_of_big_int
+  let to_big_int = EBigInt.big_int_of_string
   let of_int x = string_of_int x
   let to_int x = 
-    let i = to_z x in
-    if not (Big_int_Z.is_int_big_int i) 
+    let i = to_big_int x in
+    if not (EBigInt.is_int_big_int i) 
     then invalid_arg "Newspeak.Nat.to_int";
-    Big_int_Z.int_of_big_int i
+    EBigInt.int_of_big_int i
 
   let apply_big_int_op op x y =
-    let x = Big_int_Z.big_int_of_string x in
-    let y = Big_int_Z.big_int_of_string y in
+    let x = EBigInt.big_int_of_string x in
+    let y = EBigInt.big_int_of_string y in
     let z = op x y in
-      Big_int_Z.string_of_big_int z
+      EBigInt.string_of_big_int z
 
-  let add = apply_big_int_op Big_int_Z.add_big_int
+  let add = apply_big_int_op EBigInt.add_big_int
 
-  let sub = apply_big_int_op Big_int_Z.sub_big_int
+  let sub = apply_big_int_op EBigInt.sub_big_int
 
-  let mul = apply_big_int_op Big_int_Z.mult_big_int
+  let mul = apply_big_int_op EBigInt.mult_big_int
 
-  let div = apply_big_int_op Big_int_Z.div_big_int
+  let div = apply_big_int_op EBigInt.div_big_int
 
   let neg x = 
-    let x = Big_int_Z.big_int_of_string x in
-    let y = Big_int_Z.minus_big_int x in
-      Big_int_Z.string_of_big_int y
+    let x = EBigInt.big_int_of_string x in
+    let y = EBigInt.minus_big_int x in
+      EBigInt.string_of_big_int y
 
   let add_int i x = 
-    let x = Big_int_Z.big_int_of_string x in
-    let y = Big_int_Z.add_int_big_int i x in
-      Big_int_Z.string_of_big_int y
+    let x = EBigInt.big_int_of_string x in
+    let y = EBigInt.add_int_big_int i x in
+      EBigInt.string_of_big_int y
 
   let mul_int i x = 
-    let x = Big_int_Z.big_int_of_string x in
-    let y = Big_int_Z.mult_int_big_int i x in
-      Big_int_Z.string_of_big_int y
+    let x = EBigInt.big_int_of_string x in
+    let y = EBigInt.mult_int_big_int i x in
+      EBigInt.string_of_big_int y
 
   let shift_left x n =
-    let x = Big_int_Z.big_int_of_string x in
-    let y = Big_int_Z.power_int_positive_int 2 n in
-    let z = Big_int_Z.mult_big_int x y in
-      Big_int_Z.string_of_big_int z
+    let x = EBigInt.big_int_of_string x in
+    let y = EBigInt.power_int_positive_int 2 n in
+    let z = EBigInt.mult_big_int x y in
+      EBigInt.string_of_big_int z
 
   let compare x y = 
-    let x = Big_int_Z.big_int_of_string x in
-    let y = Big_int_Z.big_int_of_string y in
-      Big_int_Z.compare_big_int x y
+    let x = EBigInt.big_int_of_string x in
+    let y = EBigInt.big_int_of_string y in
+      EBigInt.compare_big_int x y
 
   let to_string x = x
   let of_string x = x
diff --git a/ocaml/src/npk/newspeak/newspeak.mli b/ocaml/src/npk/newspeak/newspeak.mli
index 5937260e..9821ed95 100644
--- a/ocaml/src/npk/newspeak/newspeak.mli
+++ b/ocaml/src/npk/newspeak/newspeak.mli
@@ -1,7 +1,7 @@
 (*
   C2Newspeak: compiles C code into Newspeak. Newspeak is a minimal language 
   well-suited for static analysis.
-  Copyright (C) 2007-2021  Charles Hymans, Sarah Zennou
+  Copyright (C) 2007-2011  Charles Hymans, Sarah Zennou
   
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
@@ -70,8 +70,8 @@ module Nat: sig
       @raise Invalid_argument "Newspeak.Nat.to_int" otherwise. *)
   val to_int: t -> int
 
-  val of_z: Z.t -> t
-  val to_z: t -> Z.t
+  val of_big_int: EBigInt.big_int -> t
+  val to_big_int: t -> EBigInt.big_int
 
   val add: t -> t -> t
   val mul: t -> t -> t
diff --git a/ocaml/src/package.json b/ocaml/src/package.json
deleted file mode 100644
index 5351185d..00000000
--- a/ocaml/src/package.json
+++ /dev/null
@@ -1,14 +0,0 @@
-{
-  "name": "bincat",
-  "description": "Specification of opam dependencies for BinCAT for Windows",
-  "dependencies": {
-    "ocaml": "4.8.x",
-    "@opam/menhir": "*",
-    "@opam/zarith": "*",
-    "@opam/ocamlgraph": "*",
-    "@opam/ppx_tools": "*",
-    "@opam/cppo": "*",
-    "@opam/num": "*",
-    "@opam/gmp": "*"
-  }
-}
diff --git a/ocaml/src/utils/config.ml b/ocaml/src/utils/config.ml
index e93af820..b069f8fd 100644
--- a/ocaml/src/utils/config.ml
+++ b/ocaml/src/utils/config.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -114,7 +114,6 @@ type call_conv_t =
   | SVR (* PowerPC *)
   | SYSV (* x64 SystemV *)
   | MS (* x64 Microsoft *)
-  | RISCVI (* risc v without floating point hardware *)
 
 let call_conv_to_string cc =
   match cc with
@@ -125,11 +124,7 @@ let call_conv_to_string cc =
   | SVR -> "SVR"
   | SYSV -> "SYSV"
   | MS -> "MS"
-  | RISCVI -> "RISC V integer"
 
-(* MPX extension *)
-let mpx = ref false
-        
 let call_conv = ref CDECL
 
 let ep = ref Z.zero
@@ -153,13 +148,6 @@ let char_of_null_cst () = Char.chr (Z.to_int !null_cst)
 (* used for powerpc mfspr *)
 let processor_version = ref 0
 
-type os_t =
-  | Windows
-  | Linux
-  | Unknown_os
-
-let os = ref Unknown_os
-       
 (* if true then an interleave of backward then forward analysis from a CFA will be processed *)
 (** after the first forward analysis from binary has been performed *)
 let interleave = ref false
@@ -229,7 +217,10 @@ type fun_t =
  * (addr/name, nb_of_args_bytes * (ret value))
  *)
 let funSkipTbl: (fun_t, Z.t * ((cvalue option * tvalue list) option)) Hashtbl.t  = Hashtbl.create 5
-                                
+                 
+(* addr = reg_name(addrs, ...) *)
+let cfgTbl: (Z.t, (string * Z.t list)) Hashtbl.t = Hashtbl.create 5
+
 let reg_override: (Z.t, ((string * (Register.t -> (cvalue option * tvalue list))) list)) Hashtbl.t = Hashtbl.create 5
 let mem_override: (Z.t, ((Z.t * int) * (cvalue option * tvalue list)) list) Hashtbl.t = Hashtbl.create 5
 let heap_override: (Z.t, (((Z.t * Z.t) * int) * (cvalue option * tvalue list)) list) Hashtbl.t = Hashtbl.create 5
@@ -311,6 +302,7 @@ let clear_tables () =
   Hashtbl.clear assert_untainted_functions;
   Hashtbl.clear assert_tainted_functions;
   Hashtbl.clear import_tbl;
+  Hashtbl.clear cfgTbl;
   Hashtbl.clear reg_override;
   Hashtbl.clear mem_override;
   Hashtbl.clear heap_override;
@@ -348,6 +340,7 @@ let reset () =
   heap_content := [];
   register_content := [];
   Hashtbl.reset funSkipTbl;
+  Hashtbl.reset cfgTbl;
   Hashtbl.reset module_loglevel;
   Hashtbl.reset reg_override;
   Hashtbl.reset mem_override;
diff --git a/ocaml/src/utils/exceptions.ml b/ocaml/src/utils/exceptions.ml
index ca3312d1..2bfc7202 100644
--- a/ocaml/src/utils/exceptions.ml
+++ b/ocaml/src/utils/exceptions.ml
@@ -48,3 +48,9 @@ exception Null_deref of string
 
 (** stop the analysis for the current context *)
 exception Stop of string
+
+(** Decoding failed because instruction is unknown or unsupported **)
+exception Failed_decoding of string * int
+
+(** Failed to find the jump target **)
+exception Jump_target
\ No newline at end of file
diff --git a/ocaml/src/utils/log.ml b/ocaml/src/utils/log.ml
index 23c38bc4..a9f6d7e5 100644
--- a/ocaml/src/utils/log.ml
+++ b/ocaml/src/utils/log.ml
@@ -264,8 +264,6 @@ module History =
             paths @ acc
           ) [] preds
 
-          
-      
     let get_msg id =
       let _preds, msg = Hashtbl.find msg_id_tbl id in
       msg
