diff --git a/.gitignore b/.gitignore
index 3a63a2d0..0a97fb48 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,12 +1,19 @@
 *.cmi
 *.cmx
+*.cmxa
+*.a
+*.opt
 *.o
 *~
 *.so
 *.out
-lexer.ml
-parser.ml
-parser.mli
+*lexer.ml
+*Lexer.ml
+*parser.ml
+*Parser.ml
+*parser.mli
+*Parser.mli
+*.conflicts
 *.orig
 __pycache__/*
 .coverage
diff --git a/doc/get_key/Makefile b/doc/get_key/Makefile
index 3e4f9a9c..127b4de0 100644
--- a/doc/get_key/Makefile
+++ b/doc/get_key/Makefile
@@ -17,7 +17,7 @@ get_key_armv7: get_key.c sha1.c
 	arm-linux-gnueabi-gcc $(CFLAGS) -o $@ $^
 
 get_key_armv7_thumb: get_key_armv7_thumb.c sha1thumb.c
-	arm-linux-gnueabi-gcc-5 $(CFLAGS) -o $@ $^
+	arm-linux-gnueabi-gcc $(CFLAGS) -o $@ $^
 
 get_key_armv8: get_key.c sha1.c
 	aarch64-linux-gnu-gcc $(CFLAGS) -std=gnu99 -o $@ $^
diff --git a/doc/get_key/get_key_armv7 b/doc/get_key/get_key_armv7
old mode 100644
new mode 100755
index 5aa04a95..3fbbdef5
Binary files a/doc/get_key/get_key_armv7 and b/doc/get_key/get_key_armv7 differ
diff --git a/doc/get_key/get_key_armv7_thumb b/doc/get_key/get_key_armv7_thumb
new file mode 100755
index 00000000..d3d2fec4
Binary files /dev/null and b/doc/get_key/get_key_armv7_thumb differ
diff --git a/doc/get_key/get_key_x86 b/doc/get_key/get_key_x86
old mode 100644
new mode 100755
index 6304bd0a..a31fa77a
Binary files a/doc/get_key/get_key_x86 and b/doc/get_key/get_key_x86 differ
diff --git a/docker/Dockerfile b/docker/Dockerfile
index 64b779be..4eab8cf5 100644
--- a/docker/Dockerfile
+++ b/docker/Dockerfile
@@ -17,17 +17,17 @@ RUN apt-get update && apt-get install --no-install-recommends -y \
 # Install a later version of firejail for it to be able to report exit codes correctly
 RUN wget http://fr.archive.ubuntu.com/ubuntu/pool/universe/f/firejail/firejail_0.9.52-2_amd64.deb ; dpkg -i firejail*deb; rm firejail*deb
 
-# ubuntu-packaged python-flask does not provide the flask executable, or a
-# working module
-RUN pip install Flask
+# # ubuntu-packaged python-flask does not provide the flask executable, or a
+# # working module
+# RUN pip install Flask
 
-RUN mkdir -p /tmp/bincat_web
+# RUN mkdir -p /tmp/bincat_web
 
-RUN git clone https://github.com/airbus-seclab/bincat/
-RUN cd bincat && git checkout "$SOURCE_BRANCH" && make PREFIX=/usr && make PREFIX=/usr install
-WORKDIR /
-ENV FLASK_APP webbincat.wsgi
-ENV PYTHONPATH /usr/lib/python2.7/site-packages
+# RUN git clone https://github.com/airbus-seclab/bincat/
+# RUN cd bincat && git checkout "$SOURCE_BRANCH" && make PREFIX=/usr && make PREFIX=/usr install
+# WORKDIR /
+# ENV FLASK_APP webbincat.wsgi
+# ENV PYTHONPATH /usr/lib/python2.7/site-packages
 
-CMD python -m flask run --host=0.0.0.0 --port 5000
-EXPOSE 5000
+# CMD python -m flask run --host=0.0.0.0 --port 5000
+# EXPOSE 5000
diff --git a/docker/Dockerfile.runtests b/docker/Dockerfile.runtests
index fd92e714..e5eed981 100644
--- a/docker/Dockerfile.runtests
+++ b/docker/Dockerfile.runtests
@@ -13,23 +13,30 @@ RUN apt-get update && apt-get install --no-install-recommends -y \
         ocaml menhir ocaml-findlib libzarith-ocaml-dev \
         libocamlgraph-ocaml-dev python-setuptools python-dev \
         ocaml-compiler-libs libppx-tools-ocaml-dev cppo libapparmor1 \
-        gcc-aarch64-linux-gnu gcc-arm-linux-gnueabi gcc-powerpc-linux-gnu qemu libc6-dev-armel-cross libc6-dev-powerpc-cross libc6-dev-arm64-cross python-pytest-xdist
+        gcc-aarch64-linux-gnu gcc-arm-linux-gnueabi gcc-powerpc-linux-gnu qemu libc6-dev-armel-cross libc6-dev-powerpc-cross libc6-dev-arm64-cross python-pytest-xdist \
+        sudo
 
 # Install a later version of firejail for it to be able to report exit codes correctly
 RUN wget http://fr.archive.ubuntu.com/ubuntu/pool/universe/f/firejail/firejail_0.9.52-2_amd64.deb ; dpkg -i firejail*deb; rm firejail*deb
 
+RUN useradd -rm -d /home/builder --shell /bin/bash --gid root --groups sudo --uid 1000 builder && \
+    sed -i /etc/sudoers -re 's/^%sudo.*/%sudo ALL=(ALL:ALL) NOPASSWD: ALL/g'
+USER builder
+WORKDIR /home/builder
+
 # ubuntu-packaged python-flask does not provide the flask executable, or a
 # working module
-RUN pip install Flask
+# RUN pip install Flask
+
+# RUN mkdir -p /tmp/bincat_web
 
-RUN mkdir -p /tmp/bincat_web
+# RUN git clone https://github.com/airbus-seclab/bincat/
+# RUN cd bincat && git checkout "$SOURCE_BRANCH" && make PREFIX=/usr && make PREFIX=/usr install
 
-RUN git clone https://github.com/airbus-seclab/bincat/
-RUN cd bincat && git checkout "$SOURCE_BRANCH" && make PREFIX=/usr && make PREFIX=/usr install
-RUN cd bincat/test && make eggloaders
-WORKDIR /
-ENV FLASK_APP webbincat.wsgi
-ENV PYTHONPATH /usr/lib/python2.7/site-packages
+# RUN make PREFIX=/usr && make PREFIX=/usr install
+# RUN cd bincat/test && make eggloaders
 
-CMD python -m flask run --host=0.0.0.0 --port 5000
-EXPOSE 5000
+# ENV FLASK_APP webbincat.wsgi
+# ENV PYTHONPATH /usr/lib/python2.7/site-packages
+# CMD python -m flask run --host=0.0.0.0 --port 5000
+# EXPOSE 5000
diff --git a/ocaml/src/Makefile b/ocaml/src/Makefile
index d35954fb..f9d07268 100644
--- a/ocaml/src/Makefile
+++ b/ocaml/src/Makefile
@@ -24,6 +24,7 @@ ML=\
   data-struct/asm.ml\
   utils/dump.ml\
   data-struct/mapped_mem.ml\
+  loaders/custom_section.ml\
   loaders/manual.ml\
   loaders/raw.ml\
   loaders/elf_core.ml\
@@ -37,7 +38,6 @@ ML=\
   disassembly/armv7Imports.ml\
   disassembly/armv8aImports.ml\
   disassembly/powerpcImports.ml\
-  disassembly/riscVImports.ml\
   frontend/lexer.ml\
   frontend/parser.ml\
   domains/env.ml\
@@ -55,10 +55,8 @@ ML=\
   disassembly/armv7.ml\
   disassembly/armv8A.ml\
   disassembly/powerpc.ml\
-  fixpoint/forward.ml\
-  fixpoint/backward.ml\
   fixpoint/interpreter.ml\
-  bincat_ver.ml\
+  bincat_ver.ml \
   main.ml
 
 MLI=\
@@ -70,7 +68,7 @@ MLI=\
   domains/domain.mli\
   disassembly/cfa.mli\
   disassembly/decoder.mli\
-
+  fixpoint/stubs.mli
 
 
 DEPS-armv8A := armv8A_ppx
@@ -91,8 +89,8 @@ DEPS-reduced_unrel_typenv_heap := npk/c2newspeak/typedC.cmi npk/newspeak/newspea
 OPTS-reduced_unrel_typenv_heap := -I npk/c2newspeak -I npk/newspeak
 
 
-EXTLIB := str unix graph zarith bigarray
-PACKAGES := ocamlgraph zarith
+EXTLIB := nums str unix graph zarith bigarray
+PACKAGES := ocamlgraph zarith num
 
 EXTLIBINCL := $(foreach P,$(PACKAGES), -I $(shell ocamlfind query $(P)))
 LIBINCL = $(EXTLIBINCL) -I data-struct -I domains -I utils -I disassembly -I frontend -I loaders -I fixpoint
diff --git a/ocaml/src/data-struct/asm.ml b/ocaml/src/data-struct/asm.ml
index b968d02e..4df1f2ee 100644
--- a/ocaml/src/data-struct/asm.ml
+++ b/ocaml/src/data-struct/asm.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2018 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -120,7 +120,7 @@ and directive_t =
             tmin (n, bs) where n is an offset from memory [e].
             This offset is the minimal integer where (sz)[e] cmp terminator is true
         *)
-  | Handler of int * Address.t (** Handler(sig_nb, addr): handler of signal number _sig_nb_ is at address _addr_ *)
+
   | Stub of string * calling_convention_t (** Stub (f, args) is the stub of the function f with args as arguments *)
   | Skip of fun_t * calling_convention_t (** Skip (f, calling_conv) will skip the function _f_ but restablish the stack wrt the calling convention _calling_conv_ *)
 
@@ -269,10 +269,6 @@ let string_of_directive d extended =
        Printf.sprintf "%s <- stub of %s" (string_of_lval cc.return extended) f
      else
        Printf.sprintf "stub of %s" f
-
-  | Handler (sig_nb, handler_addr) ->
-     Printf.sprintf "the handler of signal %d is set at address %s" sig_nb (Address.to_string handler_addr)
-    
   | Skip (f, cc) ->
      let fs = string_of_fun f in
      if extended then
diff --git a/ocaml/src/data-struct/mapped_mem.ml b/ocaml/src/data-struct/mapped_mem.ml
index edc5f919..f4c95404 100644
--- a/ocaml/src/data-struct/mapped_mem.ml
+++ b/ocaml/src/data-struct/mapped_mem.ml
@@ -69,14 +69,54 @@ let is_in_section vaddr section =
   (Data.Address.compare vaddr section.virt_addr >= 0) &&
     (Data.Address.compare vaddr section.virt_addr_end < 0)
 
+let is_good_section section (taint_src: Taint.Src.t) : bool =
+  let taint_id = Taint.Src.src_id taint_src in
+  let section_name, section_id =
+    if taint_id >= Hashtbl.length Config.funSkipTbl then
+      "arg", taint_id - Hashtbl.length Config.funSkipTbl
+    else
+      "call", taint_id in
+  section.name = section_name ^ (string_of_int section_id)
+
+let find_section_from_taint (taint_src: Taint.SrcSet.t) : section_t =
+  let src = Taint.SrcSet.min_elt taint_src in
+  let mapped_mem = match !current_mapping with
+  | None -> L.abort (fun p -> p "File not mmapped")
+  | Some x -> x in
+  try
+    List.find (fun section_info -> is_good_section section_info src ) mapped_mem.sections
+  with
+    | Not_found -> raise(Exceptions.Error("Not found"))
+
+let is_good_name section (name: string): bool =
+  section.name = name
+
+let find_top_section (_) : section_t =
+  let mapped_mem = match !current_mapping with
+  | Some x -> x
+  | None -> raise (Exceptions.Too_many_concrete_elements "File not mapped")
+  in try
+    let section = List.find (fun section -> is_good_name section "topsection") mapped_mem.sections in
+    section
+  with Not_found ->
+    L.debug2(fun p -> p "Top section not found");
+    raise (Exceptions.Error("Top section not found"))
+
+let get_address_from_taint (taint_src : Taint.t) : Data.Address.t =
+  let section = match taint_src with
+    | Taint.S srcs -> find_section_from_taint srcs
+    | Taint.TOP -> find_top_section taint_src
+    | Taint.BOT | Taint.U -> raise (Exceptions.Too_many_concrete_elements "no taint")
+  in section.virt_addr
+
 (** find the first section in a section list that contains vaddr *)
 let find_section section_list vaddr =
   try
     List.find (fun section_info -> is_in_section vaddr section_info) section_list
-  with
-  | Not_found -> raise (Exceptions.Error
-                          (Printf.sprintf "No mapped section at vaddr=%s"
-                                          (Data.Address.to_string vaddr)))
+  with Not_found -> (
+      L.error(fun p -> p "No mapped section at vaddr=%s" (Data.Address.to_string vaddr));
+      raise (Exceptions.Error("No mapped section"))
+  )
 
 (** return Some byte from mapped mem at vaddr or None if it is out of the file and raises Not_found if not in any section*)
 let read mapped_mem vaddr =
@@ -87,36 +127,42 @@ let read mapped_mem vaddr =
   L.debug2 (fun p -> p "Section found [%s:%s], reading at paddr=%08x"
                        section.mapped_file_name section.name file_offset);
   (* check if we're out of the section's raw data *)
-  let byte = if file_offset >= (Z.to_int section.raw_addr_end) then
-      begin
-        L.debug2 (fun p -> p "paddr=%08x is out of the section on disk" (file_offset));
-        0
-      end
-    else
-      Bigarray.Array1.get section.mapped_file file_offset in
+  let byte =
+    if Str.string_match (Str.regexp "\\(arg[0-9]\\|call[0-9]\\|topsection\\)") section.name 0 then (
+        -1
+    ) else if file_offset >= (Z.to_int section.raw_addr_end) then (
+      L.debug2 (fun p -> p "paddr=%08x is out of the section on disk" (file_offset));
+      0
+    )
+    else Bigarray.Array1.get section.mapped_file file_offset
+    in
   L.debug(fun p -> p "read byte %02x" byte);
   Data.Word.of_int (Z.of_int byte) 8
 
 
 let string_from_addr mapped_mem vaddr len =
   L.debug2 (fun p -> p "Reading string at vaddr=%s len=%i" (Data.Address.to_string vaddr) len);
-  let sec = find_section mapped_mem.sections vaddr in
-  let raddr = Z.to_int (Z.add sec.raw_addr (Data.Address.sub vaddr sec.virt_addr)) in
-  L.debug2 (fun p -> p "Section found [%s:%s], reading at paddr=%08x"
-                       sec.mapped_file_name sec.name raddr);
-  if raddr >= (Z.to_int sec.raw_addr_end) then
-    begin
-      L.debug2 (fun p -> p "paddr=%08x is out of the section on disk" raddr);
-      None
-    end
-  else
-    let last_raddr = (min (raddr + len) (Z.to_int sec.raw_addr_end))-1 in
-    let addrs = Misc.seq raddr last_raddr in
-    let bytes = List.map
-      (fun addr -> Char.chr (Bigarray.Array1.get sec.mapped_file addr))
-      addrs in
-    L.debug (fun p -> p "read %i bytes at %s: [%s]"
-      len (Data.Address.to_string vaddr)
-      (String.concat " " (List.map (fun b -> Printf.sprintf "%02x" (Char.code b)) bytes)));
-    Some (Misc.string_of_chars bytes)
-
+  try
+    let sec = find_section mapped_mem.sections vaddr in
+    let raddr = Z.to_int (Z.add sec.raw_addr (Data.Address.sub vaddr sec.virt_addr)) in
+    L.debug2 (fun p -> p "Section found [%s:%s], reading at paddr=%08x"
+                        sec.mapped_file_name sec.name raddr);
+    if raddr >= (Z.to_int sec.raw_addr_end) then
+      begin
+        L.debug2 (fun p -> p "paddr=%08x is out of the section on disk" raddr);
+        None
+      end
+    else
+      let last_raddr = (min (raddr + len) (Z.to_int sec.raw_addr_end))-1 in
+      let addrs = Misc.seq raddr last_raddr in
+      try
+        let bytes = List.map
+          (fun addr -> Char.chr (Bigarray.Array1.get sec.mapped_file addr))
+          addrs in
+          L.debug (fun p -> p "read %i bytes at %s: [%s]" len (Data.Address.to_string vaddr)
+            (String.concat " " (List.map (fun b -> Printf.sprintf "%02x" (Char.code b)) bytes)));
+        Some (Misc.string_of_chars bytes)
+      with Invalid_argument msg -> L.error(fun p -> p "%s" msg); None
+    with
+       | Exceptions.Error msg -> L.error(fun p -> p "%s" msg); None
+       | _ -> L.error(fun p -> p "Unknown exceptions occured"); None
\ No newline at end of file
diff --git a/ocaml/src/data-struct/taint.ml b/ocaml/src/data-struct/taint.ml
index 06ee915d..e59b7c85 100644
--- a/ocaml/src/data-struct/taint.ml
+++ b/ocaml/src/data-struct/taint.ml
@@ -38,6 +38,9 @@ module Src =
       | Tainted of id_t (** surely tainted by the given source *)
       | Maybe of id_t (** maybe tainted by then given source *)
 
+    let src_id src : int =
+      match src with
+      | Tainted id | Maybe id -> id
 
     (* comparison between tainting sources. Returns
     - 0 is equal
@@ -80,12 +83,12 @@ let total_order t1 t2 =
      let n2 = SrcSet.cardinal src2 in
      let n = n1-n2 in
      if n <> 0 then n1
-     else SrcSet.compare src1 src2   
+     else SrcSet.compare src1 src2
   | BOT, _ -> -1
   | TOP, _ -> -1
   | U, _ -> -1
   | _, _ -> 1
-          
+
 let is_subset t1 t2 =
   match t1, t2 with
   | BOT, _
@@ -235,12 +238,12 @@ let to_z (t: t): Z.t =
 let to_string t =
   match t with
   | BOT -> "_"
-  | U -> ""
+  | U -> "U"
   | TOP -> "?"
   | S srcs ->
      SrcSet.fold (fun src acc -> (Src.to_string src)^", "^acc) srcs ""
 
-module Set = Set.Make (struct type aux_t = t type t = aux_t let compare = total_order end) 
+module Set = Set.Make (struct type aux_t = t type t = aux_t let compare = total_order end)
 
 let string_of_set s =
   let s' = Set.fold (fun s acc -> logor s acc) s U in
diff --git a/ocaml/src/disassembly/armv7.ml b/ocaml/src/disassembly/armv7.ml
index 57e2e45f..a62f4524 100644
--- a/ocaml/src/disassembly/armv7.ml
+++ b/ocaml/src/disassembly/armv7.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -170,7 +170,7 @@ struct
                        BBinOp(LogOr, BBinOp(LogAnd, n_is_set, v_is_clear),
                               BBinOp(LogAnd, n_is_clear, v_is_set)))
 
-    | _ -> L.abort (fun p -> p "Unexpected condiction code %x" cc)
+    | _ -> L.abort (fun p -> p "Unexpected condition code %x" cc)
 
 
   let op_add rd rn op2_stmt =
@@ -233,9 +233,8 @@ struct
       nflag_update_exp rd ]
 
 
-
   module Cfa = Cfa.Make(Domain)
-               
+
   module Imports = Armv7Imports.Make(Domain)(Stubs)
 
   type state = {
@@ -252,6 +251,13 @@ struct
     | MARK_ISN of Asm.stmt
     | MARK_FLAG of Asm.stmt
 
+  type shift_type_t =
+    | SRType_LSL
+    | SRType_LSR
+    | SRType_ASR
+    | SRType_RRX
+    | SRType_ROR
+
   let mark_as_isn l =
     List.map (fun i -> MARK_ISN i) l
 
@@ -270,16 +276,23 @@ struct
 
   (* fatal error reporting *)
   let error a msg =
-    L.abort (fun p -> p "at %s: %s" (Address.to_string a) msg)
+    L.error (fun p -> p "at %s: %s" (Address.to_string a) msg);
+    raise (Exceptions.Failed_decoding ((Printf.sprintf "ERROR: %s" (Address.to_string a)), 0))
 
-  let error_isn a isn msg =
-    L.abort (fun p -> p "at %s: isn=%08x %s" (Address.to_string a) isn msg)
+  let error_isn a (isn: int) ?(isn2) (msg: string) =
+    let isn = match isn2 with None -> isn | Some value -> (isn lsl 16 lor value) in
+    L.error (fun p -> p "at %s: isn=%08x %s" (Address.to_string a) isn msg);
+    raise (Exceptions.Failed_decoding ((Printf.sprintf "ERROR_ISN: %d" isn), isn))
 
-  let notimplemented_arm s isn mnemo = L.abort (fun p -> p "at %s: %s (%08x): ARM instruction not implemented yet"
-                                                 (Address.to_string s.a) mnemo isn)
+  let notimplemented_arm s isn mnemo =
+    L.error (fun p -> p "at %s: %s (%08x): ARM instruction not implemented yet"
+                                                 (Address.to_string s.a) mnemo isn);
+    raise (Exceptions.Failed_decoding ((Printf.sprintf "ARM: %s" mnemo), isn))
 
-  let notimplemented_thumb s isn mnemo = L.abort (fun p -> p "at %s: %s (%04x): thumb instruction not implemented yet"
-                                                 (Address.to_string s.a) mnemo isn)
+  let notimplemented_thumb s isn mnemo =
+    L.error (fun p -> p "at %s: %s (%04x): thumb instruction not implemented yet"
+                                                 (Address.to_string s.a) mnemo isn);
+    raise (Exceptions.Failed_decoding ((Printf.sprintf "THUMB: %s" mnemo), isn))
 
   let string_to_char_list str =
     let len = String.length str in
@@ -315,10 +328,12 @@ struct
 
   let return (s: state) (instruction: int) (stmts: Asm.stmt list): Cfa.State.t * Data.Address.t =
     let isn_size =
-      if s.thumbmode && ((((instruction lsr 11) land 0x3) = 0) ||
-                           (((instruction lsr 13) land 0x7) != 0b111))
-      then 2 (* Thumb 16 bits instruction *)
-      else 4 (* Arm or Thumb 32 bits instruction *) in
+      if s.thumbmode then (
+        if instruction > 0xFFFF then 4
+        else if ((((instruction lsr 11) land 0x3) = 0) || (((instruction lsr 13) land 0x7) != 0b111)) then 2
+        else 4
+      ) else 4
+    in
     s.b.Cfa.State.stmts <- stmts;
     s.b.Cfa.State.bytes <-
       if isn_size = 2 then
@@ -440,8 +455,8 @@ struct
     @ jmp_or_call_stmt
 
   let branch_exchange s instruction =
-    let zero = const 0 1 in
-    let one = const 1 1 in
+    let zero = const 0 32 in
+    let one = const 1 32 in
     let jreg = Lval(V(treg (instruction land 0xf))) in
     let bit1 = BinOp(And, jreg, one) in
     let target = BinOp(And, jreg, const 0xfffffffe 32) in
@@ -461,7 +476,6 @@ struct
     let sign = TernOp( Cmp (EQ, msb, const 0 32), const 0 32, sign_mask) in
     BinOp(Or, shifted, sign)
 
-
   let asr_stmt_exp exp shift_exp =
     let sign_mask = BinOp(Shl, const (-1) 32, BinOp(Sub, const 32 32, shift_exp)) in
     let shifted = BinOp(Shr, exp, shift_exp) in
@@ -495,106 +509,187 @@ struct
                        one33),
                   const 1 1, const 0 1))
 
+  let lsl_c register (amount: int) =
+    BinOp(Shl, Lval (V (treg register )), const amount 32),
+    Lval (V (preg register amount amount))
 
-  let single_data_transfer s instruction =
-    let rd = (instruction lsr 12) land 0xf in
-    let rn = (instruction lsr 16) land 0xf in
-    let ofs = if instruction land (1 lsl 25) = 0 then (* immediate value *)
-        const (instruction land 0xfff) 32
-      else
-        let rm = instruction land 0xf in
-        let shift_op = (instruction lsr 4) land 0xff in
-        if shift_op land 1 = 1 then error s.a "Shift register cannot be specified for single data transfer instructions"
-        else
-          let shift_type = (shift_op lsr 1) land 3 in
-          let shift_amount = (shift_op lsr 3) land 0x1f in
-          match  shift_type with
-          | 0b00 -> (* logical shift left *)
-             if shift_amount = 0 then
-              Lval (V (treg rm))
-            else
-              BinOp(Shl, Lval (V (treg rm)), const shift_amount 32)
-          | 0b01 -> (* logical shift right *)
-             let actual_shift = if shift_amount = 0 then 32 else shift_amount in
-             BinOp(Shl, Lval (V (treg rm)), const actual_shift 32)
-          | 0b10 -> (* asr *)
-             let actual_shift = if shift_amount = 0 then 32 else shift_amount in
-             asr_stmt (Lval (V (treg rm))) actual_shift
-          | 0b11 -> (* ror *)
-             let actual_shift = if shift_amount = 0 then 32 else shift_amount in
-             ror_stmt (Lval (V (treg rm))) actual_shift
-          | _ -> error s.a "unexpected shift type insingle data xfer" in
-    let updown = if (instruction land (1 lsl 23)) = 0 then Sub else Add in
-    let preindex = (instruction land (1 lsl 24)) <> 0 in
-    let writeback = (instruction land (1 lsl 21)) <> 0 in
-    let length, dst_or_src = if (instruction land (1 lsl 22)) = 0 then
-        32, (V (treg rd))
+  let lsr_c register (amount: int) =
+    BinOp(Shl, Lval (V (treg register )), const amount 32),
+    Lval( V( preg register (amount-1) (amount-1)))
+
+  let set_cflag_from_carry_out (carry_out: Asm.exp) : Asm.stmt =
+    Set( V (T cflag), carry_out)
+
+  let decode_shift_carry (register: int) (shift_type: shift_type_t) (shift_amount: int) (carry_in: Asm.exp) : Asm.exp * Asm.exp =
+    (* *)
+    match shift_type with
+    | SRType_LSL -> (* LSL *)
+      if shift_amount = 0 then
+        Lval (V (treg register)), carry_in
       else
-        8, (V (preg rd 0 7)) in
-    let src_or_dst = match preindex,writeback with
-      | true, false -> M (BinOp(updown, Lval (V (treg rn)), ofs), length)
-      | true, true
-      | false, false -> M (Lval (V (treg rn)), length) (* if post-indexing, write back is implied and W=0 *)
-      | false, true -> error s.a "Undefined combination (post indexing and W=1)" in
-    let stmts,update_pc = if (instruction land (1 lsl 20)) = 0 then (* store *)
-        [ Set (src_or_dst, Lval dst_or_src)], false
-      else (* load *)
-        if length = 32 then
-          [ Set (V (treg rd), Lval src_or_dst) ], rd = 15
+        lsl_c register shift_amount (* LSL_C *)
+    | SRType_LSR -> (* LSR *)
+        lsr_c register shift_amount
+    | SRType_ASR -> (* ASR *)
+      let carry_out = Lval( V( preg register (shift_amount-1) (shift_amount-1))) in
+      (asr_stmt (Lval (V (treg register))) shift_amount), carry_out
+    | SRType_ROR -> (* ROR *)
+      let div = shift_amount / 32 in
+      let stmts, _ =
+        if div = 0 then
+          lsr_c register shift_amount
         else
-          [ Set (V (treg rd), UnOp(ZeroExt 32, Lval src_or_dst)) ], rd = 15 in
-    let write_back_stmt = Set (V (treg rn), BinOp(updown, Lval (V (treg rn)), ofs)) in
-    let stmts' =
-      if preindex then
-        if writeback then
-          write_back_stmt :: stmts
-        else
-          stmts
+          lsl_c register (shift_amount - div)
+        in
+      stmts, Lval( V( preg register 31 31))
+    | SRType_RRX -> (* RRX *)
+      let stmts = BinOp(Or,
+            BinOp(Shl, carry_in, const 31 32),
+            BinOp(And,
+                  Lval (V (treg register)),
+                  const (0x7fffffff) 32))
+      in
+      stmts, Lval( V( preg register 0 0))
+
+  let decode_imm_shift (shift: int) (shift_amount: int) : shift_type_t * int =
+    (* DecodeImmShift *)
+    let actual_shift = if shift_amount = 0 then 32 else shift_amount in
+    match shift with
+    | 0b00 -> SRType_LSL, shift_amount
+    | 0b01 -> SRType_LSR, actual_shift
+    | 0b10 -> SRType_ASR, actual_shift
+    | 0b11 -> (if shift_amount = 0 then SRType_RRX, 1 else SRType_ROR, shift_amount)
+    | _ -> L.abort(fun p -> p "Unknown shift (imm)")
+
+  let decode_reg_shift (shift: int) : shift_type_t =
+    (* DecodeRegShift *)
+    match shift with
+    | 0b00 -> SRType_LSL
+    | 0b01 -> SRType_LSR
+    | 0b10 -> SRType_ASR
+    | 0b11 -> SRType_ROR
+    | _ -> L.abort(fun p -> p "Unknown shift (reg)")
+
+  let decode_shift (register: int) (shift_t: shift_type_t) (shift_n: int) (carry_in: Asm.exp) : Asm.exp =
+    (* Shift *)
+    let result, _ = decode_shift_carry register shift_t shift_n carry_in in
+    result
+
+  let nth_bit (n: int) (value:int) : int = (value lsr n) land 1
+
+  let is_valid (v: char) (m: int) =
+    if v = 'x' then true
+    else int_of_char v = (m+48)
+
+  let bitstring (length: int) (value: int) =
+    let rec aux (acc: int list) (cur: int) (value: int) =
+      if cur < length then (aux ((nth_bit cur value) :: acc) (cur+1) value) else acc
+    in aux [] 0 value
+
+  let check_mask (mask: string) (value: int) : bool =
+    let bit_value = bitstring (String.length mask) value in
+    List.fold_left(fun acc el -> acc && el ) true (List.mapi (fun index b -> is_valid mask.[index] b) bit_value)
+
+  let single_data_transfer _s instruction (store: bool) (updown: bool) (index: bool) (writeback: bool) (offset: Asm.exp) (size: int) (signed: bool) =
+    let rt = (instruction lsr 12) land 0xf in
+    let rn = (instruction lsr 16) land 0xf in
+    let operation = if signed then (SignExt 32) else (ZeroExt 32) in
+    let add = if updown then Sub else Add in
+    let offset_addr = BinOp(add, Lval(V (treg rn)), offset) in
+    let address = if index then offset_addr else Lval (V (treg rn)) in
+    let src, dst =
+      if store then (
+        (if size = 32 then Lval(V (treg rt)) else Lval(V (preg rt 0 (size-1)))),
+        M(address, size)
+      )
+      else (
+        (if size = 32 then Lval(M(address, size)) else UnOp(operation, Lval(M(address, size)))), V (treg rt)
+      )
+   in
+   let update_pc_stmts = if store && rt = 15 then [ Jmp (R (Lval (V (T pc)))) ] else [] in
+    let stmts =
+      [ Set( dst, src)  ]
+    in if writeback then
+      stmts @ [Set(V (treg rn), offset_addr)] @ update_pc_stmts
+    else
+      stmts @ update_pc_stmts
+
+  let decode_single_data_transfer s instruction =
+    (* A5.3 *)
+    let a = instruction lsr 25 land 1 in
+    let op1 = instruction lsr 20 land 0x1f in
+    let b = instruction lsr 4 land 1 in
+
+    let u = instruction land (1 lsl 23) <> 0 in
+    let p = (instruction land (1 lsl 24)) <> 0 in
+    let w = (instruction land (1 lsl 21)) <> 0 in
+
+    let register_form = instruction land (1 lsl 25) <> 0 in
+    let offset = if register_form = false then (* immediate value *)
+      const (instruction land 0xfff) 32
+    else
+      let rm = instruction land 0xf in
+      let shift_op = (instruction lsr 4) land 0xff in
+      if shift_op land 1 = 1 then error s.a "Shift register cannot be specified for single data transfer instructions"
       else
-        stmts @ [ write_back_stmt ] in
-    if update_pc then
-      stmts' @ [ Jmp (R (Lval (V (T pc)))) ]
+        let shift_t, shift_n = decode_imm_shift ((shift_op lsr 1) land 3) ((shift_op lsr 3) land 0x1f) in
+        decode_shift rm shift_t shift_n (const 0 1) in
+
+    if (a = 0 || (a = 1 && b = 0)) && check_mask "xx0x0" op1 then
+      (* STR immediate/register *)
+      single_data_transfer s instruction true u p (not p || w) offset 32 false
+    else if (a = 0 || (a = 1 && b = 0)) && check_mask "0x010" op1 then
+      (* STRT *)
+      single_data_transfer s instruction true u true true offset 32 false
+    else if (a = 0 || (a = 1 && b = 0)) && check_mask "xx0x1" op1 then
+        (* LDR *)
+        single_data_transfer s instruction false u p (not p || w) offset 32 false
+    else if (a = 0 || (a = 1 && b = 0)) && check_mask "0x011" op1 then
+      (* LDRT *)
+      single_data_transfer s instruction false u true true offset 32 false
+    else if (a = 0 || (a = 1 && b = 0)) && check_mask "xx1x0" op1 then
+      (* STRB *)
+      single_data_transfer s instruction false u p (not p || w) offset 8 false
+    else if (a = 0 || (a = 1 && b = 0)) && check_mask "0x110" op1 then
+      (* STRBT *)
+      single_data_transfer s instruction false u true true offset 8 false
+    else if (a = 0 || (a = 1 && b = 0)) && check_mask "xx1x1" op1 then
+      (* LDRB *)
+      single_data_transfer s instruction true u p (not p || w) offset 8 false
+    else if (a = 0 || (a = 1 && b = 0)) && check_mask "0x111" op1 then
+      (* LDRBT *)
+      single_data_transfer s instruction true true true (not p || w) offset 8 false
     else
-      stmts'
+      error s.a (Printf.sprintf "Load store undefined with op1 %d" op1)
+
 
   let halfword_data_transfer s instruction =
-    let rd = (instruction lsr 12) land 0xf in
-    let rn = (instruction lsr 16) land 0xf in
-    let load = (instruction land (1 lsl 20)) <> 0 in
-    let writeback = (instruction land (1 lsl 21)) <> 0 in
-    let immediate = (instruction land (1 lsl 22)) <> 0 in
-    let updown = if (instruction land (1 lsl 23)) = 0 then Sub else Add in
-    let preindex = (instruction land (1 lsl 24)) <> 0 in
-    let extend_op = if (instruction land (1 lsl 6)) = 0 then (ZeroExt 32) else (SignExt 32) in
-    let length = if (instruction land (1 lsl 5)) <> 0 then 16 else 8 in
-    let ofs = if immediate then
-        const (((instruction lsr 4) land 0xf0) lor (instruction land 0xf)) 32
-      else
-        let rm = instruction land 0xf in
-        Lval (V (treg rm)) in
-    let index_expr = BinOp(updown, Lval (V (treg rn)), ofs) in
-    let src_or_dst = match preindex,writeback with
-      | true, false -> M (index_expr, length)
-      | true, true
-      | false, false -> M (Lval (V (treg rn)), length) (* if post-indexing, write back is implied and W=0 *)
-      | false, true -> error s.a "Undefined combination (post indexing and W=1)" in
-    let stmts, update_pc = if load then
-        [ Set (V (treg rd), UnOp(extend_op, Lval src_or_dst)) ], rd = 15
-      else
-        [ Set (src_or_dst, Lval (V (preg rd 0 (length-1)))) ], false in
-    let write_back_stmt = Set (V (treg rn), index_expr) in
-    let stmts' =
-      if preindex then
-        if writeback then
-          write_back_stmt :: stmts
-        else
-          stmts
-      else
-        stmts @ [ write_back_stmt ] in
-    if update_pc then
-      stmts' @ [ Jmp (R (Lval (V (T pc)))) ]
+    (* A5.2.9 *)
+    let op = instruction lsr 20 land 1 in
+    let op2 = instruction lsr 5 land 3 in
+
+    let offset = if (instruction land (1 lsl 22)) <> 0 then
+      const (((instruction lsr 4) land 0xf0) lor (instruction land 0xf)) 32
     else
-      stmts'
+      let rm = instruction land 0xf in
+      Lval (V (treg rm)) in
+
+    let u = instruction land (1 lsl 23) <> 0 in
+
+    match op2 with
+    | 0b01 -> (
+      if op = 0 then
+        (* STRHT *)
+      single_data_transfer s instruction true u true true offset 16 false
+      else
+        (* LDRHT *)
+        single_data_transfer s instruction false u true true offset 16 false
+    )
+    | 0b10 -> (* LDRSBT *)
+      single_data_transfer s instruction false u true true offset 8 true
+    | 0b11 -> (* LDRSHT *)
+      single_data_transfer s instruction false u true true offset 16 true
+    | _ -> error s.a "Undefined halfword data transfer"
 
 
   let data_proc_msr rm_stmt =
@@ -635,7 +730,7 @@ struct
                                         const 28 32))),
                       const 0b10000 32)) ]
        else error s.a "MRS from SPSR not supported"
-    | 0b000,0,0b01 -> 
+    | 0b000,0,0b01 ->
        if instruction land (1 lsl 22) = 0 then (* Source PSR: 0=CPSR 1=SPSR *)
          data_proc_msr rm_stmt
        else error s.a "MSR to SPSR not supported"
@@ -774,8 +869,7 @@ struct
     | 0,_,_ when (op1 land 0b11001 == 0b10000) && (op2 land 0b1000 == 0b0000) -> data_proc_misc_instructions s instruction
     | 0,_,_ when (op1 land 0b11001 == 0b10000) && (op2 land 0b1001 == 0b1000) -> notimplemented_arm s instruction "Halfword multiply and multiply accumulate"
     | 1,0b10000,_ -> if rd == 15
-                     then L.abort (fun p -> p "at %s: MOVW to PC: UNPREDICTABLE"
-                                              (Address.to_string s.a))
+                     then  error_isn s.a instruction "MOVW to PC: UNPREDICTABLE"
                      else [ Set (V (treg rd),
                                  Const (Word.of_int (Z.of_int (
                                                          ((instruction lsr 4) land 0xf000)
@@ -886,7 +980,7 @@ struct
               vflag_update_exp (Lval (V (treg rn))) op2_stmt (Lval (V (P (tmpreg, 0, 31)))) ;
               Directive (Remove tmpreg) ],
             false
-         | _ -> L.abort (fun p -> p "unexpected opcode %x" op1) in
+         | _ -> error_isn s.a instruction "unexpected opcode"  in
        let stmt_cc =
          if set_cond_codes
          then
@@ -1008,6 +1102,7 @@ struct
     | _ -> error s.a (Printf.sprintf "unknown packing/unpacking/saturation/reversal instruction opcode (%08x)" instruction)
 
 
+
   let decode_media_instructions s instruction =
     let op1 = (instruction lsr 20) land 0x1f in
     let op2 = (instruction lsr 5) land 7 in
@@ -1041,20 +1136,21 @@ struct
     let instruction = build_instruction s str in
     let stmts = match (instruction lsr 25) land 0x7 with
     | 0b000 | 0b001 -> data_proc s instruction
-    | 0b010 -> single_data_transfer s instruction
+    | 0b010 -> decode_single_data_transfer s instruction
     | 0b011 ->
            if instruction land (1 lsl 4) = 0
-           then single_data_transfer s instruction
+           then decode_single_data_transfer s instruction
            else decode_media_instructions s instruction
     | 0b100 -> block_data_transfer s instruction (* block data transfer *)
     | 0b101 -> branch s instruction
-    | 0b110 -> error s.a (Printf.sprintf "Comprocessor data transfer not implemented (isn=%08x)" instruction)
+    | 0b110 -> error s.a (Printf.sprintf "Coprocessor data transfer not implemented (isn=%08x)" instruction)
     | 0b111 when instruction land (1 lsl 24) = 0 -> error s.a (Printf.sprintf "coprocessor operation or register transfer (isn=%08x)" instruction)
     | 0b111 when instruction land (1 lsl 24) <> 0 -> error s.a (Printf.sprintf "software interrupt not implemented (swi=%08x)" instruction)
     | _ -> error s.a (Printf.sprintf "Unknown opcode 0x%x" instruction) in
     let cc = (instruction lsr 28) land 0xf in
     let stmts_cc = wrap_cc cc stmts in
-    let current_pc = Const (Word.of_int (Z.add (Address.to_int s.a) (Z.of_int 8)) 32) in (* pc is 8 bytes ahead because of pre-fetching. *)
+    let current_pc = Const (Word.of_int (Z.add (Address.to_int s.a) (Z.of_int 8)) 32) in
+     (* pc is 8 bytes ahead because of pre-fetching. *)
     (* XXX: 12 bytes if a register is used to specify a shift amount *)
     return s instruction (Set( V (T pc), current_pc) :: stmts_cc)
 
@@ -1120,7 +1216,27 @@ struct
       | 0b010 -> L.analysis (fun p -> p "WFE: Wait For Event hint") ; []
       | 0b011 -> L.analysis (fun p -> p "WFI: Wait For Interrupt hint") ; []
       | 0b100 -> L.analysis (fun p -> p "SEV: Send Event hint") ; []
-      | _ -> L.abort (fun p -> p "Unkown hint instruction encoding %04x" isn)
+      | _ -> error_isn s.a isn"Unkown hint instruction encoding"
+
+  let decode_thumb_cbz_cbnz _s isn cmp =
+    let rn = isn land 0x7 in
+    let imm = (((isn lsr 9) land 1) lsl 6) lor (((isn lsr 3) land 0x1f) lsl 1) in (* bit<9>:bit<7-3>:0 *)
+    let branching = [
+      Set (V (T pc), BinOp(Add, Lval (V (T pc)), const imm 32)) ;
+          Jmp (R (Lval (V (T pc))))
+    ] in
+    [ If (Cmp (cmp, Lval (V (treg rn)), const 0 32), branching, []) ] |> mark_as_isn
+
+  let rev _s (rd: int) (rm: int) =
+    (* REV implementation for 32 bits *)
+    let tmpreg = Register.make (Register.fresh_name ()) 32 in
+    [ Set ((V (T tmpreg)), Lval (V (treg rm))); (* Set (V (treg rd), Lval (V (treg rm))) *)
+      Set (V (preg rd 24 31), Lval( V (P (tmpreg, 0, 7))));
+      Set (V (preg rd 16 23), Lval( V (P (tmpreg, 8, 15))));
+      Set (V (preg rd 8 15), Lval( V (P (tmpreg, 16, 23))));
+      Set (V (preg rd 0 7), Lval( V (P (tmpreg, 24, 31))));
+      Directive (Remove tmpreg);
+    ]
 
   let decode_thumb_misc s isn =
     match (isn lsr 6) land 0x3f with
@@ -1130,41 +1246,50 @@ struct
        else (* Change Processor State CPS *)
          notimplemented_thumb s isn "CPS"
     | 0b000000 | 0b000001 -> (* Add Immediate to SP ADD (SP plus immediate) *)
-       notimplemented_thumb s isn "ADD on SP"
+       let imm7 = isn land 0x7f in
+       op_add sp 13 (const (imm7 lsl 2) 32) |> mark_couple
     | 0b000010 | 0b000011 -> (* Subtract Immediate from SP SUB (SP minus immediate) *)
        let imm7 = isn land 0x7f in
        op_sub sp 13 (const (imm7 lsl 2) 32) |> mark_couple
     | 0b000100 | 0b000101 | 0b000110 | 0b000111 -> (* Compare and Branch on Zero CBNZ, CBZ *)
-       notimplemented_thumb s isn "CBZ/CBNZ (0)"
+      decode_thumb_cbz_cbnz s isn EQ
     | 0b001000 -> (* Signed Extend Halfword SXTH *)
        notimplemented_thumb s isn "SXTH"
     | 0b001001 -> (* Signed Extend Byte SXTB *)
        notimplemented_thumb s isn "SXTB"
     | 0b001010 -> (* Unsigned Extend Halfword UXTH *)
-       notimplemented_thumb s isn "UXTH"
+      let rd = isn land 7 in
+      let rm = isn lsr 3 land 7 in
+      [
+        Set ( (V (treg rd)), UnOp( ZeroExt 32, Lval (V (preg rm 0 15))))
+      ] |> mark_as_isn
+       (* notimplemented_thumb s isn "UXTH" *)
     | 0b001011 -> (* Unsigned Extend Byte UXTB *)
        notimplemented_thumb s isn "UXTB"
     | 0b001100 | 0b001101 | 0b001110 | 0b001111 -> (* Compare and Branch on Zero CBNZ, CBZ *)
-       notimplemented_thumb s isn "CBNZ/CBZ (1)"
+      decode_thumb_cbz_cbnz s isn EQ
     | 0b010000 | 0b010001 | 0b010010 | 0b010011 | 0b010100 | 0b010101 | 0b010110 | 0b010111 -> (* Push Multiple Registers PUSH *)
        thumb_push s isn
     | 0b100100 | 0b100101 | 0b100110 | 0b100111 -> (* Compare and Branch on Nonzero CBNZ, CBZ *)
-       notimplemented_thumb s isn "CBNZ/CBZ (2)"
+      decode_thumb_cbz_cbnz s isn NEQ
     | 0b101000 -> (* Byte-Reverse Word REV *)
-       notimplemented_thumb s isn "REV"
+       let rd = isn land 7 in
+       let rm = isn lsr 3 land 0x7 in
+       rev s rd rm |> mark_as_isn
+       (* notimplemented_thumb s isn "REV" *)
     | 0b101001 -> (* Byte-Reverse Packed Halfword REV16 *)
        notimplemented_thumb s isn "REV16"
     | 0b101011 -> (* Byte-Reverse Signed Halfword REVSH *)
        notimplemented_thumb s isn "REVSH"
     | 0b101100 | 0b101101 | 0b101110 | 0b101111 -> (* Compare and Branch on Nonzero CBNZ, CBZ *)
-       notimplemented_thumb s isn "CBNZ/CBZ (3)"
+      decode_thumb_cbz_cbnz s isn NEQ
     | 0b110000 | 0b110001 | 0b110010 | 0b110011 | 0b110100 | 0b110101 | 0b110110 | 0b110111 -> (* Pop Multiple Registers POP *)
        thumb_pop s isn
     | 0b111000 | 0b111001 | 0b111010 | 0b111011 -> (* Breakpoint BKPT *)
        notimplemented_thumb s isn "BKPT"
     | 0b111100 | 0b111101 | 0b111110 | 0b111111 -> (* If-Then and hints *)
        decode_thumb_it_hints s isn
-    | _ ->  L.abort (fun p -> p "Unknown thumb misc encoding %04x" isn)
+    | _ -> error_isn s.a isn "Unkown  thumb misc encoding"
 
 
   let thumb_mov_imm _s isn =
@@ -1174,6 +1299,29 @@ struct
       MARK_FLAG (Set (V (T zflag), const (if imm = 0 then 1 else 0) 1)) ;
       MARK_FLAG (Set (V (T nflag), const (imm lsr 31) 1)) ; ]
 
+  let thumb32_mov_imm _s isn isn2 =
+    (* imm = isn<10>:isn2<14-12>:isn2<7-0>*)
+    let imm = ((isn lsr 10 land 1) lsl 11) lor (((isn2 lsr 12) land 7) lsl 8) lor (isn2 land 0xff) in
+    (* In some case MOVT or MOV (T3) imm = isn<3-0>:imm *)
+    let imm = if isn lsr 9 land 1 = 1 then (isn land 0xf) lsl 12 lor imm else imm in
+    let setflags = (isn lsr 4 land 1) = 1 in
+    (* rd = isn2<11-8>*)
+    let rd = isn2 lsr 8 land 0xf in
+    let dest, cst_size =
+      if isn lsr 7 land 1 = 1 then (* MOVT *)
+        (preg rd 16 31), 16
+      else
+        (treg rd), 32
+      in
+    let flags_stmts =
+      if setflags then
+        [
+          MARK_FLAG (Set (V (T zflag), const (if imm = 0 then 1 else 0) 1));
+          MARK_FLAG (Set (V (T nflag), const (imm lsr 31) 1 ));
+        ]
+      else [] in
+    [MARK_ISN (Set (V dest, const imm cst_size));] @ flags_stmts
+
   let thumb_cmp_imm _s isn =
     let rn = (isn lsr 8) land 7 in
     let imm = isn land 0xff in
@@ -1198,7 +1346,7 @@ struct
             op_add (reg rd) rn (const rm_or_imm3 32)
          | 0b11 -> (* Subtract 3-bit immediate SUB (immediate, Thumb) *)
             op_sub (reg rd) rn (const rm_or_imm3 32)
-         | _ -> L.abort (fun p -> p "Unknown encoding %04x" isn)
+         | _ ->  error_isn s.a isn "Unkown encoding"
        end |> mark_couple
     | 0b000 -> (* Logical Shift Left LSL (immediate) *)
        let shift = (isn lsr 6) land 0x1f in
@@ -1236,7 +1384,7 @@ struct
        let rdn = (isn lsr 8) land 7 in
        let imm8 = isn land 0xff in
        op_sub (reg rdn) rdn (const imm8 32) |> mark_couple
-    | _ -> L.abort (fun p -> p "Unknown encoding %04x" isn)
+    | _ -> error_isn s.a isn "Unkown encoding"
 
 
   let thumb_cond_branching _s isn =
@@ -1258,7 +1406,7 @@ struct
   let decode_thumb_branching_svcall s isn =
     match isn lsr 8 land 0xf with
     | 0b1110 -> (* Permanently UNDEFINED *)
-       L.abort (fun p -> p "Thumb16 instruction %04x permanently undefined" isn)
+      error_isn s.a isn "Permanently undefined"
     | 0b1111 -> (* Supervisor Call *)
        notimplemented_thumb s isn "SVC"
     | _ -> (* Conditional branch *)
@@ -1270,31 +1418,49 @@ struct
     let jump_pc = if rd = 15 then [ Jmp (R (Lval (V (T pc)))) ] else [] in
     [ Set (V (treg rd), Lval (V (treg rm))) ] @ jump_pc |> mark_as_isn
 
-  let thumb_bx _s isn =
+  let thumb_bx_blx _s isn =
     let rm = (isn lsr 3) land 0xf in
-    [ Set (V (T tflag), Lval (V (preg rm 0 0))) ;
+    let set_lr =
+      if isn lsr 7 land 1 = 1 then (* BLX *)
+        (* LR = (PC-2)<31:1>:1 *)
+        [Set (V (T lr), BinOp(Or, BinOp(Add, Lval (V (T pc)), const 0xfffffffe 32), const 1 32))]
+      else (* BX *)
+        []
+    in
+    set_lr @ [
+     Set (V (T tflag), Lval (V (preg rm 0 0))) ;
       Set (V (T pc), BinOp (And, Lval (V (treg rm)), const 0xfffffffe 32)) ;
       Jmp (R (Lval (V (T pc)))) ] |> mark_as_isn
 
+
   let decode_thumb_special_data_branch_exch s isn =
     match (isn lsr 6) land 0xf with
-    | 0b0000 -> (* Add Low Registers ADD (register)*)
-       notimplemented_thumb s isn "ADD (low reg)"
-    | 0b0001 | 0b0010 | 0b0011 -> (* Add High Registers ADD (register) *)
-       let rd = ((isn lsr 4) land 0x8) lor (isn land 0x7) in
-       let rm = (isn lsr 3) land 0xf in
-       op_add (reg rd) rm (Lval (V (treg rd))) |> mark_couple
+    | 0b0000 | 0b0001 | 0b0010 | 0b0011 -> (* ADD *)
+      let rm = isn lsr 3 land 0xf in
+      let rd = ((isn lsr 7 land 1) lsl 3) lor (isn land 7) in
+      let stmts, _ = op_add (reg rd) rm (Lval (V (treg rd))) in
+      stmts |> mark_as_isn
     | 0b0101 | 0b0110 | 0b0111 -> (* Compare High Registers CMP (register) *)
-       notimplemented_thumb s isn "CMP (high reg)"
+      let rn = (((isn lsr 7) land 1) lsl 3) lor (isn land 7) in
+      let rm = (isn lsr 3) land 0xf in
+      let shift_t, shift_n = decode_imm_shift 0 0 in
+      let shifted = decode_shift rm shift_t shift_n (Lval (V (T cflag))) in
+      let tmpreg = Register.make (Register.fresh_name ()) 32 in
+      let opstmts, flagstmts = op_add tmpreg rn (UnOp(Not, shifted)) in
+      mark_as_isn (opstmts @ flagstmts @ [ Directive (Remove tmpreg) ])
+       (* notimplemented_thumb s isn "CMP (high reg)" *)
     | 0b1000 -> (* Move Low Registers MOV (register) *)
-       notimplemented_thumb s isn "MOV (low reg)"
+      let rd = ((isn land 0x80) lsr 4) lor (isn land 0x7) in
+      let rm = (isn lsr 3) land 0xf in
+      [MARK_ISN (Set (V (treg rd), Lval (V (treg rm))))]
+       (* notimplemented_thumb s isn "MOV (low reg)" *)
     | 0b1001 | 0b1010 | 0b1011 -> (* Move High Registers MOV (register) *)
        thumb_mov_high_reg s isn
     | 0b1100 | 0b1101 -> (* Branch and Exchange BX *)
-       thumb_bx s isn
+      thumb_bx_blx s isn
     | 0b1110 | 0b1111 -> (* Branch with Link and Exchange BLX *)
-       notimplemented_thumb s isn "BLX"
-    | _ -> L.abort (fun p -> p "Unknown or unpredictable instruction %04x" isn)
+      thumb_bx_blx s isn
+    | _ -> error_isn s.a isn "Unknown or unpredictable instruction"
 
   let thumb_mul _s isn =
     let rn = (isn lsr 3) land 7 in
@@ -1338,8 +1504,10 @@ struct
        op_rsb (reg op0) op1 (const 0 32) |> mark_couple
     | 0b1010 -> (* CMP Compare Registers *)
        let tmpreg = Register.make (Register.fresh_name ()) 32 in
-       let opstmts,flagstmts = op_sub tmpreg op0 (Lval (V (treg op1))) in
+       let opstmts,flagstmts = op_add tmpreg op0 (UnOp(Not, Lval (V (treg op1)))) in
+       (* let opstmts,flagstmts = op_sub tmpreg op0 (Lval (V (treg op1))) in *)
        mark_as_isn (opstmts @ flagstmts @ [ Directive (Remove tmpreg) ])
+
     | 0b1011 -> (* CMN Compare Negative *)
        let tmpreg = Register.make (Register.fresh_name ()) 32 in
        let opstmts,flagstmts = op_add tmpreg op0 (Lval (V (treg op1))) in
@@ -1352,7 +1520,7 @@ struct
        op_bic (reg op0) op0 (Lval (V (treg op1))) |> mark_couple
     | 0b1111 -> (* MVN Bitwise NOT *)
        op_mvn (reg op0) (Lval (V (treg op1))) |> mark_couple
-    | _ -> L.abort (fun p -> p "internal error")
+    | _ -> error_isn s.a isn "Internal error"
 
   let thumb_ldr _s isn =
     let rt = (isn lsr 8) land 7 in
@@ -1364,7 +1532,7 @@ struct
                            const (imm lsl 2) 32),
                     32))) ] |> mark_as_isn
 
-  let decode_thumb_load_store_single_data_item _s isn =
+  let decode_thumb_load_store_single_data_item s isn =
     let stmts =
       match (isn lsr 12) land 0xf with
       | 0b0101 ->
@@ -1390,7 +1558,7 @@ struct
               [ Set (V (treg rt), UnOp( ZeroExt 32, Lval (M (ofs, 8)))) ]
            | 0b111 -> (* LDRSH (register) Load Register Signed Halfword *)
               [ Set (V (treg rt), UnOp( SignExt 32, Lval (M (ofs, 16)))) ]
-           | _ -> L.abort (fun p -> p "Internal error")
+           | _ -> error_isn s.a isn "Internal error (2)"
          end
       | 0b1001 ->
          let imm8 = isn land 0xff in
@@ -1400,11 +1568,11 @@ struct
            [ Set (M (ofs, 32), Lval (V (treg rt))) ]
          else (* LDR (immediate) Load Register SP relative *)
            [ Set (V (treg rt), Lval (M (ofs, 32))) ]
-      | _ -> 
+      | _ ->
          let rn = (isn lsr 3) land 7 in
          let rt = isn land 7 in
          let imm5 = (isn lsr 6) land 0x1f in
-         let ofs sz = BinOp (Add, Lval (V (treg rn)), const (imm5 lsl sz) 32) in 
+         let ofs sz = BinOp (Add, Lval (V (treg rn)), const (imm5 lsl sz) 32) in
          (* imm5 is shifted by 0 for byte access, 1 for halfword access, 2 for word access *)
          begin
            match isn lsr 11 land 0x1f with
@@ -1420,45 +1588,124 @@ struct
               [ Set (M (ofs 1, 16), Lval (V (preg rt 0 15))) ]
            | 0b10001 -> (* LDRH (immediate) Load Register Halfword *)
               [ Set (V (treg rt), UnOp(ZeroExt 32, Lval (M (ofs 1, 16)))) ]
-           | _ -> L.abort (fun p -> p "Internal error")
+           | _ -> error_isn s.a isn "Internal error (3)"
          end in
     mark_as_isn stmts
 
 
+  (* THUMB 32 utilities *)
+  let decode_thumb32_imm12 imm12 =
+    if (imm12 lsr 10) = 0 then
+      let imm8 = imm12 land 0xff in
+      match (imm12 lsr 8) land 3 with
+        | 0b00 -> const imm12 32
+        | 0b01 -> const ((imm8 lsl 16) lor imm8) 32 (* 00000000 : imm8 : 00000000 : imm8  *)
+        | 0b10 -> const ((imm8 lsl 24) lor (imm8 lsl 8)) 32 (* imm8 : 00000000 : imm8 : 00000000 *)
+        | 0b11 -> const ((imm8 lsl 24) lor (imm8 lsl 16) lor (imm8 lsl 8) lor imm8) 32
+        | _ -> L.abort(fun p -> p "Unreachable")
+    else
+      (* ror_stmt *)
+      let unrotated_value = (1 lsl 7) lor (imm12 land 0x3f) in
+      ror_stmt (const unrotated_value 32) (imm12 lsr 7)
+
+  let decode_thumb32_cmp_stmts rn value =
+    let tmpreg = Register.make (Register.fresh_name ()) 33 in
+    [
+      MARK_ISN(Set( V (T tmpreg), BinOp(Add, to33bits (Lval (V (treg rn))),
+                                      to33bits(BinOp(Add, value,
+                                                    const 1 32))))) ;
+      MARK_FLAG( zflag_update_exp (Lval (V (P (tmpreg, 0, 31)))));
+      MARK_FLAG( nflag_update_exp tmpreg );
+      MARK_FLAG(vflag_update_exp  (Lval (V (treg rn))) value (Lval (V (P (tmpreg, 0, 31)))));
+      MARK_ISN(Set (V (T cflag), Lval (V (P (tmpreg, 32, 32)))));
+      MARK_ISN(Directive (Remove tmpreg))
+    ]
+
+
+  let decode_thumb32_cmp_imm _s isn isn2 =
+    let rn = isn land 0xf in
+    (* imm = isn<10>:isn2<14-12>:isn2<7-0> *)
+    let imm = (((isn lsr 10) land 1) lsl 11) lor (((isn2 lsr 12) land 7) lsl 8) lor (isn2 land 0xff) in
+    let decoded_imm = decode_thumb32_imm12 imm in
+    decode_thumb32_cmp_stmts rn (UnOp(Not, decoded_imm))
+
+  let decode_thumb32_cmp_reg _s isn isn2 =
+    (* for CMP or CMN reg *)
+    let rm = isn2 land 0xf in
+    let rn = isn land 0xf in
+    let shift_type = isn2 lsr 4 land 3 in
+    let shift_amount = ((isn2 lsr 12 land 0x7) lsl 2) lor (isn2 lsr 6) land 3 in
+    let shift_t, shift_n = decode_imm_shift shift_type shift_amount in
+    let shift = decode_shift rm shift_t shift_n (Lval (V (T cflag))) in
+    let shifted =
+      if isn lsr 5 land 1 = 1 (* CMP *) then
+        UnOp(Not, shift)
+      else (* CMN *)
+        shift
+      in
+    decode_thumb32_cmp_stmts rn shifted
+
   let decode_thumb32_data_proc_shift_reg s isn isn2 =
     let op = (isn lsr 5) land 0xf in
     let rn = isn land 0xf in
+    let rm = isn2 land 0xf in
+    let shift_type = (isn2 lsr 4) land 3 in
+    (* imm5 : <isn2:14-12>:<isn2:7-6> *)
+    let shift_amount = (((isn2 lsr 11) land 7) lsl 2) land ((isn2 lsr 5) land 3) in
+    let shift_t, shift_n = decode_imm_shift shift_type shift_amount in
+    let shifted, carry_out = decode_shift_carry rm shift_t shift_n (Lval (V (T cflag))) in
+    let rd = (isn2 lsr 0x8) land 0xf in
     let tst = (isn lsr 4) land 1 in
     match op with
     | 0b0000 ->
-       if tst = 0 then (* Bitwise AND AND (register) *)
-         notimplemented_thumb s isn "AND (register)"
-       else (* TST (register) *)
-         notimplemented_thumb s isn "TST (register)"
+      if tst = 1 && rd = 15 then (* TST (register) *)
+        notimplemented_thumb s isn "TST (register)"
+      else ( (* AND (register) *)
+        let stmts, flags = op_and (reg rd) rn shifted in
+        let flags = if tst = 1 then (mark_as_flag flags) @ [ MARK_FLAG(set_cflag_from_carry_out carry_out) ] else [] in
+        (mark_as_isn stmts) @ flags
+         (* notimplemented_thumb s isn "AND (register)" *)
+      )
     | 0b0001 -> (* Bitwise Bit Clear BIC (register) *)
-       notimplemented_thumb s isn "BIC (register)"
+      let stmts, flags = op_bic (reg rd) rn shifted in
+      let flags = if tst = 1 then (mark_as_flag flags) @ [ MARK_FLAG(set_cflag_from_carry_out carry_out)] else [] in
+      (mark_as_isn stmts) @ flags
+
     | 0b0010 ->
        if rn = 0xf then (* Move MOV (register) *)
-         notimplemented_thumb s isn "ORR (register)"
+         notimplemented_thumb s isn "MOV (from ORR) (register)"
        else (* Bitwise OR ORR (register) *)
-         notimplemented_thumb s isn "ORR (register)"
+        let result = BinOp(Or, Lval (V (treg rn)), shifted) in
+        let stmts = [ Set (V (treg rd), result) ] in
+        if tst = 0 then
+          mark_as_isn stmts
+        else
+          (mark_as_isn stmts) @ [
+            MARK_FLAG(zflag_update_exp result) ;
+            MARK_FLAG(nflag_update_exp (reg rd)) ;
+            MARK_FLAG(set_cflag_from_carry_out carry_out)
+          ]
     | 0b0011 ->
        if rn = 0xf then (* Bitwise NOT MVN (register) *)
          notimplemented_thumb s isn "MVN (register)"
        else (* Bitwise OR NOT ORN (register) *)
          notimplemented_thumb s isn "ORN (register)"
     | 0b0100 ->
-       if tst = 0 then (* Bitwise Exclusive OR EOR (register) *)
-         notimplemented_thumb s isn "EOR (register)"
-       else (* Test Equivalence TEQ (register) *)
-         notimplemented_thumb s isn "TEQ (register)"
+      if tst = 1 && rd = 15 then
+        notimplemented_thumb s isn "TEQ (register)"
+      else (* EOR (register) *)
+        let stmts, flags = op_eor (reg rd) rn shifted in
+        let flags = if tst = 1 then (mark_as_flag flags) @ [MARK_FLAG(set_cflag_from_carry_out carry_out)] else [] in
+        (mark_as_isn stmts) @ flags
+
     | 0b0110 -> (* Pack Halfword PKH *)
        notimplemented_thumb s isn "PKH"
     | 0b1000 ->
        if tst = 0 then (* Add ADD (register) *)
-         notimplemented_thumb s isn "ADD (register)"
+        [Set (V (treg rd), BinOp(Add, Lval (V (treg rn)), shifted)) ] |> mark_as_isn
+         (* notimplemented_thumb s isn "ADD (register)" *)
        else (* Compare Negative CMN (register) *)
-         notimplemented_thumb s isn "CMN (register)"
+         decode_thumb32_cmp_reg s isn isn2
     | 0b1010 -> (* Add with Carry ADC (register) *)
        notimplemented_thumb s isn "ADC (register)"
     | 0b1011 -> (* Subtract with Carry SBC (register) *)
@@ -1467,12 +1714,10 @@ struct
        if tst = 0 then (* Subtract SUB (register) *)
          notimplemented_thumb s isn "SUB (register)"
        else (* Compare CMP (register) *)
-         notimplemented_thumb s isn "CMP (register)"
+         decode_thumb32_cmp_reg s isn isn2
     | 0b1110 -> (* Reverse Subtract RSB (register) *)
        notimplemented_thumb s isn "RSB (register)"
-    | _ -> L.abort (fun p -> p "Unexpected thumb32 encoding %04x %04x" isn isn2)
-
-
+    | _ -> error_isn s.a isn ~isn2:isn2 "Unexpected thumb encoding (2)"
 
   let thumb32_bl_blx_immediate _s isn isn2 =
     let immh = isn land 0x3ff in
@@ -1517,16 +1762,88 @@ struct
               if op1 = 0 then
                 notimplemented_thumb s isn "SMC"
               else
-                L.abort (fun p -> p "permanently undefined thumb32 instruction %04x %04x" isn isn2)
-           | _ -> L.abort (fun p -> p "unexpected thumb32 encoding %04x %04x" isn isn2)
-         else (* Conditional branch *)
-           notimplemented_thumb s isn "conditional branch"
+                error_isn s.a isn ~isn2:isn2 "permanently undefined thumb32 instruction"
+           | _ -> error_isn s.a isn ~isn2:isn2 "Unexpected thumb encoding (3)"
+         else (* Conditional branch *) (
+           let cond = (isn lsr 6) land 0xf in
+           let bit_s = (isn lsr 10) land 1 in
+           let imm = (bit_s lsl 20) lor (((isn2 lsr 11) land 1) lsl 19) lor (((isn2 lsr 13) land 1) lsl 18) lor ((isn land 0x3f) lsl 12) lor ((isn2 land 0x7ff) lsl 1) in
+           let s_imm = sconst imm 21 32 in
+            let branching = [
+              Set (V (T pc),
+                  BinOp(Add, Lval (V (T pc)), s_imm)) ;
+                  Jmp (R (Lval (V (T pc))))
+            ] in
+            [ If (asm_cond cond, branching, []) ] |> mark_as_isn
+         )
        end
-    | 0b001 | 0b011 -> notimplemented_thumb s isn "B"
+    | 0b001 | 0b011 -> (* B - T4 *)
+       let s_bit = isn lsr 10 land 1 in
+       let i1 = (((isn2 lsr 13) land 1) lxor s_bit) lxor 1 in (* i1 = NOT (<isn2:13> xor <isn:10>) *)
+       let i2 = (((isn2 lsr 11) land 1) lxor s_bit) lxor 1 in
+       (* imm : <isn:10>:<i1>:<i2>:<isn:9-0>:<isn2:10-0> *)
+       let imm = (s_bit lsl 24) lor (i1 lsl 23) lor (i2 lsl 22) lor ((isn land 0x3ff) lsl 12) lor ((isn2 land 0x7ff) lsl 1)  in
+       let s_imm = sconst imm 25 32 in
+       [ Set(V (T pc), BinOp(Add, Lval (V (T pc)), s_imm));
+         Jmp (R (Lval (V (T pc))))
+       ] |> mark_as_isn
+
     | 0b100 | 0b110 | 0b101 | 0b111 -> (* BL, BLX *)
        thumb32_bl_blx_immediate s isn isn2
-    | _ -> L.abort (fun p -> p "unexpected thumb32 encoding %04x %04x" isn isn2)
+    | _ ->  error_isn s.a isn ~isn2:isn2 "Unexpected thumb encoding (4)"
+
+  let decode_thumb32_multiple_store _ _ ins2 =
+    (* TODO(dm) TEST ME: http://class.ece.iastate.edu/cpre288/resources/docs/Thumb-2SupplementReferenceManual.pdf *)
+    let reglist = (ins2 land 0x4000) lor (ins2 land 0xfff) in (* registers: '0':M:'0':reg_list *)
+    let stmts = ref [] in
+    let bitcount = ref 0 in
+    for i = 14 downto 0 do
+      if (reglist lsr i) land 1 = 1 then
+        begin
+          bitcount := !bitcount+4;
+          let stmt = Set (M (BinOp(Sub, Lval (V (T sp)), const !bitcount 32), 32),
+                          Lval (V (treg i))) in
+          stmts := stmt :: (!stmts)
+        end
+    done;
+    (!stmts) @ [ Set (V (T sp), BinOp(Sub, Lval (V (T sp)), const !bitcount 32)) ] |> mark_as_isn
+
+    let decode_thumb32_multiple_load _ _ isn2 = (* TODO(dm) CHECK ME*)
+      let reglist = ((isn2 lsl 7) land 0xc000) lor (isn2 land 0xfff) in (* reglist = bit15(P):bit14(M):0:bit12-0  *)
+      let stmts = ref [] in
+      let bitcount = ref 0 in
+      for i = 0 to 15 do
+        if (reglist lsr i) land 1 = 1 then
+          begin
+            let stmt = Set (V (treg i),
+                            Lval (M (BinOp(Add, Lval (V (T sp)), const !bitcount 32), 32))) in
+            bitcount := !bitcount+4;
+            stmts := stmt :: (!stmts)
+          end
+      done;
+
+      (!stmts) @ [ Set (V (T sp), BinOp(Add, Lval (V (T sp)), const !bitcount 32)) ] |>  mark_as_isn
+
+  let decode_thumb32_add _s isn isn2 =
+    (* Decode ADD (immediate) / ADD (SP) / CMN *)
+    let rn = isn land 0xf in
+    let rd = (isn2 lsr 0x8) land 0xf in
+    let test = ((isn lsr 0x4) land 1) = 1 in
+    (* imm12 = isn<10>:isn2<14-12>:isn2<7-0> *)
+    let imm12 = (((isn lsr 10) land 1) lsl 11) lor (((isn2 lsr 12) land 0x7) lsl 0x8) lor (isn2 land 0xff) in
+    let decoded_imm = decode_thumb32_imm12 imm12 in
+    let stmts, flags = op_add (reg rd) rn decoded_imm in
+    if test then
+      if rd = 15 then (* CMN: discard the results *)
+        flags |> mark_as_isn
+      else
+        stmts @ flags |> mark_as_isn
+    else
+      stmts |> mark_as_isn
 
+  let offset_addr_computation updown_bit src cst =
+    let updown = if updown_bit = 0 then Sub else Add in
+    BinOp(updown, Lval (V (treg src)), cst)
 
   let decode_thumb32 s isn isn2 =
     let op1 = (isn lsr 11) land 3 in
@@ -1534,36 +1851,112 @@ struct
     let op = isn2 lsr 15 in
     match op1 with
     | 0b01 ->
-       if op2 land 0x64 = 0 then (* Load/store multiple *)
-         notimplemented_thumb s isn "thumb32 load/store multible"
+       if op2 land 0x64 = 0 then ((* Load/store multiple *)
+        if op2 land 1 = 1 then
+          decode_thumb32_multiple_load s isn isn2
+        else
+          decode_thumb32_multiple_store s isn isn2
+       )
        else if op2 land 0x64 = 4 then (* Load/store dual, load/store exclusive, table branch *)
-         notimplemented_thumb s isn  "load/store dual/excl, table branch"
+        let rn = isn land 0xf in
+        let rt = (isn2 lsr 12) land 0xf in
+        let rt2 = (isn2 lsr 8) land 0xf in
+        let imm32 = const ((isn2 land 0xff) lsl 2) 32 in
+        let index = ((isn lsr 8) land 1) = 1 in
+        let updown = (isn lsr 7) land 1 in
+        let wback = ((isn lsr 5) land 1) = 1 in
+        let address = if index then offset_addr_computation updown rn imm32 else Lval (V (treg rn)) in
+        let stmts = [
+          Set (M (address, 32), Lval (V (treg rt))) ;
+          Set (M (BinOp(Add, address, const 32 32), 32), Lval (V (treg rt2))) ; (* we set Mem[address+4, 4]*)
+        ] in
+        if wback then
+          stmts @ [ Set(V (treg rn), address) ] |> mark_as_isn
+        else
+          stmts |> mark_as_isn
+         (* notimplemented_thumb s isn  "load/store dual/excl, table branch" *)
        else if op2 land 0x60 = 0x20 then (* Data-processing (shifted register) *)
          decode_thumb32_data_proc_shift_reg s isn isn2
        else if op2 land 0x40 = 40 then (* Coprocessor instructions *)
          notimplemented_thumb s isn "Coprocessor instructions"
-       else L.abort (fun p -> p "Unexpected thumb32 encoding %04x %04x" isn isn2)
+       else  error_isn s.a isn ~isn2:isn2 "Unexpected thumb encoding (5)"
     | 0b10 ->
        if op = 1 then (* Branches and miscellaneous control *)
          decode_thumb32_branches_misc s isn isn2
-       else
-         if op2 land 0x20 = 0 then (* Data-processing (modified immediate) *)
-           notimplemented_thumb s isn "Data-processing (modified immediate)"
-         else (* Data-processing (modified immediate) *)
-           notimplemented_thumb s isn "Data-processing (plain binary immediate)"
+       else (
+        let op2 = op2 lsr 1 in
+        match op2 with
+        | 0b011100 -> notimplemented_thumb s isn "MSR (register)"
+        | 0b011111 -> notimplemented_thumb s isn "MRS"
+        | 0b010110|0b110110 -> thumb32_mov_imm s isn isn2 (* MOVT *)
+        | 0b010010|0b110010|0b000010|0b100010 -> thumb32_mov_imm s isn isn2 (* MOV (immediate) *)
+        | 0b000100|0b100100 -> notimplemented_thumb s isn "EOR (immediate)"
+        | 0b011101 -> notimplemented_thumb s isn "DSB/DMB/DBG/CPS/CLREX/ISB"
+        | 0b001101|0b101101 ->
+          decode_thumb32_cmp_imm s isn isn2 (* CMP.W for imm *)
+        | 0b001000|0b101000 -> decode_thumb32_add s isn isn2 (*CMN / ADD(SP+) / ADD(immediate) *)
+        | 0b000001|0b100001 -> notimplemented_thumb s isn "BIC"
+        | 0b011011 -> notimplemented_thumb s isn "BFI/BFC"
+        | 0b000000|0b100000 -> notimplemented_thumb s isn "AND (immediate)"
+        | 0b010000|0b110000|0b010101|0b110101 -> decode_thumb32_add s isn isn2 (* CMN/ADD(immediate)/ADD(SP+)*)
+        | 0b001010|0b101010 -> notimplemented_thumb s isn "ADC (immediate)"
+        | _ -> error_isn s.a isn ~isn2:isn2 "Failed to decode the instruction"
+      )
     | 0b11 ->
+      let rn = isn land 0xf in
+      let rt = (isn2 lsr 12) in
        if op2 land 0x71 = 0 then (* Store single data item *)
-         notimplemented_thumb s isn "Store single data item"
+        let imm12 = (isn2 land 0xfff) in
+        let address = BinOp(Add, Lval (V (treg rn)), const imm12 32) in
+        [
+          Set (M (address, 8), Lval (V (preg rt 0 7)))
+        ] |> mark_as_isn
+         (* notimplemented_thumb s isn "Store single data item" *)
+
+        else if op2 = 0x21 then (* UXTAH *)
+          let rm = isn2 land 0xf in
+          let rd = isn2 lsr 8 land 0xf in
+          let rotate = (isn2 lsr 4 land 3) lsl 3 in
+          let rotated =
+            if rotate < 24 then
+              Lval (V (preg rm rotate (rotate+15)))
+            else
+              BinOp (Or,
+                     UnOp (ZeroExt 16, Lval (V (preg rm rotate (rotate+7)))),
+                     BinOp (Shl, UnOp (ZeroExt 16, Lval (V (preg rm 0 7))) , const 8 16))
+          in [ Set (V (treg rd),
+                    (UnOp (ZeroExt 32, rotated ))) ] |> mark_as_isn
+
        else if op2 land 0x71 = 0x10 then (* Advanced SIMD element or structure load/store *)
          notimplemented_thumb s isn "Advanced SIMD element or structure load/store"
-       else if op2 land 0x67 = 1 then (* Load byte, memory hints *)
-         notimplemented_thumb s isn "Load byte, memory hints"
+
+       else if op2 land 0x6f = 9 then (* Load byte, memory hints (only T2) *)
+        let imm12 = isn2 land 0xfff in
+
+        let address = BinOp(Add, Lval (V (treg rn)), const imm12 32) in
+        [ Set (V (treg rt), UnOp(ZeroExt 32, Lval(M (address, 8)))) ] |> mark_as_isn
+
        else if op2 land 0x67 = 3 then (* Load halfword, memory hints *)
-         notimplemented_thumb s isn "Load halfword, memory hints"
-       else if op2 land 0x67 = 5 then (* Load word *)
-         notimplemented_thumb s isn "Load word"
+        let rn = isn land 0xf in
+        let rt = isn2 lsr 12 land 0xf in
+        let rm = isn2 land 0xf in
+        let shift_n = isn2 lsr 4 land 3 in
+        let shifted, _ = lsl_c rm shift_n in
+        let address = BinOp(Add, Lval (V (treg rn)), shifted) in
+        [
+          Set(V (treg rt), UnOp(ZeroExt 32, Lval (M (address, 16))))
+        ] |> mark_as_isn
+
+       else if op2 land 0x67 = 5 || op2 land 0x67 = 13 then (* Load word *)
+        let imm12 = isn2 land 0xfff in
+        let u = (isn lsr 7) land 1 in
+        let op = if u = 1 then Add else Sub in
+        let address = BinOp(op, Lval (V (treg rn)), const imm12 32) in
+        [ Set (V (treg rt), Lval (M (address, 32))) ] |> mark_as_isn
+
        else if op2 land 0x67 = 7 then
-         L.abort (fun p -> p "undefined Thumb32 instruction")
+        error_isn s.a isn "Undefined thumb instruction"
+
        else if op2 land 0x70 = 0x20 then (* Data-processing (register) *)
          notimplemented_thumb s isn "Data-processing (register)"
        else if op2 land 0x78 = 0x30 then (* Multiply, multiply accumulate, and absolute difference *)
@@ -1572,8 +1965,18 @@ struct
          notimplemented_thumb s isn "Long multiply, long multiply accumulate, and divide"
        else if op2 land 0x40 = 0x40 then (* Coprocessor instructions *)
          notimplemented_thumb s isn "Coprocessor instructions"
-       else L.abort (fun p -> p "Unexpected thumb32 encoding %04x %04x" isn isn2)
-    | _ -> L.abort (fun p -> p "Unexpected thumb32 encoding")
+
+       else if op2 = 1 then (* LDRB (register) *)
+        let rm = isn2 land 0xf in
+        let _, shift_n = decode_imm_shift 00 (isn2 lsr 4 land 3) in
+        let shifted, _ = lsl_c rm shift_n in
+        let address = BinOp(Add, Lval (V (treg rn)), shifted) in (* Shift left *)
+        [
+          Set (V (treg rt), (UnOp(ZeroExt 32, Lval (M (address, 8)))))
+        ] |> mark_as_isn
+        (* notimplemented_thumb s isn "LDRB (register)" *)
+       else  error_isn s.a isn ~isn2:isn2 "Unexpected thumb encoding (6)"
+    | _ ->  error_isn s.a isn ~isn2:isn2 "Unexpected thumb encoding (7)"
 
   let thumb_generate_pc_relative _s isn =
     let rd = (isn lsr 8) land 7 in
@@ -1629,17 +2032,18 @@ struct
              | 0b010 | 0b011 | 0b100 -> (* Load/store single data item *)
                 (* 0b0100 does not belong here but is taken care of before*)
                 decode_thumb_load_store_single_data_item s instruction
-             | _ -> L.abort (fun p -> p "Unknown thumb encoding %04x" instruction)
+             | _ ->  error_isn s.a instruction "Unexpected thumb encoding (1)"
            end in
     (* pc is 4 bytes ahead in thumb mode because of pre-fetching. *)
     let current_pc = Const (Word.of_int (Z.add (Address.to_int s.a) (Z.of_int 4)) 32) in
     let filtered_stmts =
-      match s.itstate with
-      | None -> L.abort (fun p -> p "Could not obtain a concrete ITSTATE value. Decoding not supported yet in this case")
-      | Some v ->
-         if (v land 0xf) = 0
-         then remove_marks marked_stmts
-         else let next_itstate = if v land 7 = 0 then 0 else (v land 0xf0) lor ((v lsl 1) land 0xf) in
+      let v = match s.itstate with
+        | None -> 0
+        | Some v -> v
+      in if (v land 0xf) = 0 then
+        remove_marks marked_stmts
+      else
+        let next_itstate = if v land 7 = 0 then 0 else (v land 0xf0) lor ((v lsl 1) land 0xf) in
               (wrap_cc (v lsr 4) (remove_marks_keep_isn marked_stmts)) @ [ Set (V (T itstate), const next_itstate 8)] in
     return s instruction (Set( V (T pc), current_pc) :: filtered_stmts)
 
@@ -1666,6 +2070,13 @@ struct
       let v', ip' = decode s in
       Some (v', ip', ())
     with
+      | Exceptions.Failed_decoding (msg, isn) -> (
+        L.debug (fun p -> p "Failed-decoding: %s" msg);
+        let isn_size = if s.thumbmode then 4 else 8 in
+        let current_pc = Const (Word.of_int (Z.add (Address.to_int s.a) (Z.of_int isn_size)) 32) in
+        let v', ip' = (return s isn ([(Set (V (T pc), current_pc))])) in
+        Some (v', ip', ())
+      )
       | Exceptions.Error _ as e -> raise e
       | _  -> (*end of buffer *) None
 
diff --git a/ocaml/src/disassembly/armv7Imports.ml b/ocaml/src/disassembly/armv7Imports.ml
index ee221a0c..1425ef9e 100644
--- a/ocaml/src/disassembly/armv7Imports.ml
+++ b/ocaml/src/disassembly/armv7Imports.ml
@@ -46,9 +46,9 @@ struct
     | Config.AAPCS -> aapcs_calling_convention
     | c -> L.abort (fun p -> p "Calling convention [%s] not supported for arm v7 architecture"
                                (Config.call_conv_to_string c))
-    
+
   let get_callconv () = get_local_callconv !Config.call_conv
-                      
+
   let typing_rule_stmts_from_name name =
     try
       let _rule = Hashtbl.find Config.typing_rules name in
@@ -101,7 +101,7 @@ struct
   (** check if fdesc (import description) or a (address) should be skipped
    *  raise Not_found if not
    *  else
-   *    return either a 
+   *    return either a
    *      - *patched* fdesc (stub replaced with 'Skip')
    *      - new minimal fdesc to Skip
    * *)
@@ -128,7 +128,7 @@ struct
            }
          else
            raise Not_found
-    
+
   let init () =
     Stubs.init ();
     init_imports ()
diff --git a/ocaml/src/disassembly/armv8A.ml b/ocaml/src/disassembly/armv8A.ml
index 67b1e6f0..d6e30a42 100644
--- a/ocaml/src/disassembly/armv8A.ml
+++ b/ocaml/src/disassembly/armv8A.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2019 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -162,7 +162,7 @@ struct
       P (reg_from_num n, 0, 31)
 
   module Cfa = Cfa.Make(Domain)
-               
+
   module Imports = Armv8aImports.Make(Domain)(Stubs)
 
   type state = {
@@ -174,7 +174,18 @@ struct
 
   (* fatal error reporting *)
   let error a msg =
-    L.abort (fun p -> p "at %s: %s" (Address.to_string a) msg)
+    L.error (fun p -> p "at %s: %s" (Address.to_string a) msg);
+    raise (Exceptions.Failed_decoding ((Printf.sprintf "ERROR: %s" (Address.to_string a)), 0))
+
+  let error_isn (a: Address.t) (isn: int) ?(isn2) (msg: string) =
+    let isn = match isn2 with None -> isn | Some value -> (isn lsl 16 lor value) in
+    L.error (fun p -> p "at %s: isn=%08x %s" (Address.to_string a) isn msg);
+    raise (Exceptions.Failed_decoding ((Printf.sprintf "ERROR_ISN: %d" isn), isn))
+
+  let notimplemented (s: state) (isn: int) (mnemo: string) =
+    L.error (fun p -> p "at %s: %s (%08x): ARMV8 instruction not implemented yet"
+                                                  (Address.to_string s.a) mnemo isn);
+    raise (Exceptions.Failed_decoding ((Printf.sprintf "ARMV8: %s" mnemo), isn))
 
   let string_to_char_list str =
     let len = String.length str in
@@ -258,7 +269,7 @@ struct
     let res = BinOp (Or, high, low) in
     res
 
-  let get_shifted_reg sz insn reg amount =
+  let get_shifted_reg (s: state) (sz: int) (insn: int) (reg: Asm.exp) (amount: int) =
     if amount = 0 then
       reg
     else
@@ -266,9 +277,9 @@ struct
       match shift with
       | 0b00 (* LSL *) -> BinOp(Shl, reg, const amount sz)
       | 0b01 (* LSR *) -> BinOp(Shr, reg, const amount sz)
-      | 0b10 (* ASR XXX *) -> L.abort (fun p->p "shifted reg with ASR not implemented yet");
+      | 0b10 (* ASR XXX *) -> error_isn s.a insn "shifted reg with ASR not implemented yet"
       | 0b11 (* ROR *) -> ror sz reg (const amount sz)
-      | _ -> L.abort (fun p->p "Invalid value for shift")
+      | _ -> error_isn s.a insn "Invalid value for shift"
 
   (* 32 bits ops zero the top 32 bits, this helper does it if needed *)
   let sf_zero_rd rd_v sf s_b =
@@ -418,7 +429,7 @@ struct
     let rd, post = get_Rd_lv rd_v sf_v in
     let rn = get_reg_exp rn_v sf_v in
     let rm = get_reg_exp rm_v sf_v in
-    let shifted_rm =  get_shifted_reg sz insn rm imm6_v in
+    let shifted_rm =  get_shifted_reg s sz insn rm imm6_v in
     (add_sub_core sz rd rn op_v shifted_rm s_b @ sf_zero_rd rd_v sf_v s_b) @ post
 
   (* AND / ORR / EOR / ANDS (32/64) core *)
@@ -459,7 +470,7 @@ struct
     let rd, post = get_Rd_lv ~use_sp:(not flags) rd_v sf_v in
     let rn = get_reg_exp rn_v sf_v in
     let rm = get_reg_exp rm_v sf_v in
-    let shifted_rm = get_shifted_reg sz insn rm imm6_v in
+    let shifted_rm = get_shifted_reg s sz insn rm imm6_v in
     let shifted_rm' = if n_v = 1 then UnOp(Not, shifted_rm) else shifted_rm in
     logic_core sz rd rn opc_v shifted_rm' flags @ sf_zero_rd rd_v sf_v (not flags) @ post
 
@@ -508,7 +519,7 @@ BFM <31:31:sf:F:0,30:29:opc:F:01,28:23:_:F:100110,22:22:N:F:0,21:16:immr:F:xxxxx
 SBFM <31:31:sf:F:0,30:29:opc:F:00,28:23:_:F:100110,22:22:N:F:0,21:16:immr:F:xxxxxx,15:10:imms:F:xxxxxx,9:5:Rn:F:xxxxx,4:0:Rd:F:xxxxx> Signed Bitfield Move
 UBFM <31:31:sf:F:0,30:29:opc:F:10,28:23:_:F:100110,22:22:N:F:0,21:16:immr:F:xxxxxx,15:10:imms:F:xxxxxx,9:5:Rn:F:xxxxx,4:0:Rd:F:xxxxx> Unsigned Bitfield Move
 *)
-  let bitfield insn =
+  let bitfield (s: state) (insn: int) =
     let%decode insn' = insn "31:31:sf:F:0,30:29:opc:F:10,28:23:_:F:100110,22:22:N:F:0,21:16:immr:F:xxxxxx,15:10:imms:F:xxxxxx,9:5:Rn:F:xxxxx,4:0:Rd:F:xxxxx" in
     let sz = sf2sz sf_v in
     let wmask, tmask = decode_bitmasks sz n_v imms_v immr_v in
@@ -532,7 +543,7 @@ UBFM <31:31:sf:F:0,30:29:opc:F:10,28:23:_:F:100110,22:22:N:F:0,21:16:immr:F:xxxx
           (* (top AND NOT(tmask)) OR (bot AND tmask); *)
           [Set(rd, BinOp(Or, BinOp(And, top, UnOp(Not, Const(Word.of_int tmask sz))), BinOp(And, rored, Const(Word.of_int tmask sz))))]
         end
-      | _ -> L.abort (fun p->p "BFM/SBFM not handled yet")
+      | _ -> notimplemented s insn "BFM/SBFM not handled yet"
     in
     res @ sf_zero_rd rd_v sf_v false
 
@@ -558,18 +569,18 @@ UBFM <31:31:sf:F:0,30:29:opc:F:10,28:23:_:F:100110,22:22:N:F:0,21:16:immr:F:xxxx
       | 0b010 | 0b011 -> add_sub_imm s insn sf
       | 0b100         -> logic_imm s insn
       | 0b101 -> mov_wide s insn
-      | 0b110 -> bitfield insn
+      | 0b110 -> bitfield s insn
       | 0b111 -> extr insn
-      | _ -> error s.a (Printf.sprintf "Unknown opcode 0x%x" insn)
+      | _ -> error_isn s.a insn "Unknown opcode"
     in stmts
 
   let data_proc_2src s insn =
     (* XXX *)
-    error s.a (Printf.sprintf "Data processing (2 sources) not decoded yet (0x%x)" insn)
+    notimplemented s insn "Data processing (2 sources) not decoded yet"
 
   let data_proc_1src s insn =
     (* XXX *)
-    error s.a (Printf.sprintf "Data processing (1 source) not decoded yet (0x%x)" insn)
+    notimplemented s insn "Data processing (1 sources) not decoded yet"
 
   (*
 MADD   <31:31:sf:0  30:29:op54:00  28:24:_:11011  23:21:op31:000         20:16:Rm:  15:15:o0:0  14:10:Ra:  9:5:Rn:  4:0:Rd:> Multiply-Add
@@ -585,7 +596,7 @@ UMULH  <31:31:sf:1  30:29:op54:00  28:24:_:11011  23:23:U:1  22:21:_:10  20:16:R
     let%decode insn' = insn "31:31:sf:F:0,30:29:_op54:F:00,28:24:_:F:11011,23:21:op31:F:000,20:16:Rm:F:xxxxx,15:15:o0:F:1,14:10:Ra:F:xxxxx,9:5:Rn:F:xxxxx,4:0:Rd:F:xxxxx" in
     let op = if o0_v = 0 then Add else Sub in
     if sf_v = 0 && (op31_v != 0) then
-      error s.a (Printf.sprintf "invalid instruction 0x%x" insn);
+      error_isn s.a insn "invalid instruction";
     let sz = sf2sz sf_v in
     let tmp = Register.make (Register.fresh_name ()) (sz*2) in
     let u_v = op31_v lsr 2 in
@@ -642,11 +653,11 @@ UMULH  <31:31:sf:1  30:29:op54:00  28:24:_:11011  23:23:U:1  22:21:_:10  20:16:R
         end
       else
         match op2 with
-        | 0 -> error s.a (Printf.sprintf "ADD/SUB with carry not decoded yet (0x%x)" insn)
-        | 2 -> error s.a (Printf.sprintf "cond compare not decoded yet (0x%x)" insn)
-        | 4 -> error s.a (Printf.sprintf "cond select not decoded yet (0x%x)" insn)
+        | 0 -> notimplemented s insn "ADD/SUB with carry"
+        | 2 -> notimplemented s insn "cond compare"
+        | 4 -> notimplemented s insn "cond select"
         | _ when op2 >= 8 && op2 <= 15 -> data_proc_3src s insn
-        | _-> error s.a (Printf.sprintf "invalid opcode (0x%x)" insn)
+        | _-> error_isn s.a insn "invalid opcode"
     end
 
 (*
@@ -663,19 +674,20 @@ STR   <31:30:size:00  29:27:_:111  26:26:V:1  25:24:_:00  23:22:opc:00  21:21:_:
 STR   <31:30:size:10  29:27:_:111  26:26:V:0  25:24:_:00  23:22:opc:00  21:21:_:1  20:16:Rm:  15:13:option:  12:12:S:  11:10:_:10  9:5:Rn:  4:0:Rt:> Store Register (register)
 *)
   (* LDR / STR (register offset) *)
-  let load_store_reg_off insn =
+  let load_store_reg_off (s: state) (insn: int) =
     let%decode insn' = insn "31:30:size:F:10,29:27:_:F:111,26:26:_V:F:0,25:24:_:F:00,23:22:opc:F:00,21:21:_:F:1,20:16:Rm:F:xxxxx,15:13:option:F:xxx,12:12:S:F:x,11:10:_:F:10,9:5:Rn:F:xxxxx,4:0:Rt:F:xxxxx" in
     let mem_sz = match size_v with
       | 0 -> 8
       | 1 -> 16
       | 2 -> 32
       | 3 -> 64
-      | _ -> L.abort (fun p->p "impossible size")
+      | _ -> error_isn s.a insn "impossible size"
     in
     let sf = (size_v land 1) in
     let sz = sf2sz sf in
     let rn = get_reg_lv ~use_sp:true rn_v sf in
     let rt = get_reg_lv rt_v sf in
+    L.info(fun p -> p "Reg are : %s and %s" (string_of_lval rn false) (string_of_lval rt false));
     let shl_amount = if s_v = 1 then size_v else 0 in
     let offset = extend_reg sz rm_v option_v shl_amount in
     let addr = BinOp(Add, Lval rn, offset) in
@@ -707,17 +719,18 @@ STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:00  23:22:opc:00  21:21:_:
 STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:00  23:22:opc:00  21:21:_:0  20:12:imm9:  11:10:_:11  9:5:Rn:  4:0:Rt:> Store Register Halfword (immediate)
 
 *)
-  let load_store_reg_imm insn =
+  let load_store_reg_imm (s: state) (insn: int) =
     let%decode insn' = insn "31:30:size:F:10,29:27:_:F:111,26:26:_V:F:0,25:24:_:F:00,23:22:opc:F:10,21:21:_:F:0,20:12:imm9:F:xxxxxxxxx,11:10:op5:F:01,9:5:Rn:F:xxxxx,4:0:Rt:F:xxxxx" in
     let mem_sz = match size_v with
       | 0 -> 8
       | 1 -> 16
       | 2 -> 32
       | 3 -> 64
-      | _ -> L.abort (fun p->p "impossible size")
+      | _ -> error_isn s.a insn "impossible size"
     in
+    let use_64 = if mem_sz = 3 then 1 else 0 in
     let rn = get_reg_lv ~use_sp:true rn_v 1 in
-    let rt = get_reg_lv rt_v 1 in
+    let rt = get_reg_lv rt_v use_64 in
     let offset = UnOp(SignExt 64, const imm9_v 9) in
     let addr, post = match op5_v with
       (* no index *)
@@ -726,7 +739,7 @@ STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:00  23:22:opc:00  21:21:_:
       | 0b01 -> offset, [Set(rn, BinOp(Add, Lval(rn), offset))]
       (* pre index *)
       | 0b11 -> BinOp(Add, Lval(rn), offset), [Set(rn, BinOp(Add, Lval(rn), offset))]
-      | _ -> L.abort (fun p->p "Impossible value in load_store_pair")
+      | _ -> error_isn s.a insn "Impossible value in load_store_pair"
     in
     if opc_v = 1 then
       (* load *)
@@ -748,14 +761,14 @@ LDRSW <31:30:size:10  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:10  21:10:im
 STRB  <31:30:size:00  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:00  21:10:imm12:  9:5:Rn:  4:0:Rt:> Store Register Byte (immediate)
 STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:00  21:10:imm12:  9:5:Rn:  4:0:Rt:> Store Register Halfword (immediate)
 *)
-  let load_store_reg_uimm insn =
+  let load_store_reg_uimm s insn =
     let%decode insn' = insn "31:30:size:F:01,29:27:_:F:111,26:26:_V:F:0,25:24:_:F:01,23:22:opc:F:00,21:10:imm12:F:xxxxxxxxxxxx,9:5:Rn:F:xxxxx,4:0:Rt:F:xxxxx" in
     let mem_sz = match size_v with
       | 0 -> 8
       | 1 -> 16
       | 2 -> 32
       | 3 -> 64
-      | _ -> L.abort (fun p->p "impossible size")
+      | _ -> error_isn s.a insn "impossible size"
     in
     let sf = (size_v land 1) in
     let sz = sf2sz sf in
@@ -773,7 +786,7 @@ STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:00  21:10:im
       [Set(M(addr, mem_sz), Lval(rt))]
 
   (* STP / STNP / LDP *)
-  let load_store_pair insn op3 =
+  let load_store_pair s insn op3 =
     let%decode insn' = insn "31:30:opc:F:00,29:27:_:F:101,26:26:_V:F:0,25:23:_:F:001,22:22:L:F:1,21:15:imm7:F:xxxxxxx,14:10:Rt2:F:xxxxx,9:5:Rn:F:xxxxx,4:0:Rt:F:xxxxx" in
     let sf = (opc_v lsr 1) land 1 in
     let sz = sf2sz sf in
@@ -788,7 +801,7 @@ STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:00  21:10:im
       | 0b01 ->  Lval(rn), [Set(rn, BinOp(Add, Lval(rn), offset))]
       (* pre index *)
       | 0b11 -> BinOp(Add, Lval(rn), offset), [Set(rn, BinOp(Add, Lval(rn), offset))]
-      | _ -> L.abort (fun p->p "Impossible value in load_store_pair")
+      | _ -> error_isn s.a insn "Impossible value in load_store_pair"
     in
     if l_v = 1 then
       (* load *)
@@ -813,31 +826,31 @@ STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:00  21:10:im
        (op0 = 1 && op1 = 0 && op2 = 1) ||
        (op1 = 0 && op2 = 0 && op3 > 1) ||
        (op1 = 1 && op3 > 1) then
-      error s.a (Printf.sprintf "Unallocated opcode 0x%x" insn);
+      error s.a "Unallocated opcode";
     (* SIMD *)
     if (op0 = 0 && op1 =0 && op2 = 1) then
-      error s.a (Printf.sprintf "SIMD load/store not decoded yet. opcode 0x%x" insn);
+      notimplemented s insn "SIMD load/store";
     if (op1 = 0b10) then
-      load_store_pair insn op3
+      load_store_pair s insn op3
     else begin
       if (op1 = 0b11) then
         begin
           if op3 > 1 then begin
-            load_store_reg_uimm insn
+            load_store_reg_uimm s insn
           end else begin
             if op5 = 0b10 then begin
-              load_store_reg_off insn
+              load_store_reg_off s insn
             end else begin
-              load_store_reg_imm insn
+              load_store_reg_imm s insn
             end
           end
         end
       else
-        error s.a (Printf.sprintf "load/store type not decoded yet. opcode 0x%x" insn);
+        notimplemented s insn "load/store";
     end
 
   (* Return statement matching cond, see ConditionHolds in MRA *)
-  let decode_cond cond =
+  let decode_cond s cond =
     let base_cond = match (cond lsr 1) with
       | 0b000 -> Cmp(EQ, zf_lv, const1 1)
       | 0b001 -> Cmp(EQ, cf_lv, const1 1)
@@ -847,7 +860,7 @@ STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:00  21:10:im
       | 0b101 -> Cmp(EQ, nf_lv, vf_lv)
       | 0b110 -> BBinOp(LogAnd, Cmp(EQ, nf_lv, vf_lv), Cmp(EQ, zf_lv, const0 1))
       | 0b111 -> BConst(true)
-      | _ -> L.abort (fun p->p "Invalid condition")
+      | _ -> error s.a "invalid condition"
     in
     if (cond land 1) = 1 && cond != 15 then
       BUnOp(LogNot, base_cond)
@@ -859,7 +872,7 @@ STRH  <31:30:size:01  29:27:_:111  26:26:V:0  25:24:_:01  23:22:opc:00  21:10:im
     let%decode insn' = insn "31:25:_:F:0101010,24:24:_o1:F:0,23:5:imm19:F:xxxxxxxxxxxxxxxxxxx,4:4:_o0:F:0,3:0:cond:F:xxxx" in
     let offset = imm19_v lsl 2 in
     let signed_offset = sign_extension (Z.of_int offset) 21 64 in
-    let cond_il = decode_cond cond_v in
+    let cond_il = decode_cond s cond_v in
     [If(cond_il, [Jmp(A(Address.add_offset s.a signed_offset))], [Nop])]
 
   (*
@@ -918,6 +931,16 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
          [Jmp(A(Address.add_offset s.a signed_offset))],
          [Nop])]
 
+  let branch_system_register_move (_s: state) (_isn: int) : (Asm.stmt list) =
+    (* Not implemented for the moment but does not fails *)
+    L.info(fun p -> p "branch system register move not implemented");
+    []
+    (* let%decode isn' = isn "31:22:_:F:1101010100,21:21:L:F:x,20:20:_:F:1,19:19:oO:F:x,18:16:op1:F:xxx,15:12:CRn:F:xxxx,11:8:CRm:F:xxxx,7:5:Rt:F:xxx,4:0:Rt:F:xxxxx" in
+    if L_v = 0 (* MSR (register) *) then
+      []
+    else (* MRS *)
+      [] *)
+
   (* Branches, Exception Generating and System instructions *)
   let branch (s: state) (insn: int): (Asm.stmt list) =
     let op0 = (insn lsr 29) land 7 in
@@ -932,8 +955,13 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
       tst_br s insn
     else if (op0 land 3) = 1 && op1 <= 7 then
       cmp_br s insn
+    else if op0 = 0b110 && op1 = 0b0100 then
+      if insn lsr 20 land 1 = 1 then
+        branch_system_register_move s insn
+      else
+        notimplemented s insn "System instruction"
     else
-      error s.a (Printf.sprintf "Unsupported branch opcode 0x%08x" insn)
+      notimplemented s insn "Branch opcode"
 
 
   (* SIMD three same - C4.1.5, page C-302) *)
@@ -966,7 +994,7 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
 
   (* Conversion between floating-point and fixed-point *)
   let fp_fp_conv  (s: state) (insn: int): (Asm.stmt list) =
-    error s.a (Printf.sprintf "Conversion between floating-point and fixed-point not implemented, opcode : 0x%08x" insn)
+    notimplemented s insn "Conversion between floating-point and fixed-point"
 
 
   (* Conversion between floating-point and integer *)
@@ -981,7 +1009,7 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
     match sf, s_, typ, rmode, opcode with
     | 0, 0, 0b00, 0b00, 0b110 -> [ Set( V (wreg rd), Lval (V (sreg rn))) ]
     | 0, 0, 0b00, 0b00, 0b111 -> [ Set( V (qreg rd), UnOp(ZeroExt 128, Lval (V (wreg rn)))) ]
-    | _ -> error s.a (Printf.sprintf "Unsupported floating-point and integer conversion instruction opcode: 0x%08x" insn)
+    | _ -> notimplemented s insn "Floating-point and integer conversion"
 
   let scalar_fp_simd  (s: state) (insn: int): (Asm.stmt list) =
     let op0 = (insn lsr 28) land 0xf in
@@ -998,12 +1026,12 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
           if (op2 land 4) = 4 && (op3 land 1) = 1 then
             simd_three_same
           else
-            error s.a (Printf.sprintf "Unsupported scalar floating point or SIMD opcode: 0x%08x" insn)
+            notimplemented s insn "Scalar floating point or SIMD"
         end
       else
         begin
           L.debug (fun p -> p "FP/SIMD instruction decoded as: op0=%x op1=%x op2=%x op3=%x" op0 op1 op2 op3);
-          error s.a (Printf.sprintf "Unsupported scalar floating point or SIMD opcode: 0x%08x" insn)
+          notimplemented s insn "Scalar floating point or SIMD (2)"
         end
     in f s insn
 
@@ -1014,7 +1042,7 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
     let stmts = match (instruction lsr 25) land 0xF with
       (* C4.1 in ARMv8 manual *)
       (* 00xx : unallocated *)
-      | 0b0000 | 0b0001 | 0b0010 | 0b0011 -> error s.a (Printf.sprintf "Unallocated opcode 0x%x" instruction)
+      | 0b0000 | 0b0001 | 0b0010 | 0b0011 -> error s.a "Unallocated opcode"
       (* 100x : data processing (immediate) *)
       | 0b1000 | 0b1001 -> data_processing_imm s instruction
       (* 101x : branches, exceptions, system instructions *)
@@ -1024,7 +1052,7 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
       (* x101 : data processing (register) *)
       | 0b0101 | 0b1101 -> data_processing_reg s instruction
       | 0b0111 | 0b1111 -> scalar_fp_simd s instruction
-      | _ -> error s.a (Printf.sprintf "Unknown opcode 0x%x" instruction)
+      | _ -> error s.a "Unknown opcode"
     in
     return s str stmts
 
@@ -1040,6 +1068,11 @@ B  <31:31:op:F:0,30:26:_:F:00101,25:0:imm26:F:xxxxxxxxxxxxxxxxxxxxxxxxxx> Branch
       let v', ip' = decode s in
       Some (v', ip', ())
     with
+    | Exceptions.Failed_decoding (msg, isn) -> (
+      L.debug(fun p -> p "Failed-decoding: %s" msg);
+      let v', ip' = return s (String.sub s.buf 0 4) [] in
+      Some (v', ip', ())
+    )
     | Exceptions.Error _ as e -> raise e
     | _             -> (*end of buffer *) None
 
diff --git a/ocaml/src/disassembly/armv8aImports.ml b/ocaml/src/disassembly/armv8aImports.ml
index 6a3d6fe1..5fc4a8ca 100644
--- a/ocaml/src/disassembly/armv8aImports.ml
+++ b/ocaml/src/disassembly/armv8aImports.ml
@@ -116,7 +116,7 @@ struct
           libname = "";
           prologue = [];
           stub = [];
-          epilogue = [] ;
+          epilogue = [Directive ( Skip (Asm.Fun_addr a, get_callconv()))] ;
           ret_addr =Lval(reg "x30");
            }
          else
diff --git a/ocaml/src/disassembly/cfa.ml b/ocaml/src/disassembly/cfa.ml
index 58c4924a..0b418492 100644
--- a/ocaml/src/disassembly/cfa.ml
+++ b/ocaml/src/disassembly/cfa.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2019 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -34,13 +34,8 @@ sig
     type ctx_t = {
       addr_sz: int; (** size in bits of the addresses *)
       op_sz  : int; (** size in bits of operands *)
-      }
-               
-    (** data type for handler management *)
-    type handler_kind_t =
-      | Direct of Data.Address.t
-      | Inlined of Asm.stmt list
-                 
+    }
+
     type t  = {
       id: int;                          (** unique identificator of the state *)
       mutable ip: Data.Address.t;       (** instruction pointer *)
@@ -54,8 +49,7 @@ sig
       mutable branch: bool option;      (** None is for unconditional predecessor. Some true if the predecessor is a If-statement for which the true branch has been taken. Some false if the false branch has been taken *)
       mutable bytes: char list;         (** corresponding list of bytes *)
       mutable taint_sources: Taint.Set.t;    (** set of taint sources*)
-      mutable back_taint_sources: Taint.Set.t option; (** set of taint sources in backward mode. None means undefined *)
-      mutable handlers: (int, Data.Address.t) Hashtbl.t * (int -> Asm.stmt list); (** table of user defined handlers * default handler behavior *)
+      mutable back_taint_sources: Taint.Set.t option (** set of taint sources in backward mode. None means undefined *)
     }
 
     val compare: t -> t -> int
@@ -63,17 +57,13 @@ sig
 
   (** oracle for retrieving any semantic information computed by the interpreter *)
   class oracle:
-          domain ->
-          (int, Data.Address.t) Hashtbl.t * (int -> Asm.stmt list) ->
+    domain ->
   object
     (** returns the computed concrete value of the given register
         may raise an exception if the conretization fails
         (not a singleton, bottom) *)
     method value_of_register: Register.t -> Z.t
 
-    (** returns the address associated to the given interrupt number *)
-    method get_handler: int -> State.handler_kind_t
-         
   end
 
   (** abstract data type of the control flow graph *)
@@ -82,12 +72,16 @@ sig
   (** [create] creates an empty CFG *)
   val create: unit -> t
 
-  (** [init_state addr] creates a state whose ip field is _addr_ *)
-  val init_state: Data.Address.t -> (int -> Asm.stmt list) -> State.t
+  (** [init addr] creates a state whose ip field is _addr_ *)
+  val init_state: Data.Address.t -> State.t
 
   (** [add_state cfg state] adds the state _state_ from the CFG _cfg_ *)
   val add_state: t -> State.t -> unit
 
+  val has_ip: t -> State.t -> bool
+
+  val update_states: t -> Data.Address.t -> unit
+
   (** [copy_state cfg state] creates a fresh copy of the state _state_ in the CFG _cfg_.
       The fresh copy is returned *)
   val copy_state: t -> State.t -> State.t
@@ -157,10 +151,6 @@ struct
       op_sz  : int; (** size in bits of operands *)
     }
 
-    type handler_kind_t =
-      | Direct of Data.Address.t
-      | Inlined of Asm.stmt list
-                 
     (** abstract data type of a state *)
     type t = {
       id: int;                          (** unique identificator of the state *)
@@ -175,8 +165,7 @@ struct
       mutable branch: bool option;      (** None is for unconditional predecessor. Some true if the predecessor is a If-statement for which the true branch has been taken. Some false if the false branch has been taken *)
       mutable bytes: char list;         (** corresponding list of bytes *)
       mutable taint_sources: Taint.Set.t;     (** set of taint sources. Empty if not tainted  *)
-      mutable back_taint_sources: Taint.Set.t option; (** set of taint sources in backward mode. None means undefined *)
-      mutable handlers: (int, Data.Address.t) Hashtbl.t * (int -> Asm.stmt list); (** table of user defined handlers * default handler behavior *)
+      mutable back_taint_sources: Taint.Set.t option (** set of taint sources in backward mode. None means undefined *)
     }
 
     (** the state identificator counter *)
@@ -201,14 +190,9 @@ struct
   open State
 
 
-  class oracle (d: domain) (handlers: (((int, Data.Address.t) Hashtbl.t) * (int -> Asm.stmt list))) =
+  class oracle (d: domain) =
   object
     method value_of_register (reg: Register.t) = Domain.value_of_register d reg
-
-    method get_handler i = 
-      try
-        State.Direct (Hashtbl.find (fst handlers) i)
-      with Not_found -> State.Inlined ((snd handlers) i)
   end
 
   (** type of a CFA *)
@@ -248,7 +232,7 @@ struct
       match c with
       | Some c' -> Config.size_of_content c'
       | None -> 0
-         
+
     let init_heap ip domain content_list =
       (* TODO: factorize with init_mem *)
       List.fold_left
@@ -265,8 +249,8 @@ struct
           in
           d', Taint.Set.union prev_taint taint
         ) (domain, Taint.Set.singleton Taint.U) (List.rev content_list)
-  
-      
+
+
   let update_abstract_value ip d =
     (* initialisation of Global memory + registers *)
     let d', taint1 = init_registers d in
@@ -282,8 +266,8 @@ struct
 
   (* CFA creation.
      Return the abstract value generated from the Config module *)
-    
-  let init_state (ip: Data.Address.t) default_handlers: State.t =
+
+  let init_state (ip: Data.Address.t): State.t =
     let d', _taint = init_abstract_value ip in
     {
       id = 0;
@@ -302,27 +286,66 @@ struct
       };
       taint_sources = Taint.Set.singleton Taint.U;
       back_taint_sources = None;
-      handlers = Hashtbl.create 5, default_handlers;
     }
 
 
   (* CFA utilities *)
   (*****************)
 
+  let has_ip (_, ips) v =
+    try
+      let states = Hashtbl.find ips v.State.ip in
+      let states_with_statements =
+      try
+        List.find_all (fun p -> p.stmts <> []) states;
+      with Not_found -> []
+     in
+      if (List.length states_with_statements) > 0 then true else false
+    with Not_found -> false
+
+
+    (* let states =
+      try
+        Hashtbl.find ips v.State.ip
+      with Not_found -> []
+    in L.info(fun p -> p "(has_ip) States (id %d) %d" v.State.id (List.length states));
+    List.iter(fun v -> L.info(fun p -> p "Statements : %d" (List.length v.stmts))) states;
+    Hashtbl.mem ips v.State.ip *)
+
   let update_ips ips v =
+    L.info(fun p -> p "Update ips with state %d and ip %s" v.State.id (Data.Address.to_string v.State.ip));
     let states =
        try Hashtbl.find ips v.State.ip
       with Not_found -> []
     in
     Hashtbl.replace ips v.State.ip (v::states)
-    
+
+  let update_states ((_, ips): t) (old_ip: Data.Address.t): unit =
+    (* After cloning states for branches, the IP may be wrong so we update it and set the state to the correct IP *)
+    L.info(fun p -> p "Updating state for old_ip %s" (Data.Address.to_string old_ip));
+    let states =
+      try
+        Hashtbl.find ips old_ip
+      with Not_found -> []
+    in
+    L.info(fun p -> p "States size before : %d " (List.length states));
+    let new_states = List.fold_left (fun l' v ->
+      L.info(fun p -> p "Old_ip %s / State ip is %s / R: %b" (Data.Address.to_string old_ip) (Data.Address.to_string v.State.ip) (v.State.ip = old_ip));
+      if v.State.ip <> old_ip then (
+        update_ips ips v;
+        l'
+      ) else
+        v::l'
+    ) [] states in
+    Hashtbl.replace ips old_ip new_states;
+    L.info(fun p -> p "States size after : %d " (List.length new_states))
+
   let copy_state (g, ips) v =
     let v = { v with id = new_state_id() } in
     G.add_vertex g v;
     update_ips ips v;
     v
 
-
   let create () = G.create (), Hashtbl.create 117
 
   let remove_state (g, ips: t) (v: State.t): unit =
@@ -330,10 +353,8 @@ struct
     let rec remove l =
       match l with
       | [] -> []
-      | a::l ->
-         if a.State.id = vid then l else a::(remove l)
-    in
-    let states =
+      | a::l -> if a.State.id = vid then l else a::(remove l)
+    in let states =
       try
         remove (Hashtbl.find ips v.State.ip)
       with Not_found -> []
@@ -405,7 +426,7 @@ struct
     Printf.fprintf f "\n[program]\nnull = 0x%s\nmem_sz=%d\nstack_width=%d\n" (Z.format "%02x" (!Config.null_cst) ) (!Config.address_sz)(!Config.stack_width);
     Printf.fprintf f "architecture = %s\n\n" architecture_str;
     (* taint sources *)
-    Printf.fprintf f "[taint sources]\n"; 
+    Printf.fprintf f "[taint sources]\n";
     Hashtbl.iter (fun id src -> Printf.fprintf f "%d = %s\n" id (Dump.string_of_src src)) Dump.taint_src_tbl;
     Printf.fprintf f "\n";
     Printf.fprintf f "[heap ids]\n";
@@ -417,11 +438,11 @@ struct
     close_out f;;
 
 
-  let marshal (fid: out_channel) (cfa, ips: t): unit =
-    Marshal.to_channel fid cfa [Marshal.Closures];
-    Marshal.to_channel fid ips [Marshal.Closures];
+  let marshal (fid:out_channel) (cfa, ips: t): unit =
+    Marshal.to_channel fid cfa [];
+    Marshal.to_channel fid ips [];
     Marshal.to_channel fid !state_cpt [];;
-  
+
   let unmarshal fid: t =
     let origcfa = Marshal.from_channel fid in
     let origips = Marshal.from_channel fid in
diff --git a/ocaml/src/disassembly/cfa.mli b/ocaml/src/disassembly/cfa.mli
index 61d5a5ff..d43ba347 100644
--- a/ocaml/src/disassembly/cfa.mli
+++ b/ocaml/src/disassembly/cfa.mli
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2018 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -33,11 +33,6 @@ module type T =
       op_sz  : int; (** size in bits of operands *)
     }
 
-    (** data type for handler management *)
-    type handler_kind_t =
-      | Direct of Data.Address.t
-      | Inlined of Asm.stmt list
-                 
     type t  = {
       id: int;                  (** unique identificator of the state *)
       mutable ip: Data.Address.t;   (** instruction pointer *)
@@ -52,8 +47,7 @@ module type T =
       mutable branch: bool option; (** None is for unconditional predecessor. Some true if the predecessor is a If-statement for which the true branch has been taken. Some false if the false branch has been taken *)
       mutable bytes: char list;      (** corresponding list of bytes *)
       mutable taint_sources: Taint.Set.t; (** set of taint sources *)
-      mutable back_taint_sources: Taint.Set.t option; (** set of taint sources in backward mode. None means undefined *)
-      mutable handlers: (int, Data.Address.t) Hashtbl.t * (int -> Asm.stmt list); (** table of user defined handlers * default handler behavior *)
+      mutable back_taint_sources: Taint.Set.t option (** set of taint sources in backward mode. None means undefined *)
 
     }
 
@@ -63,15 +57,13 @@ module type T =
 
   (** oracle for retrieving any semantic information computed by the interpreter *)
   class oracle:
-    domain -> (int, Data.Address.t) Hashtbl.t * (int -> Asm.stmt list) -> 
+    domain ->
   object
     (** returns the computed concrete value of the given register
         may raise an exception if the conretization fails
         (not a singleton, bottom) *)
     method value_of_register: Register.t -> Z.t
 
-    (** returns the address associated to the given interrupt number *)
-    method get_handler: int -> State.handler_kind_t
   end
 
   (** abstract data type of the control flow graph *)
@@ -80,12 +72,16 @@ module type T =
   (** [create] creates an empty CFG *)
   val create: unit -> t
 
-  (** [init_state addr] creates a state whose ip field is _addr_ *)
-  val init_state: Data.Address.t -> (int -> Asm.stmt list) -> State.t
+  (** [init addr] creates a state whose ip field is _addr_ *)
+  val init_state: Data.Address.t -> State.t
 
   (** [add_state cfg state] adds the state _state_ from the CFG _cfg_ *)
   val add_state: t -> State.t -> unit
 
+  val has_ip: t -> State.t -> bool
+
+  val update_states: t -> Data.Address.t -> unit
+
   (** [copy_state cfg state] creates a fresh copy of the state _state_ in the CFG _cfg_.
       The fresh copy is returned *)
   val copy_state: t -> State.t -> State.t
diff --git a/ocaml/src/disassembly/core_x86.ml b/ocaml/src/disassembly/core_x86.ml
index a8fdea91..7e98006f 100644
--- a/ocaml/src/disassembly/core_x86.ml
+++ b/ocaml/src/disassembly/core_x86.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2019 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -17,7 +17,7 @@
  *)
 
 (************************************************************)
-(* Core functionalities of the x86 decoders                 *)
+(* core functionalities of the x86 decoders                 *)
 (************************************************************)
 
 module L = Log.Make(struct let name = "core_x86" end)
@@ -71,7 +71,7 @@ type tbl_entry = {
     dpl: privilege_level;
     p: Z.t;
     avl: Z.t;
-    l: Z.t; (* 64-bit flag *)
+    l: Z.t;
     db: Z.t;
     gran: Z.t;}
 
@@ -98,46 +98,40 @@ type ictx_t = {
 
 
 module type Arch =
-  functor (Domain: Domain.T) ->
-  functor (Stubs: Stubs.T with type domain_t := Domain.t) ->
-  sig
-    module Cfa: Cfa.T
-    val operand_sz: int
-    module Imports:
-    sig
-      val init: unit -> unit
-      val skip: (Asm.import_desc_t * Asm.calling_convention_t) option ->
-                Data.Address.t -> Asm.import_desc_t
-      val tbl: (Data.Address.t, Asm.import_desc_t * Asm.calling_convention_t) Hashtbl.t
-
-      (** returns the statements enabling to set the first function argument corresponding to the current calling convention *)
-      val set_first_arg: Asm.exp -> Asm.stmt list
-      val unset_first_arg: unit -> Asm.stmt list
-        
-    end
-    val ebx: Register.t
-    val ebp: Register.t
-    val esi: Register.t
-    val edi: Register.t
-    val edx: Register.t
-    val eax: Register.t
-    val ecx: Register.t
-    val esp: Register.t
-    val init_registers: (int, Register.t) Hashtbl.t -> (int, Register.t) Hashtbl.t -> unit
-    val decode_from_0x40_to_0x4F: char -> int -> rex_t
-    val arch_get_base_address: Cfa.oracle -> ictx_t -> Data.Address.t -> Register.t -> Z.t
-    (* function to set an lval to an expression *)
-    val set_dest: Asm.lval -> Asm.exp -> Asm.stmt list
-      
-    (** add_segment translates the segment selector/offset pair into a linear addresss *)
-    val add_segment: Cfa.oracle -> ictx_t -> int -> Data.Address.t -> Asm.exp -> Register.t -> Asm.exp
-    (* Check segments limits, returns (success_bool, base_addr, limit) *)
-    val check_seg_limit: Cfa.oracle -> Data.Address.t -> ictx_t -> Register.t -> Data.Address.t -> bool * Z.t * Z.t
-    val get_rex: int -> rex_t option
-    val prologue: Address.t -> Asm.stmt list
-    val get_operand_sz_for_stack: unit -> int
-  end
-  
+  functor (Domain: Domain.T) -> functor (Stubs: Stubs.T with type domain_t := Domain.t) ->
+                                sig
+                                  module Cfa: Cfa.T
+                                  val operand_sz: int
+                                  module Imports:
+                                  sig
+                                    val init: unit -> unit
+                                    val skip: (Asm.import_desc_t * Asm.calling_convention_t) option ->
+                                              Data.Address.t -> Asm.import_desc_t
+                                    val tbl: (Data.Address.t, Asm.import_desc_t * Asm.calling_convention_t) Hashtbl.t
+                                  end
+                                  val ebx: Register.t
+                                  val ebp: Register.t
+                                  val esi: Register.t
+                                  val edi: Register.t
+                                  val edx: Register.t
+                                  val eax: Register.t
+                                  val ecx: Register.t
+                                  val esp: Register.t
+                                  val init_registers: (int, Register.t) Hashtbl.t -> (int, Register.t) Hashtbl.t -> unit
+                                  val decode_from_0x40_to_0x4F: char -> int -> rex_t
+                                  val arch_get_base_address: Cfa.oracle -> ictx_t -> Data.Address.t -> Register.t -> Z.t
+                                  (* function to set an lval to an expression *)
+                                  val set_dest: Asm.lval -> Asm.exp -> Asm.stmt list
+
+                                  (** add_segment translates the segment selector/offset pair into a linear addresss *)
+                                  val add_segment: Cfa.oracle -> ictx_t -> int -> Data.Address.t -> Asm.exp -> Register.t -> Asm.exp
+                                  (* Check segments limits, returns (success_bool, base_addr, limit) *)
+                                  val check_seg_limit: Cfa.oracle -> Data.Address.t -> ictx_t -> Register.t -> Data.Address.t -> bool * Z.t * Z.t
+                                  val get_rex: int -> rex_t option
+                                  val prologue: Address.t -> Asm.stmt list
+                                  val get_operand_sz_for_stack: unit -> int
+                                end
+
 (** fatal error reporting *)
 let error a msg =
   L.abort (fun p -> p "at %s: %s" (Address.to_string a) msg)
@@ -305,7 +299,7 @@ module  X64(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := Domain.t) =
       | M(_, _) -> normal_set
       | V(r) -> match r with
                 | T(_) -> (* full assignation *) normal_set
-                | P(reg, l, u) -> if l == 0 && u == 31 then [Set (V (T reg), UnOp (ZeroExt 64, value))] else normal_set 
+                | P(reg, l, u) -> if l == 0 && u == 31 then [Set (V (T reg), UnOp (ZeroExt 64, value))] else normal_set
 
     let add_segment ctx segments operand_sz rip offset sreg =
       match (Register.name sreg) with
@@ -715,7 +709,6 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
   (** control flow automaton *)
   module Arch = Arch(Domain)(Stubs)
   open Arch
-
   module Cfa = Arch.Cfa
   module Imports = Arch.Imports
   let cl = P (Arch.ecx, 0, 7)
@@ -848,9 +841,7 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
     let lvl   = v land 3         in
     let ti    = (v lsr 2) land 1 in
     let index = (v lsr 3)        in
-    { rpl = privilege_level_of_int lvl;
-      ti = if ti = 0 then GDT else LDT;
-      index = Word.of_int (Z.of_int index) 13 }
+    { rpl = privilege_level_of_int lvl; ti = if ti = 0 then GDT else LDT; index = Word.of_int (Z.of_int index) 13 }
 
 
 
@@ -866,8 +857,7 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
   let copy_segments s addr ctx =
     let segments =
       get_segments addr ctx in
-    { gdt = Hashtbl.copy s.gdt; ldt = Hashtbl.copy s.ldt;
-      idt = Hashtbl.copy s.idt; data = ds; reg = segments  }
+    { gdt = Hashtbl.copy s.gdt; ldt = Hashtbl.copy s.ldt; idt = Hashtbl.copy s.idt; data = ds; reg = segments  }
 
   (** returns the base address corresponding to the given value (whose format is supposed to be compatible with the content of segment registers *)
   let get_base_address s sreg =
@@ -1384,16 +1374,19 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
     in
     replace_lv lv
 
-  let icall s =
-      let cesp = M (Lval (V (T esp)), !Config.stack_width) in
-      (* call destination *)
-      let ip' = Data.Address.add_offset s.a (Z.of_int s.o) in
-      let ip = Const (Data.Address.to_word ip' s.operand_sz) in
-      [set_esp Sub (T esp) !Config.stack_width;
-       Set (cesp, ip)]
-                
-  let call s dest_exp = (icall s)@[Call dest_exp]
-                      
+  let call s dest_exp =
+    let cesp = M (Lval (V (T esp)), !Config.stack_width)   in
+    (* call destination *)
+    let ip' = Data.Address.add_offset s.a (Z.of_int s.o) in
+    let ip   = Const (Data.Address.to_word ip' s.operand_sz) in
+    let stmts =
+      [
+        set_esp Sub (T esp) !Config.stack_width;
+        Set (cesp, ip);
+        Call dest_exp
+      ]
+    in
+    stmts
 
   (** call with expression *)
   let indirect_call s dst =
@@ -1497,29 +1490,27 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
   (** state generation for the pop instructions *)
   let pop s lv = return s (pop_stmts true s lv)
 
-  let popf_stmts s sz =
-    let name = Register.fresh_name () in
-    let v = Register.make ~name:name ~size:sz in
-    let tmp = V (T v) in
+  let popf s sz =
+    let name        = Register.fresh_name ()            in
+    let v           = Register.make ~name:name ~size:sz in
+    let tmp         = V (T v) in
     let stmt = set_eflags v in
     let popst = pop_stmts true s [tmp, sz] in
-    popst @ stmt @ [Directive (Remove v)]
+    return s (popst @ stmt @ [Directive (Remove v)])
 
-  let popf s sz = return s (popf_stmts s sz)
-                
   (** generation of statements for the push instructions *)
   let push_stmts (s: state) v =
     let esp' = esp_lval () in
     let t    = Register.make (Register.fresh_name ()) (Register.size esp) in
-    (* in case esp is in the list, save its value before the first push 
-       (this is this value that has to be pushed for esp) 
-       this is the purpose of the pre and post statements *)
+    (* in case esp is in the list, save its value before the first push (this is this value that has to be pushed for esp) *)
+    (* this is the purpose of the pre and post statements *)
     let pre, post=
       if List.exists (fun k -> with_stack_pointer false s.a (fst k)) v then
         [ Set (V (T t), Lval (V esp')) ], [ Directive (Remove t) ]
       else
         [], []
     in
+
     let stmts =
       List.fold_left (
           fun stmts (lv, n) ->
@@ -1552,9 +1543,7 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
   let push_immediate s sz =
     let c     = get_imm s sz !Config.stack_width true in
     let esp'  = esp_lval () in
-    let stmts = [
-        set_esp Sub esp' !Config.stack_width;
-        Set (M (Lval (V esp'), !Config.stack_width), c) ]
+    let stmts = [ set_esp Sub esp' !Config.stack_width; Set (M (Lval (V esp'), !Config.stack_width), c) ]
     in
     return s stmts
 
@@ -1574,8 +1563,7 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
 
   let pushf s sz = return s (pushf_stmts s sz)
 
-  (** returns the state for the mov from immediate operand to register. 
-      The size in byte of the immediate is given as parameter *)
+  (** returns the state for the mov from immediate operand to register. The size in byte of the immediate is given as parameter *)
   let mov_immediate s sz =
     let sz' = if sz = 8 then sz else s.operand_sz in
     let dst, _ = operands_from_mod_reg_rm s sz' 0 in
@@ -2485,7 +2473,6 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
       if s.repne then
         match c with
         | c when '\xA6' <= c && c <= '\xA7' || '\xAE' <= c && c <= '\xAF' -> c
-        | '\xFF' -> if !Config.mpx then error s.a "bnd jmp instruction not managed (MPX enabled)" else c
         | _ -> L.warn (fun p->p "%s: Decoder: undefined behavior of REPNE with opcode %x" (Data.Address.to_string s.a) (Char.code c)); c
       else
         c
@@ -2575,65 +2562,12 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
   exception No_rep of Cfa.State.t * Data.Address.t
 
 
-  let convert_interrupt_number n =
-    match !Config.os, n with
-    | Config.Linux, 3 -> 5
-    | _, _ -> n
-
-  (** INT n *)
-  let int_n n s ctx =
-    let n = convert_interrupt_number n in
-    let handler = ctx#get_handler n in
-    let stmts =
-      match handler with
-      | Cfa.State.Direct a -> (Imports.set_first_arg (const n !Config.stack_width)) @ (call s (A a)) @ (Imports.unset_first_arg ())
-      | Cfa.State.Inlined stmts -> (icall s) @ stmts
-    in
-    let stmts = (* push flags, set the first arg of the handler and call the handler *)
-      (if !Config.os = Config.Windows then [] else pushf_stmts s !Config.stack_width)
-      @ stmts
-      @ (if !Config.os = Config.Windows then [] else popf_stmts s !Config.stack_width)
-    in
-    return s stmts
- 
-
-  (* INT 3*)
-  let int_3 s ctx =
-    L.debug2 (fun p -> p "decoding INT 3");
-    (* we ignore the differences between the opcode CC et CD03 *)
-    int_n 3 s ctx
-
-
-  let into s ctx =
-    try
-      (* Vol 3, 5.2.1: Bit 53 is defined as the 64-bit (L) flag and is used to select 
-         between 64-bit mode and compatibility mode when IA-32e mode is active *)
-      let csv = get_segment_register_mask (ctx#value_of_register cs) in
-      let tbl = if csv.ti = GDT then s.segments.gdt else s.segments.ldt in
-      let cs_segment = Hashtbl.find tbl csv.index in
-      let is_64 =  Z.logand (Z.shift_right cs_segment.base 53) Z.one in
-      if Z.compare is_64 Z.one = 0 then
-        (* vol 2A, 3-457 *)
-        error s.a "Illegal call to INTO in x64 mode"
-      else
-        let ofv = ctx#value_of_register fof in
-        if Z.compare ofv Z.one = 0 then
-          int_n 4 s ctx
-        else
-          return s []
-    with _ -> error s.a "Imprecise value for cs or overflow flag. Analysis stops"
-
-  let iret s =
-    let stmts = (* pop ip, pop flags and restore context *)
-      Return::(popf_stmts s !Config.stack_width) in
-    return s stmts
-    
   (************************************************************)
   (* Main decoding                                            *)
   (************************************************************)
 
   (** decoding of one instruction *)
-  let decode s ctx =
+  let decode s =
     let add_sub_mrm s op use_carry sz direction =
       let dst, src = operands_from_mod_reg_rm s sz direction in
       add_sub s op use_carry dst src sz
@@ -2866,7 +2800,6 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
          let n = (Char.code c) - 0xb4  in
          let r = V (P (Hashtbl.find register_tbl n, 8, 15)) in
          return s [Set (r, Const (Word.of_int (int_of_byte s) 8))]
-         
       | c when '\xb8' <= c && c <= '\xbf' -> mov_imm_direct s c
       | '\xc0' -> (* shift grp2 with byte size*) grp2 s 8 None
       | '\xc1' -> (* shift grp2 with word or double-word size *) grp2 s s.operand_sz None
@@ -2881,17 +2814,12 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
          let sp = V (to_reg esp !Config.stack_width) in
          let bp = V (to_reg ebp !Config.stack_width) in
          return s ( (Set (sp, Lval bp))::(pop_stmts false s [bp, !Config.stack_width]))
-
-      | '\xca' -> (* RET FAR and pop a word *)
-         return s ([Return ; set_esp Add (T esp) s.addr_sz ; ] @ (pop_stmts false s [V (T cs), 16] @ (* pop imm16 *) [set_esp Add (T esp) 16]))
-                                             
+      | '\xca' -> (* RET FAR and pop a word *) return s ([Return ; set_esp Add (T esp) s.addr_sz ; ] @ (pop_stmts false s [V (T cs), 16] @ (* pop imm16 *) [set_esp Add (T esp) 16]))
       | '\xcb' -> (* RET FAR *) return s ([Return ; set_esp Add (T esp) s.addr_sz; ] @ (pop_stmts false s [V (T cs), 16]))
-      | '\xcc' -> (* INT 3 *) int_3 s ctx
+      | '\xcc' -> (* INT 3 *) error s.a "INT 3 decoded. Interpreter halts"
       | '\xcd' -> (* INT *) let c = getchar s in error s.a (Printf.sprintf "INT %d decoded. Interpreter halts" (Char.code c))
-
-      | '\xce' -> (* INTO *) into s ctx
-         
-      | '\xcf' -> (* IRET *) iret s
+      | '\xce' -> (* INTO *) error s.a "INTO decoded. Interpreter halts"
+      | '\xcf' -> (* IRET *) error s.a "IRET instruction decoded. Interpreter halts"
 
       | '\xd0' -> (* grp2 shift with one on byte size *) grp2 s 8 (Some (const1 8))
       | '\xd1' -> (* grp2 shift with one on word or double size *) grp2 s s.operand_sz (Some (const1 8))
@@ -2938,7 +2866,6 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
         begin
           match List.hd v.Cfa.State.stmts with
           | Return -> L.decoder (fun p -> p "simplified rep ret into ret")
-          | Jmp _ -> L.decoder (fun p -> p "simplified rep jmp into jmp")
           | _ ->
              (* XXX:
               * if we do not have a cmps or a scas remove repe/repne flag
@@ -3008,18 +2935,6 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
          let v, ip = mod_rm_on_xmm2 s sz in
          raise (No_rep (v, ip))
 
-      | '\x1e' ->
-         let byte = getchar s in
-         if byte = '\xfa' || byte = '\xfb' then
-           (* endbr64 / endbr62 *)
-           if !Config.mpx then
-             error s.a "endbr: MPX extension not managed"
-           else
-             (* TODO: could call our checker that verifies whether the actual return address is the one expected *)
-             return s [ Nop ]
-         else
-           error s.a (Printf.sprintf "unknown third opcode 0x%x\n" (Char.code byte))
-           
       | '\x1F' -> (* long nop *) let _, _ = operands_from_mod_reg_rm s s.operand_sz 0 in return s [ Nop ]
 
       | '\x28' -> (* MOVAPD *) (* TODO: make it more precise *)
@@ -3134,6 +3049,10 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
       | '\xc7' -> (* CMPXCHG8B *)  cmpxchg8b_mrm s
       | c when '\xc8' <= c && c <= '\xcf' -> let nreg = ((Char.code c)  - 0xc8) + (8*s.rex.b_)  in bswap s nreg s.operand_sz
 
+      | '\xef' -> (* PXOR *)
+        let forgets = List.map (fun r -> Directive (Forget (V (T r)))) [xmm0; xmm1] in
+        let v, ip = return s forgets in
+        raise (No_rep (v, ip))
 
       | c        -> error s.a (Printf.sprintf "unknown second opcode 0x%x\n" (Char.code c))
     in
@@ -3160,7 +3079,7 @@ module Make(Arch: Arch)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := D
       }
     in
     try
-      let v', ip = decode s' ctx in
+      let v', ip = decode s' in
       Some (v', ip, s'.segments)
     with
     | Exceptions.Error _ as e -> raise e
diff --git a/ocaml/src/disassembly/decoder.mli b/ocaml/src/disassembly/decoder.mli
index 5c599bd6..8d643721 100644
--- a/ocaml/src/disassembly/decoder.mli
+++ b/ocaml/src/disassembly/decoder.mli
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2018 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -21,52 +21,13 @@
 (***************************************************************************************)
 
 
-module type T =
-
-
-sig
-  (** control flow graph *)
-  module Cfa: Cfa.T
-    
-  (** data struct for external functions management *)
-  module Imports:
-  sig
-
-
-  (** mapping from code addresses to library functions *)
-    val tbl: (Data.Address.t, Asm.import_desc_t * Asm.calling_convention_t) Hashtbl.t
-
-    (** returns a function modeling a skip of the given import function wrt to the given calling convention *)
-      val skip: (Asm.import_desc_t * Asm.calling_convention_t) option -> Data.Address.t -> Asm.import_desc_t
-  end
-
-    (** decoding context *)
-    type ctx_t
-
-
-    (**  [parse text cfg ctx state addr oracle] *)
-    val parse: string -> Cfa.t -> ctx_t -> Cfa.State.t -> Data.Address.t -> Cfa.oracle -> (Cfa.State.t * Data.Address.t * ctx_t) option
-  (** extract the opcode at address _addr_ in _text_ and translate it as a list of statements.
-      This list of statement is added to the list of possible successor of the state _state_ in the control flow graph _cfg_.
-      All needed context for the decoder is passed through the context parameter _ctx_ *)
-
-  (** initialize the decoder and returns its initial context *)
-    val init: unit -> ctx_t
-
-    (** returns the expression to check whether an overflow occurs *)
-    val overflow_expression: unit -> Asm.exp
-
-                                       (** creates registers if not done by default (see x86 and x64 mechanisms) *)
-    val init_registers: unit -> unit
-
-end
-
-
-module type Make = functor (D: Domain.T)(Stubs: Stubs.T with type domain_t := D.t)-> 
 
+module type Make = functor (D: Domain.T) (Stubs: Stubs.T with type domain_t := D.t) ->
 sig
   (** control flow graph *)
   module Cfa: (Cfa.T with type domain = D.t)
+
+  (** data struct for external functions management *)
   module Imports:
   sig
 
@@ -96,5 +57,4 @@ sig
 
                                        (** creates registers if not done by default (see x86 and x64 mechanisms) *)
     val init_registers: unit -> unit
-
 end
diff --git a/ocaml/src/disassembly/powerpc.ml b/ocaml/src/disassembly/powerpc.ml
index 600ffc7f..00eea9e9 100644
--- a/ocaml/src/disassembly/powerpc.ml
+++ b/ocaml/src/disassembly/powerpc.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2018 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -21,7 +21,7 @@
 *)
 module L = Log.Make(struct let name = "powerpc" end)
 
-module Make(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := Domain.t)=
+module Make(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := Domain.t) =
 struct
 
   type ctx_t = unit
@@ -31,7 +31,7 @@ struct
   open Decodeutils
 
   module Cfa = Cfa.Make(Domain)
-               
+
   type state = {
     mutable g             : Cfa.t;        (** current cfa *)
     mutable b             : Cfa.State.t;  (** state predecessor *)
diff --git a/ocaml/src/disassembly/powerpcImports.ml b/ocaml/src/disassembly/powerpcImports.ml
index 505042db..1b832724 100644
--- a/ocaml/src/disassembly/powerpcImports.ml
+++ b/ocaml/src/disassembly/powerpcImports.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2018 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
diff --git a/ocaml/src/disassembly/riscVImports.ml b/ocaml/src/disassembly/riscVImports.ml
index 1025329a..414cc3f0 100644
--- a/ocaml/src/disassembly/riscVImports.ml
+++ b/ocaml/src/disassembly/riscVImports.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2019 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -18,71 +18,3 @@
 
 
 module L = Log.Make(struct let name = "riscVImports" end)
-module Make(D: Domain.T)(Stubs: Stubs.T with type domain_t := D.t) =
-  struct
-
-    open Asm
-    let reg r = V (T (Register.of_name r))
-    let const x sz = Const (Data.Word.of_int (Z.of_int x) sz)
-
-    let tbl: (Data.Address.t, Asm.import_desc_t * Asm.calling_convention_t) Hashtbl.t = Hashtbl.create 5
-    (* https://github.com/riscv/riscv-elf-psabi-doc/ *)
-    (* https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md *)
-    let integer_calling_convention = {
-        return = reg "x1";
-        callee_cleanup = (fun _ -> []);
-        arguments =
-          function
-          | 0 -> reg "x10"
-          | 1 -> reg "x11"
-          | 2 -> reg "x12"
-          | 3 -> reg "x13"
-          | 4 -> reg "x14"
-          | 5 -> reg "x15"
-          | 6 -> reg "x16"
-          | 7 -> reg "x17"
-          | n ->
-             let sz = !Config.operand_sz in
-             M (BinOp (Add, Lval (reg "x2"), const ((n-7)*sz) sz), sz)
-      }
-                                
-    let get_local_callconv cc =
-      match cc with
-      | Config.RISCVI -> integer_calling_convention
-      | c -> L.abort (fun p -> p "Calling convention [%s] not supported for RISC V architecture"
-                                    (Config.call_conv_to_string c))
-              
-    let get_callconv () = get_local_callconv !Config.call_conv
-
-    let stub_stmts_from_name name callconv =
-    if  Hashtbl.mem Stubs.stubs name then
-      [ Directive (Stub (name, callconv)) ]
-    else
-      [ Directive (Forget (reg "x2")) ]
-      
-    let init_imports () =
-    let default_cc = get_callconv () in
-    Hashtbl.iter (fun adrs (libname,fname) ->
-        let tainting_pro,tainting_epi, cc = Rules.tainting_rule_stmts libname fname (fun cc -> get_local_callconv cc) in
-        let cc' =
-          match cc with
-          | Some cc -> cc
-          | None -> default_cc
-        in
-        let typing_pro,typing_epi = Rules.typing_rule_stmts fname cc' in
-        let stub_stmts = stub_stmts_from_name fname cc' in
-        let fundesc:Asm.import_desc_t = {
-        name = fname ;
-        libname = libname ;
-        prologue = typing_pro @ tainting_pro ;
-        stub = stub_stmts ;
-        epilogue = typing_epi @ tainting_epi ;
-        ret_addr = Lval(reg "x30") ;
-      } in
-      Hashtbl.replace tbl (Data.Address.global_of_int adrs) (fundesc, cc')
-    ) Config.import_tbl
-
-    let init () =
-      Stubs.init();
-      init_imports ()
-  end
diff --git a/ocaml/src/disassembly/risc_v.ml b/ocaml/src/disassembly/risc_v.ml
index 124195e3..fd461e1d 100644
--- a/ocaml/src/disassembly/risc_v.ml
+++ b/ocaml/src/disassembly/risc_v.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2019 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -16,25 +16,15 @@
     along with BinCAT.  If not, see <http://www.gnu.org/licenses/>.
  *)
 
-(* implements at least RV32I and RV64I ISA as stated in spec v2.1
-https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf *)
+(* implements at least RV32I and RV64I ISA as stated in spec v2.2 *)
 module L = Log.Make(struct let name = "risc_v" end)
-
-(* XLEN refers to the width of an integer register in bits (either 32 or 64), see section 1.3) *)
-
-(* 32I ISA *)
-module I32 = struct let xlen = 32 end
-
-(* 64I ISA *)
-module I64 = struct let xlen = 64 end
-           
-module Make(Isa: sig val xlen: int end)(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := Domain.t) =
+module Make(Domain: Domain.T)(Stubs: Stubs.T with type domain_t := Domain.t) =
 struct
 
   type ctx_t = unit
 
   open Data
-  (*  open Asm *)
+  open Asm
   module Cfa = Cfa.Make(Domain)
              
   type state = {
@@ -47,113 +37,71 @@ struct
 
   module Imports = RiscVImports.Make(Domain)(Stubs)
 
-  type type_kind =
-    | R
-    | I
-    | S
-    | B
-    | U
-    | J
- 
-  (************************************************************************)
+                   (************************************************************************)
   (* Creation of the general purpose registers *)
   (************************************************************************)
-
-  (* correspondence between ABI mnemonics and actual registers can be found
-     here: https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md#named-abis
-   *)
   let (register_tbl: (int, Register.t) Hashtbl.t) = Hashtbl.create 16;;
-  (*  let x0 = Register.make ~name:"x0" ~size:Isa.xlen;; (* hardcoded to zero *) see Vol I*)
-  let x1 = Register.make ~name:"x1" ~size:Isa.xlen;;
-  let x2 = Register.make ~name:"x2" ~size:Isa.xlen;;
-  let x3 = Register.make ~name:"x3" ~size:Isa.xlen;;
-  let x4 = Register.make ~name:"x4" ~size:Isa.xlen;;
-  let x5 = Register.make ~name:"x5" ~size:Isa.xlen;;
-  let x6 = Register.make ~name:"x6" ~size:Isa.xlen;;
-  let x7 = Register.make ~name:"x7" ~size:Isa.xlen;;
-  let x8 = Register.make ~name:"x8" ~size:Isa.xlen;;
-  let x9 = Register.make ~name:"x9" ~size:Isa.xlen;;
-  let x10 = Register.make ~name:"x10" ~size:Isa.xlen;;
-  let x11 = Register.make ~name:"x11" ~size:Isa.xlen;;
-  let x12 = Register.make ~name:"x12" ~size:Isa.xlen;;
-  let x13 = Register.make ~name:"x13" ~size:Isa.xlen;;
-  let x14 = Register.make ~name:"x14" ~size:Isa.xlen;;
-  let x15 = Register.make ~name:"x15" ~size:Isa.xlen;;
-  let x16 = Register.make ~name:"x16" ~size:Isa.xlen;;
-  let x17 = Register.make ~name:"x17" ~size:Isa.xlen;;
-  let x18 = Register.make ~name:"x18" ~size:Isa.xlen;;
-  let x19 = Register.make ~name:"x19" ~size:Isa.xlen;;
-  let x20 = Register.make ~name:"x20" ~size:Isa.xlen;;
-  let x21 = Register.make ~name:"x21" ~size:Isa.xlen;;
-  let x22 = Register.make ~name:"x22" ~size:Isa.xlen;;
-  let x23 = Register.make ~name:"x23" ~size:Isa.xlen;;
-  let x24 = Register.make ~name:"x24" ~size:Isa.xlen;;
-  let x25 = Register.make ~name:"x25" ~size:Isa.xlen;;
-  let x26 = Register.make ~name:"x26" ~size:Isa.xlen;;
-  let x27 = Register.make ~name:"x27" ~size:Isa.xlen;;
-  let x28 = Register.make ~name:"x28" ~size:Isa.xlen;;
-  let x29 = Register.make ~name:"x29" ~size:Isa.xlen;;
-  let x30 = Register.make ~name:"x30" ~size:Isa.xlen;;
-  let x31 = Register.make ~name:"x31" ~size:Isa.xlen;;
-
-
-  (* convert a string of bits into an integer array *)
-  let fill_bit_array bit_array str len =
-    let convert (c: char): int =
-      match c with
-      | '0' -> 0
-      | '1' -> 1
-      | _ -> L.abort (fun p -> p "invalid bit char")
-    in
-    (* we revert the bit orders to get the number as in the spec, ie the first bit of the string is numbered 31 while the last bit of the string is the zeroth bit *)
-    String.iteri (fun i c -> Array.set bit_array (convert c) (len-i)) str;;
-
-  (* opcode is bits 6 to 0 *)
-  let get_opcode (bit_array: int Array.t): int =
-    let rec acc res n =
-      if n = 0 then
-        res + bit_array.(n)
-      else
-        acc (res lsl 1 + bit_array.(n)) (n-1)
-    in
-    acc 0 6
-
- 
-  let i_type _opcode = failwith "not yet implemented"
-
-  (** fatal error reporting *)
-  let error a msg =
-    L.abort (fun p -> p "at %s: %s" (Address.to_string a) msg)
+  (*  let x0 = Register.make ~name:"x0" ~size:!Config.address_sz;; (* hardcoded to zero *) see Vol I*)
+  let x1 = Register.make ~name:"x1" ~size:!Config.address_sz;;
+  let x2 = Register.make ~name:"x2" ~size:!config.address_sz;;
+  let x3 = Register.make ~name:"x3" ~size:!config.address_sz;;
+  let x4 = Register.make ~name:"x4" ~size:!Config.address_sz;;
+  let x5 = Register.make ~name:"x5" ~size:!Config.address_sz;;
+  let x6 = Register.make ~name:"x6" ~size:!Config.address_sz;;
+  let x7 = Register.make ~name:"x7" ~size:!Config.address_sz;;
+  let x8 = Register.make ~name:"x8" ~size:!Config.address_sz;;
+  let x9 = Register.make ~name:"x9" ~size:!Config.address_sz;;
+  let x10 = Register.make ~name:"x10" ~size:!Config.address_sz;;
+  let x11 = Register.make ~name:"x11" ~size:!Config.address_sz;;
+  let x12 = Register.make ~name:"x12" ~size:!Config.address_sz;;
+  let x13 = Register.make ~name:"x13" ~size:!Config.address_sz;;
+  let x14 = Register.make ~name:"x14" ~size:!Config.address_sz;;
+  let x15 = Register.make ~name:"x15" ~size:!Config.address_sz;;
+  let x16 = Register.make ~name:"x16" ~size:!Config.address_sz;;
+  let x17 = Register.make ~name:"x17" ~size:!Config.address_sz;;
+  let x18 = Register.make ~name:"x18" ~size:!Config.address_sz;;
+  let x19 = Register.make ~name:"x19" ~size:!Config.address_sz;;
+  let x20 = Register.make ~name:"x20" ~size:!Config.address_sz;;
+  let x21 = Register.make ~name:"x21" ~size:!Config.address_sz;;
+  let x22 = Register.make ~name:"x22" ~size:!Config.address_sz;;
+  let x23 = Register.make ~name:"x23" ~size:!Config.address_sz;;
+  let x24 = Register.make ~name:"x24" ~size:!Config.address_sz;;
+  let x25 = Register.make ~name:"x25" ~size:!Config.address_sz;;
+  let x26 = Register.make ~name:"x26" ~size:!Config.address_sz;;
+  let x27 = Register.make ~name:"x27" ~size:!Config.address_sz;;
+  let x28 = Register.make ~name:"x28" ~size:!Config.address_sz;;
+  let x29 = Register.make ~name:"x29" ~size:!Config.address_sz;;
+  let x30 = Register.make ~name:"x30" ~size:!Config.address_sz;;
+  let x31 = Register.make ~name:"x31" ~size:!Config.address_sz;;
+
+  let get_opcode str =
+    String.get str 25
     
-  let decode s: Cfa.State.t * Data.Address.t =
+  let decode s instr_sz: Cfa.State.t * Data.Address.t =
     let str = String.sub s.buf 0 4 in
-    let len = String.length str in
-    let bit_array = Array.make len 0 in
-    fill_bit_array bit_array str len;
-    let opcode = get_opcode bit_array in
-    match opcode with
-    | 0b0000011 -> (* I-type *) i_type opcode
-    | _ -> error s.a (Printf.sprintf "unknown opcode %x\n" opcode)
+    let opcode = get_opcode str in
+      match str with
     
-  let parse text cfg _ctx state addr _oracle =
+  let parse text cfg _ctx state addr oracle =
      let s =  {
       g = cfg;
       b = state;
       a = addr;
       buf = text;
-      addr_sz = Isa.xlen;
+      addr_sz = !Config.address_sz;
     }
     in
     try
-      let v' = decode s in
-      let ip' = Data.Address.add_offset addr (Z.of_int (s.addr_sz/8)) in
+      let v' = decode s A in
+      let ip' = Data.Address.add_offset addr (s.addr_sz/8) in
       Some (v', ip', ())
     with
     | Exceptions.Error _ as e -> raise e
     | _  -> (*end of buffer *) None
 
 let init_registers () = ()
-let init () = Imports.init ()
+  let init () =
+    Imports.init ()
 
-let overflow_expression () = failwith "Not implemented" (* see comment section 2.4, Vol 1 *)
+  let overflow_expression () = Failwith "Not implemented" (* see comment section 2.4, Vol 1 *)
 end
diff --git a/ocaml/src/disassembly/x64Imports.ml b/ocaml/src/disassembly/x64Imports.ml
index 14ede6c4..33fc8b43 100644
--- a/ocaml/src/disassembly/x64Imports.ml
+++ b/ocaml/src/disassembly/x64Imports.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2018 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -63,12 +63,6 @@ struct
               !Config.stack_width)
     }
 
-  let set_first_arg e =
-    let r = if !Config.call_conv = Config.SYSV then (reg "rdi") else (reg "rcx") in
-    [Set (r, e)]
-
-  let unset_first_arg () = []
-                               
   let get_local_callconv cc =
     match cc with
     | Config.SYSV -> sysv_calling_convention ()
diff --git a/ocaml/src/disassembly/x86Imports.ml b/ocaml/src/disassembly/x86Imports.ml
index f8f407e7..bbfdeafb 100644
--- a/ocaml/src/disassembly/x86Imports.ml
+++ b/ocaml/src/disassembly/x86Imports.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2018 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -31,7 +31,7 @@ struct
 
   let cdecl_calling_convention () = {
     return = reg "eax" ;
-    callee_cleanup = (fun _x -> []) ;
+    callee_cleanup = (fun _x -> [ ]) ;
     arguments = function
     | n -> M (BinOp (Add,
                      Lval (reg "esp"),
@@ -60,23 +60,6 @@ struct
 
   let get_callconv () = get_local_callconv !Config.call_conv
 
-  let set_first_arg e =
-    let r = reg "esp" in
-    [
-      Set (r, BinOp(Sub, Lval r, Const (Data.Word.of_int (Z.of_int (!Config.stack_width/8)) !Config.stack_width))) ;
-      Set (M(Lval r, !Config.stack_width), e)
-    ]
-    
-  let unset_first_arg () =
-    match !Config.call_conv with
-    | Config.CDECL ->
-       let r = reg "esp" in
-       [
-         Set (r, BinOp(Add, Lval r, Const (Data.Word.of_int (Z.of_int (!Config.stack_width/8)) !Config.stack_width)))
-       ]
-    | Config.STDCALL -> [] (* done by the callee *)
-    | cc -> L.abort (fun p -> p "Unset_first_arg: unsupported pour that calling convetion (%s)" (Config.call_conv_to_string cc))
-          
   let stub_stmts_from_name name callconv =
     if  Hashtbl.mem Stubs.stubs name then
       [ Directive (Stub (name, callconv)) ]
diff --git a/ocaml/src/domains/domain.mli b/ocaml/src/domains/domain.mli
index 726e984f..a0952d23 100644
--- a/ocaml/src/domains/domain.mli
+++ b/ocaml/src/domains/domain.mli
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -117,7 +117,7 @@ module type T =
       val taint_sources: Asm.exp -> t -> Taint.Set.t
 
       (** [set_type lv t m] type the left value lv with type t *)
-      val set_type: Asm.lval -> Types.t -> t -> t
+      (* val set_type: Asm.lval -> Types.t -> t -> t *)
 
 
       (** [get_address_of addr terminator upper_bound sz m] scans memory to get
@@ -166,7 +166,7 @@ number of copied bytes is returned *)
     (** [print_chars d src nb pad_options]
       print src until nb bytes are copied or null byte is found. If it found before nb bytes
       are copied then if pad_options = Some (pad_char, pad_left) it is padded with the char pad_char on the left if pad_left = true otherwise on the right *)
-      val print_chars: t -> Asm.exp -> int -> (char * bool) option -> t * int
+      val print_chars: t -> Asm.exp -> int -> (char * bool) option -> t
 
       (** [copy_register r dst src] returns dst with value of register r being replaced by its value in src *)
       val copy_register: Register.t -> t -> t -> t
diff --git a/ocaml/src/domains/pointer.ml b/ocaml/src/domains/pointer.ml
index 1f7d35f1..657907d0 100644
--- a/ocaml/src/domains/pointer.ml
+++ b/ocaml/src/domains/pointer.ml
@@ -19,14 +19,14 @@
 module L = Log.Make(struct let name = "pointer" end)
 
 module A = Data.Address
-         
+
 module Make (V: Vector.T) =
   (struct
     type t =
       | BOT
       | Val of (A.region * V.t) (** a pointer is a pair (r, o) where r is the region it points-to and o an offset in that region *)
       | TOP
-             
+
     let bot = BOT
     let top = TOP
     let is_bot p = p = BOT
@@ -63,7 +63,7 @@ module Make (V: Vector.T) =
         | Val (r, o) ->
            let s, t = V.to_strings o in
            Printf.sprintf "%s%s" (A.string_of_region r) s, t
-                      
+
     let untaint p =
       match p with
       | TOP | BOT  -> p
@@ -78,7 +78,7 @@ module Make (V: Vector.T) =
       match p with
       | TOP | BOT  -> p
       | Val (r, o) -> Val (r, V.span_taint o t)
-         
+
     let join p1 p2 =
       match p1, p2 with
       | BOT, p | p, BOT -> p
@@ -103,7 +103,7 @@ module Make (V: Vector.T) =
             else BOT
 
 
-                    
+
         let of_config c n =
           let r =
             match c with
@@ -127,7 +127,7 @@ module Make (V: Vector.T) =
               try Val (r1, V.meet o1 o2)
               with _ -> BOT
             else BOT
-              
+
     let unary op p =
       match p with
       | BOT  -> BOT
@@ -135,7 +135,7 @@ module Make (V: Vector.T) =
       | Val (r, o) ->
          try Val (r, V.unary op o)
          with _ -> BOT
-           
+
     let binary op p1 p2 =
       match p1, p2 with
       | BOT, _ | _, BOT      -> BOT
@@ -154,12 +154,12 @@ module Make (V: Vector.T) =
               if r1 = r2 then Val (r1, V.binary op o1 o2)
               else BOT
             with Exceptions.Too_many_concrete_elements _ -> TOP
-              
-              
+
+
     let of_word w = Val (A.Global, V.of_word w)
-      
+
     let of_addr (r, w): t = Val (r, V.of_word w)
-      
+
     let compare p1 op p2 =
       match p1, p2 with
       | BOT, BOT -> op = Asm.EQ || op = Asm.LEQ
@@ -171,13 +171,23 @@ module Make (V: Vector.T) =
          else
            if op = Asm.NEQ then true
            else false
-           
-    let to_addresses p =
-      match p with
-      | BOT  -> raise (Exceptions.Empty "pointer.to_addresses: undefined pointer")
-      | TOP  -> raise (Exceptions.Too_many_concrete_elements "pointer.to_addresses: imprecise pointer")
-      | Val (r, o) -> V.to_addresses r o
-         
+
+      let to_addresses_taint _p b =
+        L.info(fun p -> p "To address p-taint");
+        let addr = Mapped_mem.get_address_from_taint b in
+        Data.Address.Set.singleton addr
+
+      let to_addresses p b =
+        L.info(fun p -> p "To address pointer");
+        try
+          match p with
+          | BOT | TOP -> raise (Exceptions.Empty "")
+          | Val (r, o) -> V.to_addresses r o
+        with _ -> (
+          if Taint.is_tainted b then to_addresses_taint p b
+          else raise (Exceptions.Empty "pointer.to_address undefined or imprecise")
+        )
+
     let is_subset p1 p2 =
       match p1, p2 with
       | BOT, _ | _, TOP -> true
@@ -185,14 +195,14 @@ module Make (V: Vector.T) =
       | Val (r1, o1), Val (r2, o2) ->
          if r1 = r2 then V.is_subset o1 o2
          else false
-           
+
     let taint_of_config taint n prev: t * Taint.t =
       match prev with
       | Val (r, o) ->
          let o', taint' = V.taint_of_config taint n (Some o) in
          Val (r, o'), taint'
       | _      -> prev, Taint.BOT
-        
+
 
     let combine p1 p2 l u =
       L.debug2 (fun p -> p "Pointer.combine between %s and %s" (to_string p1) (to_string p2));
@@ -200,10 +210,10 @@ module Make (V: Vector.T) =
       | BOT, _ | _, BOT  -> BOT
       | TOP, _ | _, TOP  -> TOP
       | Val (r1, o1), Val (r2, o2) ->
-         if r1 = r2 then 
+         if r1 = r2 then
            Val (r1, V.combine o1 o2 l u)
          else BOT
-           
+
     let extract p l u =
       match p with
       | BOT | TOP  -> p
@@ -229,12 +239,12 @@ module Make (V: Vector.T) =
          let newoffset = V.of_repeat_val offset v_len nb in
          Val (region, newoffset)
 
-         
+
     let rec concat l =
-      L.debug2 (fun p -> p "concat len %d" (List.length l));
+
       match l with
       | [ ] -> BOT
-      | [v] -> v           
+      | [v] -> v
       | v::l' ->
          let v' = concat l' in
          match v, v' with
@@ -244,7 +254,7 @@ module Make (V: Vector.T) =
             if r1 = r2 then
               Val (r1, V.concat o1 o2)
             else BOT
-             
+
     let get_minimal_taint p =
       match p with
       | TOP -> Taint.TOP
@@ -268,5 +278,5 @@ module Make (V: Vector.T) =
       match p with
       | TOP | BOT -> p
       | Val (r, o) -> Val (r, V.forget_taint o)
-                        
+
     end: Unrel.T)
diff --git a/ocaml/src/domains/reduced_bit_tainting.ml b/ocaml/src/domains/reduced_bit_tainting.ml
index 7a5a0403..2e26891c 100644
--- a/ocaml/src/domains/reduced_bit_tainting.ml
+++ b/ocaml/src/domains/reduced_bit_tainting.ml
@@ -53,8 +53,8 @@ let core_sub_add op (v1, t1) (v2, t2) =
     match carry, res_taint with
     | B.ZERO, _   -> None
     | B.ONE, t    -> Some (B.ONE, t)
-    | B.TOP, T.U  -> Some (B.TOP, T.U)
-    | B.TOP, _    -> Some (B.TOP, T.TOP)
+    | B.TOP, t  -> Some (B.TOP, t)
+    (* | B.TOP, _    -> Some (B.TOP, T.TOP) *)
   in
   (res, res_taint), res_carry
 
diff --git a/ocaml/src/domains/reduced_unrel_typenv_heap.ml b/ocaml/src/domains/reduced_unrel_typenv_heap.ml
index f580bcdc..3e9b6279 100644
--- a/ocaml/src/domains/reduced_unrel_typenv_heap.ml
+++ b/ocaml/src/domains/reduced_unrel_typenv_heap.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -213,8 +213,7 @@ module Make(D: Unrel.T) =
 
 
   let print_chars (uenv, _tenv, henv) src sz pad_options =
-    let uenv', len = U.print_chars uenv src sz pad_options (H.check_status henv) in
-    (uenv', T.top, henv), len
+    U.print_chars uenv src sz pad_options (H.check_status henv), T.top, henv
 
   let copy_until (uenv, tenv, henv) dst arg terminator term_sz upper_bound with_exception pad_options =
     let len, uenv' = U.copy_until uenv dst arg terminator term_sz upper_bound with_exception pad_options (H.check_status henv) in
diff --git a/ocaml/src/domains/unrel.ml b/ocaml/src/domains/unrel.ml
index 01bc502c..fae5ed72 100644
--- a/ocaml/src/domains/unrel.ml
+++ b/ocaml/src/domains/unrel.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -28,7 +28,7 @@ module type T =
   sig
     (** abstract data type *)
     type t
- 
+
     (** bottom value *)
     val bot: t
 
@@ -57,7 +57,7 @@ module type T =
 
     (** converts an address into an abstract value *)
     val of_addr: Data.Address.t -> t
-      
+
     (** comparison.
     Returns true whenever the concretization of the first parameter is included in the concretization of the second parameter *)
     val is_subset: t -> t -> bool
@@ -90,7 +90,9 @@ module type T =
     val combine: t -> t -> int -> int -> t
 
     (** converts an abstract value into a set of concrete adresses *)
-    val to_addresses: t -> Data.Address.Set.t
+    val to_addresses: t -> Taint.t -> Data.Address.Set.t
+
+    val to_addresses_taint: t -> Taint.t -> Data.Address.Set.t
 
     (** [binary op v1 v2] return the result of v1 op v2 *)
     val binary: Asm.binop -> t -> t -> t
@@ -112,7 +114,7 @@ module type T =
 
     (** forgets the taint of the given value *)
     val forget_taint: t -> t
-      
+
     (** returns the sub value between bits low and up *)
     val extract: t -> int -> int -> t
 
@@ -134,17 +136,17 @@ module type T =
 
 module Make(D: T) =
   struct
-      
+
     (** type of the Map from Dimension (register or memory) to abstract values *)
     type t = D.t Env.t (* For Ocaml non-gurus : Env is a Map, indexed by Key, with values of D.t *)
 
 
     let empty = Env.empty
-              
+
     let top = Env.empty
-            
- 
-  
+
+
+
     let value_of_register m r =
       let v =
         try
@@ -295,13 +297,19 @@ module Make(D: T) =
           try
             snd (Env.find_key (where addr) map)
           with Not_found ->
-          L.debug (fun p -> p "Address %s not found in mapping, checking sections"
-                              (Data.Address.to_string addr));
           (* not in mem map, check file sections, again, will raise [Not_found] if not matched *)
           let mapped_mem = match !Mapped_mem.current_mapping with
             | None -> L.abort (fun p -> p "File not mmapped")
             | Some x -> x in
-          D.of_word (Mapped_mem.read mapped_mem addr) in
+          (* TODO(dm) CHECK ME*)
+          try
+            let read_value = Mapped_mem.read mapped_mem addr in
+            if Data.Word.to_int read_value < Z.of_int 0 then D.top
+            else D.of_word read_value
+          with _ ->
+            D.top
+          in
+          (* D.of_word (Mapped_mem.read mapped_mem addr) in *)
         let vals = map_or_revmap read_one_byte exp_addrs in
         let res = D.concat vals in
         L.debug (fun p -> p "get_mem_value result : %s" (D.to_string res));
@@ -377,7 +385,7 @@ module Make(D: T) =
       let endianness' = match endianness with
         | None -> !Config.endianness
         | Some x -> x in
-      L.debug (fun p -> p "write_in_memory (addr=%s, value=%s, size=%d bits, %s)" 
+      L.debug (fun p -> p "write_in_memory (addr=%s, value=%s, size=%d bits, %s)"
                           (Data.Address.to_string addr) (D.to_string value) sz
                           (Config.endianness_to_string endianness'));
       let nb = sz / 8 in
@@ -420,7 +428,7 @@ module Make(D: T) =
       let new_mem = List.mapi (fun i addr -> (addr, (D.extract value (i*8) ((i+1)*8-1)))) addrs in
       do_update new_mem domain
 
-                
+
     (***************************)
     (* Non mem functions  :)   *)
     (***************************)
@@ -442,11 +450,10 @@ module Make(D: T) =
         the resulting expression is tainted
     *)
     let rec eval_exp m e check_address_validity: (D.t * Taint.t) =
-      L.debug (fun p -> p "eval_exp(%s)" (Asm.string_of_exp e true));
       let rec eval (e: Asm.exp): D.t * Taint.t =
         match e with
-        | Asm.Const c                -> D.of_word c, Taint.U
-        | Asm.Lval (Asm.V (Asm.T r))         ->
+        | Asm.Const c -> D.of_word c, Taint.U
+        | Asm.Lval (Asm.V (Asm.T r)) ->
            begin
              try
                let v = Env.find (Env.Key.Reg r) m in
@@ -464,15 +471,15 @@ module Make(D: T) =
              | Not_found -> D.bot, Taint.U
            end
 
-        | Asm.Lval (Asm.M (e, n))            ->
+        | Asm.Lval (Asm.M (e, n)) ->
            begin
              let r, tsrc = eval e in
-             try
-               let addresses = Data.Address.Set.elements (D.to_addresses r) in
+             let addresses = Data.Address.Set.elements (D.to_addresses r tsrc)
+           in try
                let rec to_value a =
                  match a with
                  | [a]  ->
-                    check_address_validity a;
+                   check_address_validity a;
                    let v = get_mem_value m a n in
                    v, Taint.logor tsrc (D.taint_sources v)
 
@@ -504,7 +511,9 @@ module Make(D: T) =
            let v1, tsrc1 = eval e1 in
            let v2, tsrc2 = eval e2 in
            let v = D.binary op v1 v2 in
-           v, Taint.logor tsrc1 (Taint.logor tsrc2  (D.taint_sources v))
+           let first_part = Taint.logor tsrc2 (D.taint_sources v) in
+           let tsrc = Taint.logor tsrc1 first_part in
+           v, tsrc
 
         | Asm.UnOp (op, e) ->
            let v, tsrc = eval e in
@@ -551,7 +560,7 @@ module Make(D: T) =
            if b then v1&&v2, Taint.logand b1 b2
            else v1||v2, Taint.logor b1 b2
 
-        | Asm.Cmp (cmp, e1, e2)   -> 
+        | Asm.Cmp (cmp, e1, e2)   ->
            let cmp' = if b then cmp else inv_cmp cmp in
            compare_env m e1 cmp' e2 check_address_validity
       in
@@ -562,13 +571,13 @@ module Make(D: T) =
       let v2, tsrc2 = eval_exp env e2 check_address_validity in
       D.compare v1 op v2, Taint.logor tsrc1 tsrc2
 
-    let forget_lval lv m' check_address_validity = 
+    let forget_lval lv m' check_address_validity =
       match lv with
       | Asm.V (Asm.T r) -> forget_reg m' r None
       | Asm.V (Asm.P (r, l, u)) -> forget_reg m' r (Some (l, u))
       | Asm.M (e, n) ->
-         let v, _b = eval_exp m' e check_address_validity in
-         let addrs = D.to_addresses v in
+         let v, b = eval_exp m' e check_address_validity in
+         let addrs = D.to_addresses v b in
          let l     = Data.Address.Set.elements addrs in
          List.fold_left (fun m a ->  write_in_memory a m D.top n true check_address_validity) m' l
 
@@ -615,10 +624,10 @@ module Make(D: T) =
           val_restrict m' e1 v1 op e2 v2, Taint.logor b1 b2
         else
           raise (Exceptions.Empty "Unrel.compare")
-      
+
     let mem_to_addresses m' e check_address_validity =
       let v, b = eval_exp m' e check_address_validity in
-      let addrs = D.to_addresses v in
+      let addrs = D.to_addresses v b in
       (* check whether the address is allowed to be dereferenced *)
       (* could be put elsewhere with a set of forbidden addresses to check (e.g. range of low addresses) *)
       Data.Address.Set.iter (fun a -> if Data.Address.is_null a then raise (Exceptions.Null_deref (Asm.string_of_exp e true))) addrs;
@@ -672,15 +681,16 @@ module Make(D: T) =
 
     let set_to_memory dst_exp dst_sz v' m' b check_address_validity =
       let v, b' = eval_exp m' dst_exp check_address_validity in
-      let addrs = D.to_addresses v in
-      try
+      let addrs = D.to_addresses v b'
+      in try
         let l     = Data.Address.Set.elements addrs in
-        let t' = Taint.logor b b' in
-        match l with
-        | [a] -> (* strong update *) write_in_memory a m' v' dst_sz true check_address_validity, t'
-        | l   -> (* weak update *) List.fold_left (fun m a -> write_in_memory a m v' dst_sz false check_address_validity) m' l, t'
+          let t' = Taint.logor b b' in
+          match l with
+          | [a] -> (* strong update *) write_in_memory a m' v' dst_sz true check_address_validity, t'
+          | l   -> (* weak update *) List.fold_left (fun m a -> write_in_memory a m v' dst_sz false check_address_validity) m' l, t'
       with
       | Exceptions.Too_many_concrete_elements "unrel.set" -> Env.empty, Taint.TOP
+      | _ -> (L.info(fun p -> p "Other exp"); Env.empty, Taint.TOP)
 
     let set_to_register r v' m' =
       match r with
@@ -688,8 +698,8 @@ module Make(D: T) =
       | Asm.P (r', low, up) ->
          let prev = Env.find (Env.Key.Reg r') m' in
            Env.replace (Env.Key.Reg r') (D.combine prev v' low up) m'
-         
-             
+
+
     let set dst src m' check_address_validity: (t * Taint.t) =
       let v', _ = eval_exp m' src check_address_validity in
          let v' = span_taint m' src v' in
@@ -705,7 +715,7 @@ module Make(D: T) =
                   set_to_register r v' m', b
                 with Not_found -> raise (Exceptions.Empty "Unrel.set (register case)"), Taint.BOT
               end
-                
+
            | Asm.M (e, n) ->
               try
                 set_to_memory e n v' m' b check_address_validity
@@ -731,7 +741,7 @@ module Make(D: T) =
         else
           let m' = Env.empty in
           Env.fold (fun k v1 m' ->
-              try                
+              try
                 let v2 = Env.find k m2 in
                 let v' = D.meet v1 v2 in
                 if D.is_bot v' then
@@ -758,23 +768,23 @@ module Make(D: T) =
         else
           sz
 
-   
+
 
     let extract_taint_src_ids taint =
       let extract acc taint =
         match taint with
         | Config.Taint_all id
-        | Config.Taint (_, id) 
-        | Config.TMask (_, _, id)  
-        | Config.TBytes (_, id) 
+        | Config.Taint (_, id)
+        | Config.TMask (_, _, id)
+        | Config.TBytes (_, id)
         | Config.TBytes_Mask (_, _, id) -> id::acc
         | Config.Taint_none -> acc
-      in 
-      List.fold_left extract [] taint 
-   
+      in
+      List.fold_left extract [] taint
+
     (** builds an abstract tainted value from a config concrete tainted value *)
     let of_config (content, (taint: Config.tvalue list)) sz: (D.t * Taint.t) =
-      let v' = D.of_config content sz in  
+      let v' = D.of_config content sz in
       if taint = [] then
         (v', Taint.U)
       else
@@ -800,6 +810,7 @@ module Make(D: T) =
          Env.replace k v' m', taint
 
     let span_taint_to_addr a taint m': t * Taint.t =
+      L.info2(fun p -> p "Span taint to addr");
       let k = Env.Key.Mem a in
       let v = Env.find k m' in
       let v' = D.span_taint v taint in
@@ -808,7 +819,7 @@ module Make(D: T) =
 
     let forget_taint m = Env.map (fun v -> D.forget_taint v) m
 
-                 
+
     let taint_in_memory a m taint sz strong =
       let addrs = get_addr_list a (sz/8) in
       let update_one_key a (m, prev_taint): D.t Env.t * Taint.t =
@@ -842,17 +853,17 @@ module Make(D: T) =
     let get_taint lv m check_address_validity =
       let _, taint = eval_exp m (Asm.Lval lv) check_address_validity in
       taint
-                       
+
     let taint_lval lv taint check_address_validity m: t * Taint.t =
       match lv with
       | Asm.V (Asm.T r) -> span_taint_to_register r taint m
       | Asm.V (Asm.P (r, _l, _u)) -> span_taint_to_register r Taint.TOP m (* TODO: could be more precise *)
       | Asm.M (e, sz) ->
          try
-           let v, _ = eval_exp m e check_address_validity in
-           let addrs = D.to_addresses v in
+           let v, t = eval_exp m e check_address_validity in
+           let addrs = D.to_addresses v t in
            let l = Data.Address.Set.elements addrs in
-           begin 
+           begin
              match l with
              | [a] -> taint_in_memory a m taint sz true
              | _  -> List.fold_left (fun (m, prev_t) a ->
@@ -860,11 +871,11 @@ module Make(D: T) =
                        m', Taint.join prev_t taint') (m, Taint.U) l
            end
          with _ -> forget_taint m, Taint.TOP
-         
-         
+
+
     let set_memory_from_config addr ((content: Config.cvalue option), (taint: Config.tvalue list)) nb check_address_validity domain': t * Taint.t =
-      L.debug (fun p->p "Unrel.set_memory_from_config");  
-      let taint_srcs = extract_taint_src_ids taint in          
+      L.debug (fun p->p "Unrel.set_memory_from_config");
+      let taint_srcs = extract_taint_src_ids taint in
       let m', taint, sz =
         match content with
         | None ->
@@ -882,7 +893,7 @@ module Make(D: T) =
                  m, t
              in
              let m', taint = repeat (domain', Taint.U) 0 in
-             m', taint, taint_sz                
+             m', taint, taint_sz
            end
         | Some content' ->
            let sz = Config.size_of_content content' in
@@ -901,12 +912,12 @@ module Make(D: T) =
              write_in_memory ~endianness:endianness addr domain' v' sz true check_address_validity, taint, sz
       in
       List.iter (fun id -> if not (Hashtbl.mem Dump.taint_src_tbl id) then
-                             Hashtbl.add Dump.taint_src_tbl id (Dump.M(addr, sz*nb))) taint_srcs;  
+                             Hashtbl.add Dump.taint_src_tbl id (Dump.M(addr, sz*nb))) taint_srcs;
       m', taint
 
 
 
-    let set_register_from_config r (content, taint) m': t * Taint.t =     
+    let set_register_from_config r (content, taint) m': t * Taint.t =
       let taint_srcs = extract_taint_src_ids taint in
       List.iter (fun id ->
           if not (Hashtbl.mem Dump.taint_src_tbl id) then
@@ -917,16 +928,16 @@ module Make(D: T) =
          let v = Env.find k m' in
          let v', taint' =  D.taint_of_config taint (Register.size r) v in
          Env.replace k v' m', taint'
-      | Some c ->  
+      | Some c ->
          let sz = Register.size r in
 
-            let vt, taint = of_config  (c, taint) sz in               
+            let vt, taint = of_config  (c, taint) sz in
             Env.replace (Env.Key.Reg r) vt m', taint
 
-            
+
     let set_lval_to_addr lv (region, word) m check_address_validity =
       (* TODO: should we taint the lvalue if the address to set is tainted ? *)
-      L.debug2 (fun p -> p "entering set_lval_to_addrs with lv = %s" (Asm.string_of_lval lv true));  
+      L.debug2 (fun p -> p "entering set_lval_to_addrs with lv = %s" (Asm.string_of_lval lv true));
          match lv with
          | Asm.M (e, n) ->
             if n <> !Config.address_sz then
@@ -945,15 +956,15 @@ module Make(D: T) =
                         m', Taint.logor taint taint', Z.add i Z.one) (m, Taint.U, Z.zero) bytes
                   in
                   m', taint
-                with _ -> raise (Exceptions.Empty "set_lval_to_addr: invalid dereference"), Taint.BOT 
+                with _ -> raise (Exceptions.Empty "set_lval_to_addr: invalid dereference"), Taint.BOT
               end
-              
+
          | Asm.V r ->
             let v = D.of_addr (region, word) in
             try
               set_to_register r v m, Taint.U
             with Not_found -> raise (Exceptions.Empty (Printf.sprintf "set_lval_to_addr: register %s not found" (Asm.string_of_reg r))), Taint.BOT
-            
+
     let value_of_exp m e check_address_validity =
       D.to_z (fst (eval_exp m e check_address_validity))
 
@@ -967,9 +978,9 @@ module Make(D: T) =
       L.debug(fun p -> p "i_get_bytes addr=%s cmp=%s terminator=%s upper_bound=%i sz=%i"
         (Asm.string_of_exp addr true) (Asm.string_of_cmp cmp)
         (Asm.string_of_exp terminator true) upper_bound sz);
-    
-         let v, _ = eval_exp m' addr check_address_validity in
-         let addrs = Data.Address.Set.elements (D.to_addresses v) in
+
+         let v, t = eval_exp m' addr check_address_validity in
+         let addrs = Data.Address.Set.elements (D.to_addresses v t) in
          let term = fst (eval_exp m' terminator check_address_validity) in
          let off = sz / 8 in
          let rec find (a: Data.Address.t) (o: int): (int * D.t list) =
@@ -978,6 +989,7 @@ module Make(D: T) =
              else o, []
            else
              let a' = Data.Address.add_offset a (Z.of_int o) in
+             L.info2(fun p -> p "i_get_bytes");
              let v = get_mem_value m' a' sz in
              if D.compare v cmp term then
                match pad_options with
@@ -1026,13 +1038,13 @@ module Make(D: T) =
         len, bytes
       with Not_found -> raise (Exceptions.Too_many_concrete_elements "unrel.get_bytes")
 
-    let get_offset_from e cmp terminator upper_bound sz m check_address_validity = fst (i_get_bytes e cmp terminator upper_bound sz m true None check_address_validity) 
+    let get_offset_from e cmp terminator upper_bound sz m check_address_validity = fst (i_get_bytes e cmp terminator upper_bound sz m true None check_address_validity)
 
     let copy_register r dst' src' =
       let k = Env.Key.Reg r in
       let v = Env.find k src' in
       Env.replace k v dst'
-      
+
 
 
     (* Remove the prefix of the string, if needed
@@ -1053,8 +1065,9 @@ module Make(D: T) =
       L.debug (fun p->p "strip, after: %s" res);
       res
 
-    let copy_until m' dst e terminator term_sz upper_bound with_exception pad_options check_address_validity: int * t =  
-       let addrs = Data.Address.Set.elements (D.to_addresses (fst (eval_exp m' dst check_address_validity))) in
+    let copy_until m' dst e terminator term_sz upper_bound with_exception pad_options check_address_validity: int * t =
+      let r, t = eval_exp m' dst check_address_validity in
+       let addrs = Data.Address.Set.elements (D.to_addresses r t) in
        (* TODO optimize: m is pattern matched twice (here and in i_get_bytes) *)
        let len, bytes = i_get_bytes e Asm.EQ terminator upper_bound term_sz m' with_exception pad_options check_address_validity in
        let copy_byte a m' strong =
@@ -1072,7 +1085,7 @@ module Make(D: T) =
          | [] -> raise (Exceptions.Empty "unrel.copy_until")
        in
        len, m'
-   
+
 
     (* print nb bytes on stdout as raw string *)
     let print_bytes bytes nb =
@@ -1090,11 +1103,10 @@ module Make(D: T) =
 
     let print_chars m' src nb pad_options check_address_validity =
       (* TODO: factorize with copy_until *)
-      let len, bytes = i_get_bytes src Asm.EQ (Asm.Const (Data.Word.of_int Z.zero 8)) nb 8 m' false pad_options check_address_validity
-      in
-      print_bytes bytes len;
-      m', len
-       
+      let bytes = snd (i_get_bytes src Asm.EQ (Asm.Const (Data.Word.of_int Z.zero 8)) nb 8 m' false pad_options check_address_validity) in
+      print_bytes bytes nb;
+      m'
+
 
     let copy_chars_to_register m reg offset src nb pad_options check_address_validity =
      let terminator = Asm.Const (Data.Word.of_int Z.zero 8) in
@@ -1120,7 +1132,7 @@ module Make(D: T) =
         with _ -> "?"
       in
       str, String.length str
-      
+
     let to_hex m src nb capitalise pad_option full_print _word_sz check_address_validity: string * int =
       let capitalise str =
         if capitalise then String.uppercase_ascii str
@@ -1180,8 +1192,8 @@ module Make(D: T) =
         (* TODO generalise to non concrete src value *)
       let _, src_tainted = (eval_exp m' src check_address_validity) in
       let str_src, len = to_hex m' src nb capitalise pad_option false word_sz check_address_validity in
-      let vdst = fst (eval_exp m' dst check_address_validity) in
-      let dst_addrs = Data.Address.Set.elements (D.to_addresses vdst) in
+      let vdst, taint = eval_exp m' dst check_address_validity in
+      let dst_addrs = Data.Address.Set.elements (D.to_addresses vdst taint) in
       match dst_addrs with
       | [dst_addr] ->
          let znb = Z.of_int nb in
@@ -1209,8 +1221,8 @@ module Make(D: T) =
     let copy_int m' dst src nb capitalise pad_option word_sz check_address_validity: t * int =
       let _, src_tainted = (eval_exp m' src check_address_validity) in
       let str_src, len = to_int m' src nb capitalise pad_option false word_sz check_address_validity in
-      let vdst = fst (eval_exp m' dst check_address_validity) in
-      let dst_addrs = Data.Address.Set.elements (D.to_addresses vdst) in
+      let vdst, taint = eval_exp m' dst check_address_validity in
+      let dst_addrs = Data.Address.Set.elements (D.to_addresses vdst taint) in
       match dst_addrs with
       | [dst_addr] ->
          let znb = Z.of_int nb in
@@ -1234,8 +1246,8 @@ module Make(D: T) =
       | [] -> raise (Exceptions.Empty "unrel.copy_int")
       | _  -> Env.empty, len (* TODO could be more precise *)
 
-            
-    let print_hex m' src nb capitalise pad_option word_sz check_address_validity: t * int =      
+
+    let print_hex m' src nb capitalise pad_option word_sz check_address_validity: t * int =
       let str, len = to_hex m' src nb capitalise pad_option false word_sz check_address_validity in
       (* str is already stripped in hex *)
       Log.Stdout.stdout (fun p -> p "%s" str);
@@ -1246,30 +1258,31 @@ module Make(D: T) =
       let str, len = to_int m' src nb capitalise pad_option false word_sz check_address_validity in
       Log.Stdout.stdout (fun p -> p "%s" str);
       m', len
-      
+
     let copy m' dst arg sz check_address_validity: t =
     (* TODO: factorize pattern matching of dst with Interpreter.sprintf and with Unrel.copy_hex *)
     (* plus make pattern matching more generic for register detection *)
       let v = fst (eval_exp m' arg check_address_validity) in
-      let addrs = fst (eval_exp m' dst check_address_validity) in
-      match Data.Address.Set.elements (D.to_addresses addrs) with
-      | [a] -> write_in_memory a m' v sz true check_address_validity
-      | _::_ as l -> List.fold_left (fun m a -> write_in_memory a m v sz false check_address_validity) m' l
-      | [ ] -> raise (Exceptions.Empty "Unrel.copy")
-    
+      let addrs, taint = eval_exp m' dst check_address_validity in
+        match Data.Address.Set.elements (D.to_addresses addrs taint) with
+        | [a] -> write_in_memory a m' v sz true check_address_validity
+        | _::_ as l -> List.fold_left (fun m a -> write_in_memory a m v sz false check_address_validity) m' l
+        | [ ] -> raise (Exceptions.Empty "Unrel.copy")
+
 
     (* display (char) arg on stdout as a raw string *)
     let print m' arg _sz check_address_validity: unit =
-      let str = strip (D.to_string (fst (eval_exp m' arg check_address_validity))) in
-      let str' =
-        if String.length str <= 2 then
+      (* let str = strip (D.to_string (fst (eval_exp m' arg check_address_validity))) in *)
+      let str = strip(D.to_string (fst (eval_exp m' arg check_address_validity))) in
+      (* let str' =
+        if String.length str <= 2 then (
+          L.info(fun p -> p "dm(%s)" str);
           String.make 1 (Char.chr (Z.to_int (Z.of_string_base 16 str)))
-        else raise (Exceptions.Empty "Unrel.print")
-      in
-      Log.Stdout.stdout (fun p -> p "%s" str')
-      
+        )
+        else raise (Exceptions.Empty "Unrel.print") *)
+      let str' = String.make 1 (Char.chr (Z.to_int (Z.of_string_base 16 str)))
+      in Log.Stdout.stdout (fun p -> p "%s" str');
 
-   
   end
 
 
diff --git a/ocaml/src/domains/unrels.ml b/ocaml/src/domains/unrels.ml
index 30b28af1..5f588e74 100644
--- a/ocaml/src/domains/unrels.ml
+++ b/ocaml/src/domains/unrels.ml
@@ -17,7 +17,7 @@
  *)
 
 module L = Log.Make(struct let name = "unrels" end)
-         
+
 (* k-set of Unrel *)
 module Make(D: Unrel.T) =
   struct
@@ -29,14 +29,14 @@ module Make(D: Unrel.T) =
       | Val of ut list
 
     let init () = Val [U.empty, Log.History.new_ [] ""]
-                
+
     let bot = BOT
-            
+
     let is_bot m = m = BOT
 
     let imprecise_exn r =
       raise (Exceptions.Too_many_concrete_elements (Printf.sprintf "value of register %s is too much imprecise" (Register.name r)))
-      
+
     let value_of_register m r =
       match m with
       | BOT -> raise (Exceptions.Empty (Printf.sprintf "unrel.value_of_register:  environment is empty; can't look up register %s" (Register.name r)))
@@ -54,7 +54,7 @@ module Make(D: Unrel.T) =
            | None -> imprecise_exn r
            | Some v' -> v'
 
-         
+
     let string_of_register m r =
       match m with
       | BOT ->  raise (Exceptions.Empty (Printf.sprintf "string_of_register: environment is empty; can't look up register %s" (Register.name r)))
@@ -82,7 +82,7 @@ module Make(D: Unrel.T) =
        match m with
       | BOT -> BOT
       | Val m' -> Val (List.map (fun (u, ids) -> U.forget_lval lv u check_address_validity, ids) m')
-                
+
     let add_register r m =
       match m with
       | BOT -> BOT
@@ -92,14 +92,17 @@ module Make(D: Unrel.T) =
       match m with
       | BOT    -> ["_"]
       | Val m' ->
+        if !Config.loglevel > 2 then
          List.fold_left (fun acc (u, id') ->
-                              let msg = Log.History.get_msg id' in
-                              (Printf.sprintf "\n[node %d - unrel %d]\ndescription =  %s" id id' msg)::((U.to_string u)@acc)
-                             ) [] m'
+            let msg = Log.History.get_msg id' in
+            (Printf.sprintf "\n[node %d - unrel %d]\ndescription =  %s" id id' (String.trim   msg))::((U.to_string u)@acc)
+            ) [] m'
+        else
+          [""]
 
     let imprecise_value_of_exp e =
       raise (Exceptions.Too_many_concrete_elements (Printf.sprintf "concretisation of expression %s is too much imprecise" (Asm.string_of_exp e true)))
-      
+
     let value_of_exp m e check_address_validity =
       match m with
       | BOT -> raise (Exceptions.Empty "unrels.value_of_exp: environment is empty")
@@ -116,7 +119,7 @@ module Make(D: Unrel.T) =
            | None -> imprecise_value_of_exp e
            | Some v' -> v'
 
-                             
+
     (* auxiliary function that will join all set elements *)
     let merge m =
       L.info2 (fun p -> p "threshold on unrel number is exceeded: merging all the unrels into one (join)");
@@ -124,9 +127,9 @@ module Make(D: Unrel.T) =
       | [] -> []
       | u::tl ->
          let u', pred = List.fold_left (fun (u', pred) (u, id) -> U.join u' u, id::pred) (fst u, [snd u]) tl in
-         [u', Log.History.new_ pred "merge"]
-                           
-               
+         [u', Log.History.new_ pred ""]
+
+
     let set dst src m check_address_validity: (t * Taint.Set.t) =
       L.debug2 (fun p -> p "set %s <- %s" (Asm.string_of_lval dst true) (Asm.string_of_exp src true));
       match m with
@@ -146,9 +149,9 @@ module Make(D: Unrel.T) =
              BOT, Taint.Set.singleton Taint.BOT
          else
            Val mres, t
-         
-  
-               
+
+
+
     let set_lval_to_addr lv addrs m check_address_validity =
       match m with
       | BOT -> BOT, Taint.Set.singleton Taint.BOT
@@ -164,7 +167,7 @@ module Make(D: Unrel.T) =
            List.fold_left (fun acc (a, msg) ->
                let m' =
                  List.map (fun (u, prev_id) ->
-                     let u', t = U.set_lval_to_addr lv a u check_address_validity in                     
+                     let u', t = U.set_lval_to_addr lv a u check_address_validity in
                      taint := Taint.Set.add t !taint;
                      let id = Log.History.new_ [prev_id] msg in
                      u', id) m'
@@ -174,7 +177,7 @@ module Make(D: Unrel.T) =
          in
          Val m2, !taint
 
-  
+
     let remove_duplicates m1 m2 =
       let one_check ulist (u, id) =
         if List.exists (fun (u', _id') -> U.is_subset u' u && U.is_subset u u') ulist then
@@ -190,7 +193,7 @@ module Make(D: Unrel.T) =
       let m1' = filter m1 in
       let m2' = filter m2 in
       List.fold_left one_check m1' m2'
-      
+
     let join m1 m2 =
       match m1, m2 with
       | BOT, m | m, BOT -> m
@@ -211,7 +214,7 @@ module Make(D: Unrel.T) =
           let u' = U.meet (fst u1) (fst u2) in
           if List.exists (fun (u, _) -> U.is_subset u' u && U.is_subset u u') m then m
           else
-            let id = Log.History.new_ [snd u1; snd u2] "meet" in
+            let id = Log.History.new_ [snd u1; snd u2] "" in
               (u', id)::m
         with Exceptions.Empty _ ->
           bot := true;
@@ -241,10 +244,8 @@ module Make(D: Unrel.T) =
          let mm2 = merge m2' in
          match mm1, mm2 with
          | [], _ | _, [] -> Val ([])
-         | (u1, id1)::_, (u2, id2)::_ -> Val ([U.widen u1 u2, Log.History.new_ [id1 ; id2] "widen"])
+         | (u1, id1)::_, (u2, id2)::_ -> Val ([U.widen u1 u2, Log.History.new_ [id1 ; id2] ""])
 
-
-            
     let fold_on_taint m f =
       match m with
       | BOT -> BOT,  Taint.Set.singleton Taint.BOT
@@ -255,16 +256,16 @@ module Make(D: Unrel.T) =
                (u', id)::m, Taint.Set.add t' t) ([], Taint.Set.singleton Taint.U) m'
          in
          Val m', t'
-         
-    let set_memory_from_config a conf nb m check_address_validity: t * Taint.Set.t = 
+
+    let set_memory_from_config a conf nb m check_address_validity: t * Taint.Set.t =
       if nb > 0 then
         fold_on_taint m (U.set_memory_from_config a conf nb check_address_validity)
       else
         m, Taint.Set.singleton Taint.U
 
-         
+
     let set_register_from_config r conf m = fold_on_taint m (U.set_register_from_config r conf)
-         
+
     let taint_register_mask reg taint m = fold_on_taint m (U.taint_register_mask reg taint)
 
     let span_taint_to_register reg taint m = fold_on_taint m (U.span_taint_to_register reg taint)
@@ -274,7 +275,7 @@ module Make(D: Unrel.T) =
     let span_taint_to_addr a t m = fold_on_taint m (U.span_taint_to_addr a t)
 
     let taint_lval lv taint m check_address_validity = fold_on_taint m (U.taint_lval lv taint check_address_validity)
-                              
+
     let compare m check_address_validity e1 op e2 =
       L.debug2 (fun p -> p "compare: %s %s %s" (Asm.string_of_exp e1 true) (Asm.string_of_cmp op) (Asm.string_of_exp e2 true));
       match m with
@@ -282,7 +283,7 @@ module Make(D: Unrel.T) =
       | Val m' ->
          let bot = ref false in
          let mres, t = List.fold_left (fun (m', t) (u, msgs) ->
-                           try                            
+                           try
                              let ulist', tset' = U.compare u check_address_validity e1 op e2 in
                              List.fold_left (fun  m' u -> (u, msgs)::m') m' ulist', Taint.Set.singleton tset'
                            with Exceptions.Empty _ ->
@@ -307,7 +308,7 @@ module Make(D: Unrel.T) =
              try
                let addrs', t' = U.mem_to_addresses (fst u) e check_address_validity in
                Data.Address.Set.union addrs addrs', Taint.Set.add t' t
-             with _ -> addrs, t) (Data.Address.Set.empty, Taint.Set.singleton Taint.U) m' 
+             with _ -> addrs, t) (Data.Address.Set.empty, Taint.Set.singleton Taint.U) m'
 
     let taint_sources e m check_address_validity =
       match m with
@@ -330,7 +331,7 @@ module Make(D: Unrel.T) =
          match res with
          | Some o -> o
          | _ -> raise (Exceptions.Empty "Unrels.get_offset_from: undefined offset")
-            
+
     let get_bytes e cmp terminator (upper_bound: int) (sz: int) (m: t) check_address_validity =
           match m with
       | BOT -> raise (Exceptions.Empty "Unrels.get_bytes: environment is empty")
@@ -347,7 +348,7 @@ module Make(D: Unrel.T) =
                   else
                     raise (Exceptions.Empty "Unrels.get_bytes: incompatible set of bytes to return")
                 else
-                  raise (Exceptions.Empty "Unrels.get_bytes: incompatible set of bytes to return")       
+                  raise (Exceptions.Empty "Unrels.get_bytes: incompatible set of bytes to return")
              ) None m'
          in
          match res with
@@ -369,7 +370,7 @@ module Make(D: Unrel.T) =
                  match n with
                  | None -> Some n'
                  | Some n  ->
-                    if n = n' then Some n' 
+                    if n = n' then Some n'
                     else raise (Exceptions.Empty "diffrent lengths of  bytes copied in Unrels.copy_hex")
                in
                (u', msg)::acc, nn
@@ -392,7 +393,7 @@ module Make(D: Unrel.T) =
                  match n with
                  | None -> Some n'
                  | Some n  ->
-                    if n = n' then Some n' 
+                    if n = n' then Some n'
                     else raise (Exceptions.Empty "diffrent lengths of  bytes copied in Unrels.copy_int")
                in
                (u', msg)::acc, nn
@@ -404,10 +405,15 @@ module Make(D: Unrel.T) =
            | None -> raise (Exceptions.Empty "uncomputable length of  bytes copied in Unrels.copy_int")
          end
       | BOT -> BOT, 0
-             
+
     let print m arg sz check_address_validity =
+      L.info(fun p -> p "print-unrels");
       match m with
-      | Val m' -> List.iter (fun (u, _) -> U.print u arg sz check_address_validity) m'; m
+      | Val m' -> (
+        match m' with
+        | (u, _) :: _ -> U.print u arg sz check_address_validity
+        | _ ->  raise (Exceptions.Empty "Unrels.print: empty list")
+      ); m
       | BOT -> Log.Stdout.stdout (fun p -> p "_"); m
 
     let print_hex m src nb capitalise pad_option word_sz check_address_validity =
@@ -445,7 +451,7 @@ module Make(D: Unrel.T) =
        | BOT -> Log.Stdout.stdout (fun p -> p "_"); 0, BOT
        | Val m' ->
           match m' with
-          | [(u, msg)] ->
+          | (u, msg)::_ ->
              let len, u' = U.print_until u e terminator term_sz upper_bound with_exception pad_options check_address_validity in
              len, Val ([u', msg])
           | _ -> raise (Exceptions.Too_many_concrete_elements "U.print_until: implemented only for one unrel only")
@@ -457,17 +463,8 @@ module Make(D: Unrel.T) =
 
     let print_chars m src nb pad_options check_address_validity =
       match m with
-      | BOT ->
-         Log.Stdout.stdout (fun p -> p "_");
-         BOT, 0
-         
-      | Val ([u, msg]) ->
-         let u', len = U.print_chars u src nb pad_options check_address_validity in
-         Val ([u', msg]), len
-
-      | _ -> raise (Exceptions.Too_many_concrete_elements "U.print_chars: implemented only for one unrel only")
-         
-     
+      | Val m' -> Val (List.map (fun (u, msg) -> U.print_chars u src nb pad_options check_address_validity, msg) m')
+      | BOT -> Log.Stdout.stdout (fun p -> p "_"); BOT
 
     let copy_register r dst src =
       match src with
diff --git a/ocaml/src/domains/vector.ml b/ocaml/src/domains/vector.ml
index 2ad105ac..f5907175 100644
--- a/ocaml/src/domains/vector.ml
+++ b/ocaml/src/domains/vector.ml
@@ -56,11 +56,11 @@ sig
     (** abstract join *)
     val join: t -> t -> t
 
-    (** logical or on taint component only 
-        this function should only be called when the value of the 
+    (** logical or on taint component only
+        this function should only be called when the value of the
         two parameters are the same. No check done *)
     val taint_logor: t -> t -> t
-      
+
     (** abstract meet *)
     val meet: t -> t -> t
 
@@ -159,7 +159,7 @@ module type T =
 sig
     (** abstract data type *)
     type t
-      
+
     (** top on sz bit-width *)
     val top: int -> t
 
@@ -258,7 +258,7 @@ end
 module Make(V: Val) =
   (struct
     type t = V.t array (** bit order is big endian, ie v[0] is the most significant bit and v[Array.length v - 1] the least significant *)
-      
+
     let top sz = Array.make sz V.top
 
     let exists p v =
@@ -266,7 +266,7 @@ module Make(V: Val) =
         Array.iter (fun b -> if p b then raise Exit) v;
         false
       with Exit -> true
-        
+
     let exist2 p v1 v2 =
       let n = min (Array.length v1) (Array.length v2) in
       try
@@ -277,8 +277,8 @@ module Make(V: Val) =
       with
       | Exit -> true
       | _    -> false
-         
-         
+
+
     let for_all2 p v1 v2 =
       try
         for i = 0 to (Array.length v1)-1 do
@@ -287,15 +287,16 @@ module Make(V: Val) =
         true
       with
       | _-> false
-         
+
     let v_to_z conv v =
+      (* L.info(fun p -> p "V_to_Z"); *)
       let z = ref Z.zero in
       for i = 0 to (Array.length v) - 1 do
         let n = conv v.(i) in
         z := Z.add n (Z.shift_left !z 1)
       done;
       !z
-            
+
     let to_char (v: t): char =
       let l = Array.length v in
       if l <> 8 then
@@ -308,13 +309,13 @@ module Make(V: Val) =
           done;
           Char.chr !c
         end
-          
+
     let size v = Array.length v
-      
+
     let to_z v = v_to_z V.to_z v
     (* this function may raise an exception if one of the bits cannot be converted into a Z.t integer (one bit at BOT or TOP) *)
     let to_word conv v = Data.Word.of_int (v_to_z conv v) !Config.address_sz
-      
+
     let extract_strings v =
       let v' =
         if exists V.is_top v then
@@ -340,7 +341,7 @@ module Make(V: Val) =
           "0b"^Bytes.to_string taint_bytes
       in
       v', t
-        
+
     let to_string v =
       let v', t = extract_strings v in
       if String.compare t "0x0" == 0 then v'
@@ -358,20 +359,20 @@ module Make(V: Val) =
           v.(i) <- f v1.(i) v2.(i)
         done;
         v
-          
+
     let to_strings v = extract_strings v
-      
+
     let concat v1 v2 = Array.append v1 v2
-      
+
     let join v1 v2 = map2 V.join v1 v2
-      
+
     let meet v1 v2 = map2 V.meet v1 v2
-      
+
     let widen v1 v2 =
       if Z.compare (to_z v1) (to_z v2) <> 0 then
         raise (Exceptions.Too_many_concrete_elements (Printf.sprintf "vector.widen with different vectors (v1=%s v2=%s)" (to_string v1) (to_string v2)))
       else v1
-        
+
     (* common utility to add and sub *)
     let core_add_sub op v1 v2 =
       let n = Array.length v1 and lv2 = (Array.length v2) in
@@ -397,8 +398,8 @@ module Make(V: Val) =
           | None   -> carry_borrow := c' (* correct as we know that we cannot have both cpred = Some ... and c' = Some ... *)
         done;
         v
-          
-          
+
+
     let lt_core v1 v2 final =
       let lv1 = Array.length v1 in
       let lv2 = Array.length v2 in
@@ -418,7 +419,7 @@ module Make(V: Val) =
           (to_string v1) (if final then "<=" else "<")
           (to_string v2) res);
         res
-          
+
     let lt v1 v2 = lt_core v1 v2 false
     let leq v1 v2 = lt_core v1 v2 true
     let gt v1 v2 = lt v2 v1
@@ -437,29 +438,30 @@ module Make(V: Val) =
       | Asm.LEQ -> leq v1 v2
       | Asm.GT -> gt v1 v2
       | Asm.GEQ -> geq v1 v2
-         
+
+    (* let taint_sources v =
+      Array.fold_left (fun acc elt -> Taint.logor acc (V.get_taint elt)) (Taint.U) v *)
+
     let add v1 v2 =
       let res = core_add_sub V.add v1 v2 in
-      L.debug2 (fun p -> p "add(%s, %s) = %s"
-        (to_string v1) (to_string v2) (to_string res));
       res
-        
+
     let sub v1 v2 = core_add_sub V.sub v1 v2
-      
+
     let xor v1 v2 =
       let res = map2 V.xor v1 v2 in
       L.debug2 (fun p -> p "xor(%s, %s) = %s"
         (to_string v1) (to_string v2) (to_string res));
       res
-        
+
     let lognot v = Array.map V.lognot v
-      
+
     let neg v =
       let n = Array.length v in
       let one = Array.make n V.zero in
       one.(n-1) <- V.one;
       add (lognot v) one
-        
+
     let logand v1 v2 =
       let lv1 = (Array.length v1) and lv2 = (Array.length v2) in
       if lv1 <> lv2 then
@@ -481,7 +483,7 @@ module Make(V: Val) =
         L.debug2 (fun p -> p "logor(%s, %s)=%s"
           (to_string v1) (to_string v2) (to_string res));
         res
-          
+
     let sign_extend v i =
       let n = Array.length v in
       if n >= i then
@@ -499,7 +501,7 @@ module Make(V: Val) =
           done;
           v'
         end
-          
+
     let truncate v new_sz =
       let sz = Array.length v in
       L.debug (fun p -> p "truncate((%d)%s, %d)" sz (to_string v) new_sz);
@@ -512,7 +514,7 @@ module Make(V: Val) =
           res.(i) <- v.(i+sz-new_sz)
         done;
         res
-          
+
     let zero_extend v new_sz =
       let sz = Array.length v in
       L.debug2 (fun p -> p "zero_extend((%d)%s, %d)" sz (to_string v) new_sz);
@@ -537,7 +539,7 @@ module Make(V: Val) =
       L.debug2 (fun p -> p "ishl(%s, %d) = %s"
         (to_string v) shift (to_string res));
       res
-        
+
     let ishr v shift pad =
       let v_len = Array.length v in
       let res = Array.make v_len pad in
@@ -547,7 +549,7 @@ module Make(V: Val) =
       L.debug2 (fun p -> p "ishr(%s, %d) = %s"
         (to_string v) shift (to_string res));
       res
-        
+
     let irotate v shift =
       let v_len = Array.length v in
       let res = Array.make v_len V.zero in
@@ -557,8 +559,8 @@ module Make(V: Val) =
       L.debug2 (fun p -> p "irotate(%s,%d)=%s"
         (to_string v) shift (to_string res));
       res
-        
-        
+
+
     let shift_count_to_int v =
       let z_shift_count = to_z v in
       try
@@ -567,24 +569,24 @@ module Make(V: Val) =
         raise (Exceptions.Too_many_concrete_elements
                  (Printf.sprintf "vector.shr: shift count overflow: %s"
                     (Z.to_string z_shift_count)))
-          
-          
+
+
     let shl v1 v2 =
       let shift_count = shift_count_to_int v2 in
       ishl v1 shift_count
-        
+
     let shr v1 v2 =
       let shift_count = shift_count_to_int v2 in
       ishr v1 shift_count V.zero (* pad with zero *)
-        
+
     let _ashr v1 v2 =
       let shift_count = shift_count_to_int v2 in
       ishr v1 shift_count v1.(0) (* pad with high bit *)
-        
+
     let _rol v1 v2 =
       let shift_count = shift_count_to_int v2 in
       irotate v1 shift_count
-        
+
     let _ror v1 v2 =
       let shift_count = shift_count_to_int v2 in
       irotate v1 (-shift_count)
@@ -595,14 +597,14 @@ module Make(V: Val) =
       let nn   = 2*n in
       let v2_ext = zero_extend v2 nn    in
       let res = ref (Array.make nn V.zero) in
-      
+
       for i = 0 to n-1 do
         let v2_ext_shift = ishl v2_ext (n-i-1) in
         let v2_ext_shift_mul = Array.map (V.logand v1.(i)) v2_ext_shift in
         res := add !res v2_ext_shift_mul
       done;
       !res
-        
+
     let imul v1 v2 =
       L.debug2 (fun p -> p "imul((%d)%s, (%d)%s)"
         (Array.length v1) (to_string v1) (Array.length v2) (to_string v2));
@@ -615,7 +617,7 @@ module Make(V: Val) =
       let res = Array.sub fullres (v1_len*2) (v1_len*2) in
       L.debug2 (fun p -> p "imul return %s" (to_string res));
       res
-        
+
     (** return v1 / v2, modulo of v1 / v2 *)
     let core_div v1 v2 =
       let lv1   = Array.length v1    in
@@ -655,7 +657,7 @@ module Make(V: Val) =
               (Array.length !rem) (to_string !rem));
             quo,!rem
         end
-          
+
     let is_neg v1 =
       V.is_one v1.(0) || V.is_top v1.(0)
 
@@ -695,28 +697,28 @@ module Make(V: Val) =
       | Asm.IMod -> imodulo v1 v2
       | Asm.Shl -> shl v1 v2
       | Asm.Shr -> shr v1 v2
-         
-         
+
+
     let unary op v =
       match op with
       | Asm.Not       -> lognot v
       | Asm.SignExt i -> sign_extend v i
       | Asm.ZeroExt i -> let res = zero_extend v i in L.debug2 (fun p -> p
         "zero_extend new length : %d" (Array.length res)); res
-        
+
     let untaint v = Array.map V.untaint v
-      
+
     let taint v = Array.map V.taint v
-      
+
     let span_taint v t = Array.map (V.update_taint t) v
-      
+
     let get_minimal_taint v =
       Array.fold_left (fun acc v -> Taint.min acc (V.get_taint v)) Taint.U v
-        
-        
+
+
     let nth_of_z_as_val v i = if Z.testbit v i then V.one else V.zero
     let nth_of_z v i = if Z.testbit v i then Z.one else Z.zero
-        
+
 
     (* real implementation of 'of_word' *)
     let of_word_real w =
@@ -744,12 +746,13 @@ module Make(V: Val) =
           Hashtbl.add !const_htbl w r;
           r
      end
-        
+
     let to_addresses r v =
+      L.debug2(fun p -> p "To Address V : %s" (to_string v));
       Data.Address.Set.singleton (r, to_word V.to_z v)
-      
+
     let is_subset v1 v2 = for_all2 V.is_subset v1 v2
-      
+
     let of_config c n =
       let v  = Array.make n V.top in
       let n' = n-1                in
@@ -800,11 +803,11 @@ module Make(V: Val) =
              else
                v.(n'-i) <- V.taint_logor v.(n'-i) v'
            done;
-           Taint.S (Taint.SrcSet.singleton (Taint.Src.Tainted tid)) 
-             
+           Taint.S (Taint.SrcSet.singleton (Taint.Src.Tainted tid))
+
         | Config.TBytes_Mask (b, m, tid) ->
            let get_byte s i = (Z.of_string_base 16 (String.sub s (i/4) 1)) in
-           for i = 0 to n' do           
+           for i = 0 to n' do
              if Z.testbit m i then
                let v' = V.forget_taint_src v.(n'-i) tid in
                if is_first then
@@ -819,7 +822,7 @@ module Make(V: Val) =
                  v.(n'-i) <- V.taint_logor v.(n'-i) v'
            done;
            Taint.S (Taint.SrcSet.singleton (Taint.Src.Tainted tid))
-             
+
         | Config.Taint (b, tid) ->
            for i = 0 to n' do
              let v' = V.taint_of_z (nth_of_z b i) v.(n'-i) tid in
@@ -830,7 +833,7 @@ module Make(V: Val) =
            done;
           if Z.compare b Z.zero = 0 then Taint.U
           else Taint.S (Taint.SrcSet.singleton (Taint.Src.Tainted tid))
-            
+
         | Config.Taint_all tid ->
            let n' =n-1 in
            for i = 0 to n' do
@@ -841,7 +844,7 @@ module Make(V: Val) =
                v.(n'-i) <- V.taint_logor v.(n'-i) v'
            done;
            Taint.S (Taint.SrcSet.singleton (Taint.Src.Tainted tid))
-             
+
         | Config.Taint_none ->
            let n' =n-1 in
            for i = 0 to n' do
@@ -852,7 +855,7 @@ module Make(V: Val) =
                v.(n'-i) <- V.taint_logor v.(n'-i) v'
            done;
            Taint.U
-             
+
         | Config.TMask (b, m, tid) ->
            let n' = n-1 in
            for i = 0 to n' do
@@ -867,7 +870,7 @@ module Make(V: Val) =
              else
                let v' = V.forget_taint_src v.(n'-i) tid in
                if is_first then
-                 v.(n'-i) <- v' 
+                 v.(n'-i) <- v'
                else
                v.(n'-i) <- V.taint_logor v.(n'-i) v'
            done;
@@ -882,7 +885,7 @@ module Make(V: Val) =
         v, taint'
       else
         v, Taint.U
-        
+
     let forget v opt =
       L.debug (fun (p: ('a, unit, string) format -> 'a) ->
         match opt with
@@ -925,6 +928,7 @@ module Make(V: Val) =
               v
             end
 
+
         let extract v low up =
           L.debug2 (fun p -> p "extract(%s, %d, %d), sz : %d" (to_string v) low up (Array.length v));
           let v' = Array.make (up-low+1) V.top in
@@ -951,6 +955,6 @@ module Make(V: Val) =
         let get_taint = taint_sources
 
         let forget_taint v =
-          Array.map (V.update_taint Taint.TOP) v       
-          
+          Array.map (V.update_taint Taint.TOP) v
+
     end: T)
diff --git a/ocaml/src/fixpoint/backward.ml b/ocaml/src/fixpoint/backward.ml
deleted file mode 100644
index 8f864fd0..00000000
--- a/ocaml/src/fixpoint/backward.ml
+++ /dev/null
@@ -1,198 +0,0 @@
-(*
-    This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
-
-    BinCAT is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Affero General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or (at your
-    option) any later version.
-
-    BinCAT is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Affero General Public License for more details.
-
-    You should have received a copy of the GNU Affero General Public License
-    along with BinCAT.  If not, see <http://www.gnu.org/licenses/>.
- *)
-
-
-module L = Log.Make(struct let name = "backward" end)
-open Asm
-   
-  
-module Make(D: Domain.T)(Cfa: Cfa.T with type domain = D.t)(Decoder: Decoder.T)
-         (Core:
-            sig
-              val cfa_iteration: (Cfa.t -> Cfa.State.t -> Data.Address.t -> Cfa.State.t list -> Cfa.State.t list) ->
-                                 (Cfa.t -> Cfa.State.t -> Cfa.State.t list) ->
-                                 (Cfa.t -> Cfa.State.t -> Cfa.State.t -> Cfa.State.t) ->
-                                 Cfa.t -> Cfa.State.t -> (Cfa.t -> unit) -> Cfa.t
-                
-              val update_abstract_value: Cfa.t -> Cfa.State.t -> (Cfa.State.t -> D.t) ->
-                                         Data.Address.t -> (Cfa.t -> Cfa.State.t -> Data.Address.t -> Cfa.State.t list) ->
-                                         Cfa.State.t list
-            end) =
-struct
-           
-    let shift_and_add shift len =
-      let one = Const (Data.Word.one len) in
-      let one' = Const (Data.Word.of_int (Z.of_int (len-1)) len) in
-      let shifted_one = BinOp (Asm.Shl, one, one') in
-      BinOp (Asm.Add, shift, shifted_one)
-      
-    let back_add_sub op dst e1 e2 d =
-      match e1, e2 with
-      | Lval lv1, Lval lv2 ->
-         if Asm.equal_lval lv1 lv2 then
-           if op = Asm.Sub then
-             let len = Asm.lval_length lv1 in
-             let shift = BinOp (Asm.Shr, Lval dst, Const (Data.Word.of_int (Z.of_int 1) len)) in
-             let d', taint =
-               try
-                 if Z.compare Z.one (D.value_of_exp d (Decoder.overflow_expression())) = 0 then
-                   D.set lv1 (shift_and_add shift len) d
-                 else
-                   D.set lv1 shift d
-               with _ ->
-                 let d1, taint1 = D.set lv1 shift d in
-                 let d2, taint2 = D.set lv1 (shift_and_add shift len) d in 
-                 D.join d1 d2, Taint.Set.union taint1 taint2
-             in
-             if Asm.with_lval dst (Lval lv1) then
-               d', taint
-             else D.forget_lval dst d', taint
-           else
-             D.forget_lval dst d, Taint.Set.singleton Taint.TOP
-         else
-           if (Asm.with_lval dst e1) || (Asm.with_lval dst e2) then 
-             D.set lv1 (BinOp (op, Lval dst, e2)) d
-           else D.forget_lval dst d, Taint.Set.singleton Taint.TOP
-        
-      | Lval lv, Const c | Const c, Lval lv ->
-         let d', taint = D.set lv (BinOp (op, Lval dst, Const c)) d in
-         if Asm.with_lval dst (Lval lv) then
-           d', taint
-         else D.forget_lval dst d', taint
-         
-      | Lval lv, e | e, Lval lv ->
-         if (Asm.with_lval dst e1) || (Asm.with_lval dst e2) then
-           D.set lv (BinOp (op, Lval dst, e)) d
-         else D.forget_lval dst d, Taint.Set.singleton Taint.TOP
-        
-      | _ ->  D.forget_lval dst d, Taint.Set.singleton Taint.TOP
-            
-            
-    let back_set (dst: Asm.lval) (src: Asm.exp) (d: D.t): (D.t * Taint.Set.t) =
-      match src with
-      | Lval lv ->
-         let d', taint = D.set lv (Lval dst) d in
-         if Asm.equal_lval lv dst then d', taint
-         else D.forget_lval dst d', taint
-         
-      | UnOp (Not, Lval lv) ->
-         let d', taint = D.set lv (UnOp (Not, Lval dst)) d in
-         if Asm.equal_lval lv dst then d', taint
-         else D.forget_lval dst d, taint
-         
-      | BinOp (Add, e1, e2)  -> back_add_sub Sub dst e1 e2 d
-      | BinOp (Sub, e1, e2) -> back_add_sub Add dst e1 e2 d
-                             
-      | _ -> D.forget_lval dst d, Taint.Set.singleton Taint.TOP
-           
-    (** backward transfert function on the given abstract value *)
-    let process (branch: bool option) (d: D.t) (stmt: Asm.stmt) : (D.t * Taint.Set.t) =
-      (* BE CAREFUL: this function does not apply to nested if statements *)
-      let rec back d stmt =
-        L.debug (fun p -> p "back of %s.........." (Asm.string_of_stmt stmt true));
-        match stmt with
-        | Call _
-        | Return
-        | Jmp _
-        | Nop -> d, Taint.Set.singleton Taint.U
-        | Directive (Forget _) -> d, Taint.Set.singleton Taint.U
-        | Directive (Remove r) -> D.add_register r d, Taint.Set.singleton Taint.U
-        | Directive (Taint _) -> D.forget d, Taint.Set.singleton Taint.TOP
-        | Directive (Type _) -> D.forget d, Taint.Set.singleton Taint.U
-        | Directive (Unroll _) -> d, Taint.Set.singleton Taint.U
-        | Directive (Unroll_until _) -> d, Taint.Set.singleton Taint.U
-        | Directive Default_unroll -> d, Taint.Set.singleton Taint.U
-        | Directive (Stub _) -> d, Taint.Set.singleton Taint.U
-        | Directive (Skip _) -> d, Taint.Set.singleton Taint.U
-        | Directive (Handler _) -> d, Taint.Set.singleton Taint.U
-        | Set (dst, src) -> back_set dst src d
-        | Assert (_bexp, _msg) -> d, Taint.Set.singleton Taint.U (* TODO *)
-        | If (_e, istmts, estmts) ->
-           match branch with
-           | Some true ->
-              List.fold_left (fun (d, b) s -> let d', b' = back d s in d', Taint.Set.union b b'
-                ) (d, Taint.Set.singleton Taint.U) (List.rev istmts)
-             
-           | Some false ->
-              List.fold_left (fun (d, b) s -> let d', b' = back d s in d', Taint.Set.union b b'
-                ) (d, Taint.Set.singleton Taint.U) (List.rev estmts)
-
-           | None -> D.forget d, Taint.Set.singleton Taint.U
-      in                                                                                                         
-      back d stmt
-
-    let back_update_abstract_value (g:Cfa.t) (v: Cfa.State.t) (ip: Data.Address.t) (pred: Cfa.State.t): Cfa.State.t list =
-      let backward _g v _ip =                                     
-        let start_v =  
-	      match v.Cfa.State.back_v with 
-	      | Some d -> d
-	      | None -> raise (Exceptions.Empty "undefined abstract value used in backward mode")
-	    in 
-	    let d', taint_sources =
-          List.fold_left (fun (d, b) s ->
-              let d', b' = process v.Cfa.State.branch d s in
-              d', Taint.Set.union b b'
-            ) (start_v, Taint.Set.singleton Taint.U) (List.rev pred.Cfa.State.stmts)
-        in
-        let v' = D.meet pred.Cfa.State.v d' in
-        begin
-          match pred.Cfa.State.back_v, pred.Cfa.State.back_taint_sources with
-          | None, None -> 
-             pred.Cfa.State.back_v <- Some v';
-             pred.Cfa.State.back_taint_sources <- Some taint_sources
-             
-          | Some v2, Some t2 -> 
-             pred.Cfa.State.back_v <- Some (D.join v' v2);
-             pred.Cfa.State.back_taint_sources <- Some (Taint.Set.union t2 taint_sources)
-
-          | _, _ -> 
-             raise (Exceptions.Error "inconsistent state in backward mode")
-        end;
-        [pred]
-      in
-      let get_field v =
-        match v.Cfa.State.back_v with
-        | Some d -> d
-        | None -> raise (Exceptions.Error "Illegal call to get_field in interpreter")
-      in
-      Core.update_abstract_value g v get_field ip backward
-
-
-    let back_unroll g v pred =
-      if v.Cfa.State.final then
-        begin
-          v.Cfa.State.final <- false;
-          let new_pred = Cfa.copy_state g v in
-          new_pred.Cfa.State.back_loop <- true;
-          Cfa.remove_successor g pred v;
-          Cfa.add_state g new_pred;
-          Cfa.add_successor g pred new_pred;
-          Cfa.add_successor g new_pred v;
-          new_pred
-        end
-      else
-        pred
-      
-      
-    let from_cfa (g: Cfa.t) (s: Cfa.State.t) (dump: Cfa.t -> unit): Cfa.t =
-      Core.cfa_iteration (fun g v ip vert -> back_update_abstract_value g v ip (List.hd vert))
-        (fun g v -> [Cfa.pred g v]) back_unroll g s dump
-      
-
-
-  end
diff --git a/ocaml/src/fixpoint/forward.ml b/ocaml/src/fixpoint/forward.ml
deleted file mode 100644
index 3d762093..00000000
--- a/ocaml/src/fixpoint/forward.ml
+++ /dev/null
@@ -1,784 +0,0 @@
-(*
-    This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
-
-    BinCAT is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Affero General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or (at your
-    option) any later version.
-
-    BinCAT is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Affero General Public License for more details.
-
-    You should have received a copy of the GNU Affero General Public License
-    along with BinCAT.  If not, see <http://www.gnu.org/licenses/>.
-*)
-
-module L = Log.Make(struct let name = "forward" end)
-open Asm
-
-
- 
- 
-module Make(D: Domain.T)(Cfa: Cfa.T with type domain = D.t)(Stubs: Stubs.T with type domain_t = D.t)(Decoder: Decoder.T)
-         (Core:
-            sig
-              type ctx_t
-              val unroll_nb: int option ref
-              val fun_unroll_tbl: (Data.Address.t, int) Hashtbl.t
-              val unroll_tbl: ((Data.Address.t, int * D.t) Hashtbl.t) ref
-              val cfa_iteration: (Cfa.t -> Cfa.State.t -> Data.Address.t -> Cfa.State.t list -> Cfa.State.t list) ->
-                                 (Cfa.t -> Cfa.State.t -> Cfa.State.t list) ->
-                                 (Cfa.t -> Cfa.State.t -> Cfa.State.t -> Cfa.State.t) ->
-                                 Cfa.t -> Cfa.State.t -> (Cfa.t -> unit) -> Cfa.t
-              val update_abstract_value: Cfa.t -> Cfa.State.t -> (Cfa.State.t -> D.t) ->
-                                         Data.Address.t -> (Cfa.t -> Cfa.State.t -> Data.Address.t -> Cfa.State.t list) ->
-                                         Cfa.State.t list
-              val init: unit -> ctx_t
-              val parse: string -> Cfa.t -> ctx_t -> Cfa.State.t -> Data.Address.t -> Cfa.oracle -> (Cfa.State.t * Data.Address.t * ctx_t) option
-              val filter_vertices: bool -> Cfa.t -> Cfa.State.t list -> Cfa.State.t list
-            end) =
-  struct
-    type fun_stack_t = ((string * string) option * Data.Address.t * Cfa.State.t * (Data.Address.t, int * D.t) Hashtbl.t * Asm.stmt list) list ref
-
-    exception Jmp_exn
-    exception Handler of int * Data.Address.t
-                      
-    (** returns true whenever the given list of statements has a jump stmt (Jmp, Call, Return) *)
-    let rec has_jmp stmts =
-      match stmts with
-      | [] -> false
-      | s::stmts' ->
-         match s with
-         | Call _ | Return  | Jmp _ -> true
-         | If (_, tstmts, estmts) -> (has_jmp tstmts) || (has_jmp estmts)
-         | _ -> (has_jmp stmts');;
-              
-
-    (** opposite the given comparison operator *)
-    let inv_cmp (cmp: Asm.cmp): Asm.cmp =
-      match cmp with
-      | EQ  -> NEQ
-      | NEQ -> EQ
-      | LT  -> GEQ
-      | GEQ -> LT
-      | LEQ -> GT
-      | GT  -> LEQ;;
-             
-    let restrict (d: D.t) (e: Asm.bexp) (b: bool): (D.t * Taint.Set.t) =
-      L.debug (fun p -> p "restrict: e=%s b=%B" (Asm.string_of_bexp e true) b);
-      let rec process e b =
-        match e with
-        | BConst b' ->
-           if b = b' then d, Taint.Set.singleton Taint.U
-           else D.bot, Taint.Set.singleton Taint.BOT
-          
-        | BUnOp (LogNot, e) -> process e (not b)
-                             
-        | BBinOp (LogOr, e1, e2) ->
-           let v1, taint1 = process e1 b in
-           let v2, taint2 = process e2 b in
-           let taint_sources =
-             if b then Taint.Set.union taint1 taint2
-             else Taint.Set.inter taint1 taint2
-           in
-           if b then D.join v1 v2, taint_sources
-           else D.meet v1 v2, taint_sources
-             
-        | BBinOp (LogAnd, e1, e2) ->
-           let v1, taint1 = process e1 b in
-           let v2, taint2 = process e2 b in
-           let taint_sources =
-             if b then Taint.Set.inter taint1 taint2
-             else Taint.Set.union taint1 taint2
-           in
-           if b then D.meet v1 v2, taint_sources
-           else D.join v1 v2, taint_sources
-           
-        | Asm.Cmp (cmp, e1, e2) ->
-           let cmp' = if b then cmp else inv_cmp cmp in
-           D.compare d e1 cmp' e2
-      in
-      process e b;;
-      
-    let unroll_wrapper (f: unit -> int): unit =
-      try
-        match !Core.unroll_nb with
-        | Some _ -> ()
-        | None ->
-           let n = max (f ()) !Config.unroll in
-           Core.unroll_nb := Some n;
-           L.analysis (fun p -> p "automatic loop unrolling detection. Computed value is 0x%x" n)
-      with _ -> ();;
-              
-    let rec process_value (ip: Data.Address.t) (d: D.t) (s: Asm.stmt) (fun_stack: fun_stack_t) (node_id: int): D.t * Taint.Set.t =
-      L.debug2 (fun p -> p "process_value VVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\n%s\n---------\n%s\n---------"
-                           (String.concat " " (D.to_string d node_id)) (Asm.string_of_stmt s true));
-      try
-        let res, tainted =
-          match s with
-          | Nop -> d, Taint.Set.singleton Taint.U
-          | If (e, then_stmts, else_stmts) -> process_if ip d e then_stmts else_stmts fun_stack node_id
-          | Set (dst, src) -> D.set dst src d
-          | Directive (Remove r) ->
-             let d' = D.remove_register r d in
-             Register.remove r;
-             d', Taint.Set.singleton Taint.U
-             
-          | Directive (Forget lval) -> D.forget_lval lval d, Taint.Set.singleton Taint.U
-          | Directive (Unroll (e, bs)) ->
-             begin
-               try
-                 let f () = min ((Z.to_int (D.value_of_exp d e)) + 1) bs in
-                 unroll_wrapper f
-               with _ -> ()
-             end;
-             d, Taint.Set.singleton Taint.U
-             
-          | Directive (Default_unroll) ->
-             L.analysis (fun p -> p "set unroll parameter to its default value");
-             Core.unroll_nb := None;
-             d, Taint.Set.singleton Taint.U
-             
-          | Asm.Directive (Asm.Unroll_until (addr, cmp, terminator, upper_bound, sz)) ->
-             begin
-               try
-                 let f () =
-                   D.get_offset_from addr cmp terminator upper_bound sz d
-                 in
-                 unroll_wrapper f;
-               with _ -> ()
-             end;
-             d, Taint.Set.singleton Taint.U
-             
-          | Directive (Taint (e, lv)) ->
-             begin
-               match lv with
-               | V (T r) ->
-                  begin
-                    match e with
-                    | None ->
-                       let taint_src = Taint.new_src () in
-                       Hashtbl.add Dump.taint_src_tbl taint_src (Dump.R r);
-                       let mask = Config.Taint_all taint_src in
-                       D.taint_register_mask r mask d
-                    | Some c ->
-                       let taints = D.taint_sources c d in
-                       let taint' = Taint.Set.fold Taint.logor taints Taint.U in
-                       (* TODO: could be more precise here  but  taint_sources should be inlined in span_taint_to_register *)
-                       D.span_taint_to_register r taint' d
-                  end
-                 
-               | M (_, 8) ->
-                  begin
-                    try
-                      match Data.Address.Set.elements (fst (D.mem_to_addresses d (Lval lv))) with
-                      | [a] ->
-                         begin
-                           match e with
-                           | None ->
-                              let taint_src = Taint.new_src () in
-                              Hashtbl.add Dump.taint_src_tbl taint_src (Dump.M (a, 8));
-                              D.taint_address_mask a [Config.Taint (Z.of_int 0xff, taint_src)] d
-                           | Some c ->
-                              let taints = D.taint_sources c d  in
-                              let taint' = Taint.Set.fold Taint.logor taints Taint.U in
-                              (* TODO/ same remark on precision *)
-                              D.span_taint_to_addr a taint' d
-                         end
-                      | _ -> raise Exit
-                    with _ -> L.analysis (fun p -> p "Tainting directive ignored"); d, Taint.Set.singleton Taint.U
-                  end
-               | _ -> L.analysis (fun p -> p "Tainting directive for %s ignored" (Asm.string_of_lval lv false)); d, Taint.Set.singleton Taint.U
-             end
-          | Directive (Type (lv, t)) -> D.set_type lv t d, Taint.Set.singleton Taint.U
-                                      
-          | Directive (Skip (f, call_conv)) as skip_statement ->
-             L.analysis (fun p -> p "Skipping %s" (Asm.string_of_fun f));
-             (* TODO: optimize to avoid type switching *)
-             let f' =
-               match f with
-               | Asm.Fun_name s -> Config.Fun_name s
-               | Asm.Fun_addr a -> Config.Fun_addr (Data.Address.to_int a)
-             in                                   
-             let d',  taint, cleanup_stmts = Stubs.skip d f' call_conv in
-             let d', taint' =
-               Log.Trace.trace (Data.Address.global_of_int (Z.of_int 0))  (fun p -> p "%s" (string_of_stmts (skip_statement :: cleanup_stmts) true));
-               List.fold_left (fun (d, t) stmt ->
-                   let dd, tt = process_value ip d stmt fun_stack node_id in
-                   dd, Taint.Set.union t tt) (d', taint) cleanup_stmts
-             in
-             d', taint'
-             
-          | Directive (Stub (fun_name, call_conv)) as stub_statement ->
-             let prev_ip =
-               try
-                 let _, _, v, _, _ = List.hd !fun_stack in
-                 Some v.Cfa.State.ip
-               with Failure _ -> None
-             in
-             let d', taint', cleanup_stmts = Stubs.process ip prev_ip d fun_name call_conv in
-             let d', taint' =
-               Log.Trace.trace (Data.Address.global_of_int (Z.of_int 0))  (fun p -> p "%s" (string_of_stmts (stub_statement :: cleanup_stmts) true));
-               List.fold_left (fun (d, t) stmt ->
-                   let dd, tt = process_value ip d stmt fun_stack node_id in
-                   dd, Taint.Set.union t tt) (d', taint') cleanup_stmts
-             in
-             d', taint'
-             
-          | Directive (Handler (sig_nb, addr)) -> raise (Handler (sig_nb, addr))               
-               
-          | _ -> raise Jmp_exn
-               
-        in
-        res, tainted
-      with Exceptions.Empty _ -> D.bot, Taint.Set.singleton Taint.BOT
-                               
-    and process_if (ip: Data.Address.t) (d: D.t) (e: Asm.bexp) (then_stmts: Asm.stmt list) (else_stmts: Asm.stmt list) fun_stack (node_id: int) =
-      if has_jmp then_stmts || has_jmp else_stmts then
-        raise Jmp_exn
-      else
-        let dt, bt = List.fold_left (fun (d, b) s -> let d', b' = process_value ip d s fun_stack node_id in d', Taint.Set.union b b') (restrict d e true) then_stmts in
-        let de, be = List.fold_left (fun (d, b) s -> let d', b' = process_value ip d s fun_stack node_id in d', Taint.Set.union b b') (restrict d e false) else_stmts in
-        D.join dt de, Taint.Set.union bt be;;
-        
-    let forward_process (ip: Data.Address.t) (d: D.t) (stmt: Asm.stmt) (branch: bool option) (node_id: int): (D.t * Taint.Set.t) =
-      (* function stack *)
-      let fun_stack = ref [] in
-      let rec forward (d: D.t) (stmt: Asm.stmt): (D.t * Taint.Set.t) =
-        match stmt with
-        | Asm.Nop
-        | Asm.Directive (Asm.Forget _)
-        | Asm.Directive (Asm.Remove _)
-        | Asm.Directive (Asm.Taint _)
-        | Asm.Directive (Asm.Type _)
-        | Asm.Directive (Asm.Unroll _)
-        | Asm.Directive (Asm.Stub _)
-        | Asm.Directive (Asm.Skip _)
-        | Asm.Directive (Asm.Handler _)
-        | Asm.Directive (Asm.Unroll_until _)
-        | Asm.Directive Asm.Default_unroll
-        | Asm.Jmp (Asm.A _)
-        | Asm.Return
-        | Asm.Call (Asm.A _) -> d, Taint.Set.singleton Taint.U
-        | Asm.Set (dst, src) -> D.set dst src d
-        | Assert (_bexp, _msg) -> d, Taint.Set.singleton Taint.U (* TODO *)
-        | Asm.If (e, istmts, estmts) ->
-           begin
-             try process_if ip d e istmts estmts fun_stack node_id
-             with Jmp_exn ->
-               match branch with
-               | Some true -> List.fold_left (fun (d, b) stmt -> let d', b' = forward d stmt in d', Taint.Set.union b b') (restrict d e true) istmts
-               | Some false -> List.fold_left (fun (d, b) stmt -> let d', b' = forward d stmt in d', Taint.Set.union b b') (restrict d e false) estmts
-               | None -> L.abort (fun p -> p "Illegal call to Interpreter.forward_process")
-           end
-        | Asm.Call (Asm.R _) -> D.forget d, Taint.Set.singleton Taint.TOP
-        | Asm.Jmp (Asm.R _) -> D.forget d, Taint.Set.singleton Taint.TOP (* TODO may be more precise but check whether the target is really in the CFA. If not then go back to forward_bin for that branch *)
-      in
-      forward d stmt;;
-      
-   let forward_abstract_value (g:Cfa.t) (succ: Cfa.State.t) (ip: Data.Address.t) (v: Cfa.State.t): Cfa.State.t list =
-      let forward _g v _ip =
-        let d', taint_sources = List.fold_left (fun (d, b) s ->
-          let d', b' = forward_process v.Cfa.State.ip d s (succ.Cfa.State.branch) v.Cfa.State.id in
-          d', Taint.Set.union b b') (v.Cfa.State.v, Taint.Set.singleton Taint.U) (succ.Cfa.State.stmts)
-        in
-        succ.Cfa.State.v <- D.meet succ.Cfa.State.v d';
-        succ.Cfa.State.taint_sources <- taint_sources;
-        [succ]
-      in
-      Core.update_abstract_value g v (fun v -> v.Cfa.State.v) ip forward;;
-
-  let unroll g v succ =
-      if v.Cfa.State.final then
-        begin
-          v.Cfa.State.final <- false;
-          let new_succ = Cfa.copy_state g v in
-          new_succ.Cfa.State.forward_loop <- true;
-          Cfa.remove_successor g v succ;
-          Cfa.add_state g new_succ;
-          Cfa.add_successor g v new_succ;
-          Cfa.add_successor g new_succ succ;
-          new_succ
-        end
-      else
-        succ;;
-
-     let apply_after_call_stmts v stmts fun_stack =
-      let d', t' =
-        List.fold_left (fun (d, t) s ->
-            let d', t' = process_value v.Cfa.State.ip d s fun_stack v.Cfa.State.id in
-            d', Taint.Set.union t t') (v.Cfa.State.v,Taint.Set.singleton Taint.U) stmts
-      in
-      v.Cfa.State.v <- d';
-      v, t';;
-
-     
-    (** returns the result of the transfert function corresponding to the statement on the given abstract value *)
-    let skip_or_import_call vertices a fun_stack =     
-      (* will raise Not_found if no import or skip is found *)
-      L.debug2 (fun p -> p "skip_or_import_tbl at %s" (Data.Address.to_string a));
-      let fundec =
-        try
-          let import_desc = Hashtbl.find Decoder.Imports.tbl a in
-            Decoder.Imports.skip (Some import_desc) a
-        with
-        | Not_found -> Decoder.Imports.skip None a
-      in
-      let stmts = fundec.Asm.prologue @ fundec.Asm.stub @ fundec.Asm.epilogue in
-      let ret_addr_exp = fundec.Asm.ret_addr in
-      let t =
-        List.fold_left (fun t v ->             
-            let d', t' =
-              List.fold_left (fun (d, t) stmt ->
-                  try
-                    let d', t' = process_value a d stmt fun_stack v.Cfa.State.id in
-                    d', Taint.Set.union t t'
-                  with  Handler (sig_nb, handler_addr) -> (* TODO factorize this code with same pattern in process_vertices *)
-                    Hashtbl.replace (fst v.Cfa.State.handlers) sig_nb handler_addr;
-                    d, t
-                ) (v.Cfa.State.v, Taint.Set.singleton Taint.U) stmts
-              
-            in
-            v.Cfa.State.v <- d';
-            let addrs, _ = D.mem_to_addresses d' ret_addr_exp in
-            let a =
-              match Data.Address.Set.elements addrs with
-              | [a] -> a
-              | []  -> raise (Exceptions.Empty "no return address can be computed")
-              | _l  -> raise (Exceptions.Too_many_concrete_elements "multiple return addresses")
-            in
-            L.analysis (fun p -> p "returning from stub to %s" (Data.Address.to_string a));
-            v.Cfa.State.ip <- a;
-            Log.Trace.trace a (fun p -> p "%s"
-                                          (Asm.string_of_stmts [ Asm.Jmp(R ret_addr_exp) ] true));
-            Taint.Set.union t t') (Taint.Set.singleton Taint.U) vertices
-      in
-      vertices, t;;
-
-    let fold_to_target (apply: Data.Address.t -> Cfa.State.t -> fun_stack_t -> Data.Address.t -> unit) (vertices: Cfa.State.t list) (target: Asm.exp) (fun_stack: fun_stack_t) (ip: Data.Address.t): (Cfa.State.t list * Taint.Set.t) =
-        let import = ref false in
-        let vertices', t =
-          List.fold_left (fun (l, t) v ->
-              try
-                let addrs, taint_sources = D.mem_to_addresses v.Cfa.State.v target in
-                let addresses = Data.Address.Set.elements addrs in
-                match addresses with
-                | [a] ->
-                   begin
-                     L.debug (fun p->p "fold_to_target addr : %s" (Data.Address.to_string a));
-                     try
-                       let res = skip_or_import_call [v] a fun_stack in
-                       import := true;
-                       res
-                     with Not_found ->
-                       v.Cfa.State.ip <- a;
-                       apply a v fun_stack ip;
-                       v::l, Taint.Set.union t taint_sources
-                   end
-                  
-                | [] -> L.abort (fun p -> p "Unreachable jump target from ip = %s\n" (Data.Address.to_string v.Cfa.State.ip))
-                | l -> L.abort (fun p -> p "Please select between the addresses %s for jump target from %s\n"
-                                           (List.fold_left (fun s a -> s^(Data.Address.to_string a)) "" l) (Data.Address.to_string v.Cfa.State.ip))
-              with
-              | Exceptions.Too_many_concrete_elements _ as e ->
-                 L.exc_and_abort e (fun p -> p "Uncomputable set of address targets for jump at ip = %s\n" (Data.Address.to_string v.Cfa.State.ip))
-            ) ([], Taint.Set.singleton Taint.U) vertices
-        in
-        if !import then
-          begin
-            (* TODO: factorize with process_vertices, case Jmp_exn, subcase Jmp (A a) *)
-            let _, _, _, _, (stmts: Asm.stmt list) = List.hd !fun_stack in
-            let vertices', t' =
-              List.fold_left (fun (l, t) v ->
-                  let v', t' = apply_after_call_stmts v stmts fun_stack in
-                  v'::l, Taint.Set.union t t') ([], Taint.Set.singleton Taint.U) vertices'
-            in
-            begin
-              try
-                fun_stack := List.tl !fun_stack
-              with Failure _ -> ()
-            end;
-            vertices', Taint.Set.union t t'
-          end
-        else vertices, t;;
-
-    let add_to_fun_stack a v fun_stack ip =
-        begin
-          try
-            let n' = (Hashtbl.find Core.fun_unroll_tbl a) + 1 in
-            if n' <= !Config.fun_unroll then
-              Hashtbl.replace Core.fun_unroll_tbl a n'
-            else
-              L.abort (fun p -> p "function at %s has been analysed more than %d times. Analysis stops" (Data.Address.to_string a) !Config.fun_unroll)
-          with Not_found -> Hashtbl.add Core.fun_unroll_tbl a 1
-        end;
-        let f =
-          try
-            Some (Hashtbl.find Config.import_tbl (Data.Address.to_int a))
-          with Not_found -> None
-        in
-        fun_stack := (f, ip, v, !Core.unroll_tbl, [])::!fun_stack;
-        Core.unroll_tbl := Hashtbl.create 1000;;
-
-    let add_stmts_to_fun_stack stmts fun_stack =
-        try
-          let f, ip, v, unroll_tbl, prev_stmts = List.hd !fun_stack in
-          fun_stack := (f, ip, v, unroll_tbl, prev_stmts @ stmts)::(List.tl !fun_stack)
-        with _ -> raise (Exceptions.Error "unexpected empty function stack");;
-
-    let copy g v d branch is_pred =
-        (* TODO: optimize with Cfa.State.copy that copies every field and then here some are updated => copy them directly *)
-        let v' = Cfa.copy_state g v in
-        v'.Cfa.State.stmts <- [];
-        v'.Cfa.State.v <- d;
-        v'.Cfa.State.branch <- branch;
-        v'.Cfa.State.bytes <- [];
-        v'.Cfa.State.taint_sources <- Taint.Set.singleton Taint.U;
-        if is_pred then
-          Cfa.add_successor g v v'
-        else
-          Cfa.add_successor g (Cfa.pred g v) v';
-        v';;
-
-    let iprocess_ret ipstack v fun_stack ip =
-        let d = v.Cfa.State.v in
-        let sp = Register.stack_pointer () in
-        let ip_on_stack, taint_sources =
-          D.mem_to_addresses d (Asm.Lval (Asm.M (Asm.Lval (Asm.V (Asm.T sp)), (Register.size sp)))) in
-        match Data.Address.Set.elements (ip_on_stack) with
-        | [a] ->
-           let after_stmts = 
-             match ipstack with
-             | Some (ip', after_stmts) ->
-                if not (Data.Address.equal ip' a) then
-                  L.analysis (fun p -> p "computed instruction pointer %s differs from instruction pointer found on the stack %s at RET instruction"
-                                         (Data.Address.to_string ip') (Data.Address.to_string a));
-                after_stmts
-             | None -> []
-           in        
-           begin
-             try
-               let vert, t = skip_or_import_call [v] a fun_stack in
-               add_to_fun_stack a v fun_stack ip;
-               if after_stmts <> [] then
-                 let vert', t' = List.fold_left (fun (l, t) v' ->
-                                     let v', t' = apply_after_call_stmts v' after_stmts fun_stack in
-                                     v'::l, Taint.Set.union t t') ([], t) vert
-                 in
-                 Some vert', t'
-               else Some vert, t
-             with Not_found ->
-               v.Cfa.State.ip <- a;
-               Some [v], taint_sources
-           end
-        | [] -> raise (Exceptions.Empty "no valid instruction pointer at return can be retrieved")
-        | _ -> raise (Exceptions.Too_many_concrete_elements  "computed instruction pointer at return is imprecise");;
-
-    let process_ret (fun_stack: fun_stack_t) v ip: (Cfa.State.t list option * Taint.Set.t) =
-      try
-        let _f, ipstack, _v, prev_unroll_tbl, after_ret_stmts = List.hd !fun_stack in
-        fun_stack := List.tl !fun_stack;
-        Core.unroll_tbl := prev_unroll_tbl;
-        iprocess_ret (Some (ipstack, after_ret_stmts)) v fun_stack ip
-      with Failure _ ->
-        L.analysis (fun p -> p "RET without previous CALL at address %s" (Data.Address.to_string v.Cfa.State.ip));
-        iprocess_ret None v fun_stack ip;;
-          
-    let process_stmts fun_stack g (v: Cfa.State.t) (ip: Data.Address.t): Cfa.State.t list =
-      let rec process_branch vertices stmts branch (e: Asm.bexp) =
-        let vertices', b =
-          List.fold_left (fun (l, b) v ->
-               try
-                 let d, taint_sources = restrict v.Cfa.State.v e branch in
-                 if D.is_bot d then
-                   l, b
-                 else
-                   (copy g v d (Some true) false)::l, Taint.Set.union b taint_sources
-               with Exceptions.Empty "Interpreter.process_if_with_jmp" -> l, b) ([], Taint.Set.singleton Taint.U) vertices
-        in
-        let vert, b', _after_call_stmts = process_list vertices' stmts in
-        vert, Taint.Set.union b b'
-        
-      and process_if_with_jmp (vertices: Cfa.State.t list) (e: Asm.bexp) (istmts: Asm.stmt list) (estmts: Asm.stmt list) =  
-        let then', bt = process_branch vertices istmts true e in
-        let else', be = process_branch vertices estmts false e in
-        List.iter (fun v -> Cfa.remove_state g v) vertices;
-        then' @ else', Taint.Set.union be bt
-          
-        and process_vertices (vertices: Cfa.State.t list) (s: Asm.stmt) : (Cfa.State.t list * Taint.Set.t) * bool =
-          try
-            List.fold_left (fun (l, b) v ->
-                let d, b' =
-                  try process_value v.Cfa.State.ip v.Cfa.State.v s fun_stack v.Cfa.State.id
-                  with
-                    Handler (sig_nb, handler_addr') ->
-                    Hashtbl.replace (fst v.Cfa.State.handlers) sig_nb handler_addr';
-                    v.Cfa.State.v, b
-                in
-                v.Cfa.State.v <- d;
-                let taint = Taint.Set.union b b' in
-                (*v.Cfa.State.taint_sources <- taint;*)
-                v::l, taint) ([], Taint.Set.singleton Taint.U) vertices, false
-          with
-          | Jmp_exn ->
-             match s with
-             | If (e, then_stmts, else_stmts) -> process_if_with_jmp vertices e then_stmts else_stmts, false 
-                                               
-             | Jmp (A a) ->
-                begin
-                  try
-                    let _, _, _, _, stmts = List.hd !fun_stack in
-                    let vertices, t = skip_or_import_call vertices a fun_stack in
-                    let vertices', t' =
-                      List.fold_left (fun (l, t) v ->
-                          let v', t' = apply_after_call_stmts v stmts fun_stack in
-                          v'::l, Taint.Set.union t t') ([], Taint.Set.singleton Taint.U) vertices
-                    in
-                    fun_stack := List.tl !fun_stack;
-                    (vertices', Taint.Set.union t t'), false
-                  with _ ->
-                    (List.map (fun v -> v.Cfa.State.ip <- a; v) vertices, Taint.Set.singleton Taint.U), false
-                end
-
-             | Jmp (R target) ->
-                let res =
-                    match target with
-                    | Lval (M (Const c, _)) ->
-                       begin
-                         let a = Data.Address.of_word c in
-                         try
-                           let res = skip_or_import_call vertices a fun_stack in
-                           fun_stack := List.tl !fun_stack;
-                           res
-                         with Not_found ->
-                           List.map (fun v -> v.Cfa.State.ip <- a; v) vertices, Taint.Set.singleton Taint.U
-                       end
-                      
-                    | target -> fold_to_target (fun _a _v _fstack _ip -> ()) vertices target fun_stack ip
-                in
-                res, false
-               
-             | Call (A a) ->
-                add_to_fun_stack a v fun_stack ip;
-                begin
-                  try
-                    skip_or_import_call vertices a fun_stack, true
-                  with Not_found ->
-                    List.iter (fun v -> v.Cfa.State.ip <- a) vertices;
-                    (vertices, Taint.Set.singleton Taint.U), true
-                end
-                
-             | Call (R target) -> fold_to_target add_to_fun_stack vertices target fun_stack ip, false
-                                
-             | Return ->
-                List.fold_left (fun (l, b) v ->
-                    let v', b' = process_ret fun_stack v ip in
-                    match v' with
-                    | None -> l, Taint.Set.union b b'
-                    | Some v -> v@l, Taint.Set.union b b') ([], Taint.Set.singleton Taint.U) vertices, false
-               
-             | _       -> (vertices, Taint.Set.singleton Taint.U), false
-                        
-        and process_list (vertices: Cfa.State.t list) (stmts: Asm.stmt list): Cfa.State.t list * Taint.Set.t * Asm.stmt list =
-          match stmts with
-          | s::stmts ->
-             begin
-               try
-                 let ((new_vertices: Cfa.State.t list), (t: Taint.Set.t)), (has_call_inside: bool) = process_vertices vertices s in
-                 if has_call_inside then new_vertices, t, stmts
-                 else
-                   let vert, t', stmts' = process_list new_vertices stmts in
-                   vert, Taint.Set.union t t', stmts'
-               with Exceptions.Bot_deref -> [], Taint.Set.singleton Taint.BOT, [] (* in case of undefined dereference corresponding vertices are no more explored. They are not added to the waiting list neither *)
-             end
-          | [] -> vertices, Taint.Set.singleton Taint.U, []
-        in
-        let vstart = copy g v v.Cfa.State.v None true in
-        vstart.Cfa.State.ip <- ip;
-        (* check if the instruction has to be skiped *)
-        let ia = Data.Address.to_int v.Cfa.State.ip in
-        if not (Config.SAddresses.mem ia !Config.nopAddresses) then
-          let vertices, taint, after_call_stmts = process_list [vstart] v.Cfa.State.stmts in
-          begin
-            try
-              v.Cfa.State.taint_sources <- taint;
-              if after_call_stmts <> [] then
-                add_stmts_to_fun_stack after_call_stmts fun_stack;
-              List.iter (fun (_f, _ip, v, _tbl, _after_call_stmts) ->
-                  v.Cfa.State.taint_sources <- Taint.Set.union v.Cfa.State.taint_sources taint
-                ) !fun_stack;
-            with _  -> ()
-          end;
-          vertices
-        else
-          begin
-            Log.Trace.trace v.Cfa.State.ip (fun p -> p "nop ; forced by config");
-            L.analysis (fun p -> p "Instruction at address %s nopped by config"
-                                  (Data.Address.to_string v.Cfa.State.ip));
-          [vstart]
-        end;;
-
-       
-    
-(** fixpoint iterator to build the CFA corresponding to the provided code starting from the initial state s.
-     g is the initial CFA reduced to the singleton s *)
-let from_bin (mapped_mem: Mapped_mem.t) (g: Cfa.t) (s: Cfa.State.t) (dump: Cfa.t -> unit): Cfa.t =
-  let module Vertices = Set.Make(Cfa.State) in
-  (* check whether the instruction pointer is in the black list of addresses to decode *)
-  if Config.SAddresses.mem (Data.Address.to_int s.Cfa.State.ip) !Config.blackAddresses then
-    L.abort (fun p -> p "Interpreter not started as the entry point belongs to the cut off branches\n");
-  (* boolean variable used as condition for exploration of the CFA *)
-  let continue = ref true in
-  (* set of waiting nodes in the CFA waiting to be processed *)
-  let waiting  = ref (Vertices.singleton s) in
-  (* set d to the initial internal state of the decoder *)
-  let d = ref (Core.init ()) in
-  (* function stack *)
-  let fun_stack = ref [] in
-  let hash_add_or_append htbl key rules =
-    try
-      let existing = Hashtbl.find htbl key in
-      Hashtbl.replace htbl key (rules @ existing)
-    with Not_found -> Hashtbl.add htbl key rules
-  in
-  (* compute override rules to apply *)
-  let overrides = Hashtbl.create 5 in
-  Hashtbl.iter (fun z rules ->
-      let ip = Data.Address.of_int Data.Address.Global z !Config.address_sz in
-      let rules' =
-        List.map (fun (rname, rfun) ->
-            let reg = Register.of_name rname in
-            let rule = rfun reg in
-            Init_check.check_register_init reg rule;
-            D.set_register_from_config reg rule) rules
-      in
-      hash_add_or_append overrides ip rules'
-    ) Config.reg_override;
-  
-  
-  List.iter (fun (tbl, region) ->
-      Hashtbl.iter (fun z rules ->
-          let ip = Data.Address.of_int Data.Address.Global z !Config.address_sz in
-          let rules' =
-            List.map (fun ((addr, nb), rule) ->
-                L.analysis (fun p -> p "Adding override rule for address 0x%x" (Z.to_int addr));
-                Init_check.check_mem rule None;
-                let addr' = Data.Address.of_int region addr !Config.address_sz in
-                match rule with
-                | (Some _, _) -> D.set_memory_from_config addr' rule nb
-                | (None, t) -> D.taint_address_mask addr' t
-              ) rules
-          in
-          hash_add_or_append overrides ip rules'
-          
-        ) tbl)
-    [Config.mem_override, Data.Address.Global ];
-  
-  Hashtbl.iter (fun z rules ->
-      let ip = Data.Address.of_int Data.Address.Global z !Config.address_sz in
-      try
-        let rules' =
-          List.map (fun (((id, offset), nb), rule) ->
-              let id' = Z.to_int id in
-              L.analysis (fun p -> p "Adding override rule for heap id %d" id');
-              let heap_sz = Data.Address.size_of_heap_region id' in
-              Init_check.check_mem rule (Some heap_sz);
-              let addr' = Data.Address.of_int (Data.Address.Heap(id', heap_sz)) offset !Config.address_sz in
-              match rule with
-              | (Some _, _) -> D.set_memory_from_config addr' rule nb
-              | (None, t) -> D.taint_address_mask addr' t
-            ) rules
-        in
-        hash_add_or_append overrides ip rules'
-      with _ -> raise (Exceptions.Error "id of heap is too large")
-    ) Config.heap_override;
-  
-  while !continue do
-    (* a waiting node is randomly chosen to be explored *)
-    let v = Vertices.choose !waiting in
-    waiting := Vertices.remove v !waiting;
-    begin
-      try
-        L.info2 (fun p -> p "################### %s" (Data.Address.to_string v.Cfa.State.ip));
-        Log.current_address := Some v.Cfa.State.ip;
-        (* the subsequence of instruction bytes starting at the offset provided the field ip of v is extracted *)
-        let text'        = Mapped_mem.string_from_addr mapped_mem v.Cfa.State.ip !Config.max_instruction_size in
-        (* the corresponding instruction is decoded and the successor state of v are computed and added to    *)
-        (* the CFA                                                                                             *)
-        (* except the abstract value field which is set to v.Cfa.State.value. The right value will be          *)
-        (* computed next step                                                                                  *)
-        (* the new instruction pointer (offset variable) is also returned                                      *)
-        let r =
-          match text' with
-          | Some text'' ->  Core.parse text'' g !d v v.Cfa.State.ip (new Cfa.oracle v.Cfa.State.v v.Cfa.State.handlers)
-          | None -> L.abort (fun p -> p "Could not retrieve %i bytes at %s to decode next instruction"
-                                        !Config.max_instruction_size (Data.Address.to_string v.Cfa.State.ip) )
-        in
-        begin
-          match r with
-          | Some (v', ip', d') ->
-             Log.Trace.trace v.Cfa.State.ip (fun p -> p "%s" (Asm.string_of_stmts v.Cfa.State.stmts true));
-             (* add overrides if needed *)               
-             begin
-               try
-                 let rules = Hashtbl.find overrides v'.Cfa.State.ip in
-                 L.analysis (fun p -> p "applied %d override(s)" (List.length rules));
-                 let d', taint =
-                   List.fold_left (fun (d, taint) rule -> let d', taint' = rule d in d', Taint.Set.union taint taint'
-                     ) (v.Cfa.State.v, v.Cfa.State.taint_sources) rules
-                 in
-                 v.Cfa.State.v <- d';
-                 v.Cfa.State.taint_sources <- taint
-               with
-                 Not_found -> ()
-             end;
-             (* these vertices are updated by their right abstract values and the new ip  *)
-             let new_vertices = Core.update_abstract_value g v' (fun v -> v.Cfa.State.v) ip' (process_stmts fun_stack) in
-             (* among these computed vertices only new are added to the waiting set of vertices to compute       *)
-             let vertices'  = Core.filter_vertices true g new_vertices in
-             List.iter (fun v -> waiting := Vertices.add v !waiting) vertices';
-             (* udpate the internal state of the decoder *)
-             d := d'
-          | None -> ()
-        end;
-        Log.latest_finished_address := Some v.Cfa.State.ip;  (* v.Cfa.State.ip can change because of calls and jumps *)
-        
-      with
-      | Exceptions.Too_many_concrete_elements msg ->
-         L.analysis (fun p -> p "%s" msg);
-         
-         
-      | Exceptions.Use_after_free msg ->
-         L.analysis (fun p -> p "possible use after free in alloc %s, at: %s" msg (Data.Address.to_string v.Cfa.State.ip));
-         
-         
-      | Exceptions.Undefined_free msg ->
-         L.analysis (fun p -> p "undefined free detected here: %s" msg);
-         
-         
-      | Exceptions.Double_free ->
-         L.analysis (fun p -> p "possible double free detected");
-         
-         
-      | Exceptions.Stop msg ->
-         L.analysis (fun p -> p "analysis stopped for the current context: %s" msg)
-        
-      | e -> L.exc e (fun p -> p "Unexpected exception"); dump g; raise e
-    end;
-    (* boolean condition of loop iteration is updated *)
-    continue := not (Vertices.is_empty !waiting);
-  done;
-  g
-    
-let from_cfa (g: Cfa.t) (s: Cfa.State.t) (dump: Cfa.t -> unit): Cfa.t =
-  let f_iter (g: Cfa.t) (v: Cfa.State.t) (ip: Data.Address.t) (vert: Cfa.State.t list) =
-    List.fold_left (fun l v' -> (forward_abstract_value g v ip v')@l) [] vert
-  in
-    Core.cfa_iteration f_iter Cfa.succs unroll g s dump
-  
-    
-end
-    
diff --git a/ocaml/src/fixpoint/interpreter.ml b/ocaml/src/fixpoint/interpreter.ml
index f9254088..7fb6fdbf 100644
--- a/ocaml/src/fixpoint/interpreter.ml
+++ b/ocaml/src/fixpoint/interpreter.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -20,34 +20,105 @@
 
 module L = Log.Make(struct let name = "interpreter" end)
 
-module Make(D: Domain.T)(Decoder: Decoder.Make)(Stubs: Stubs.T with type domain_t = D.t) =
+module Make(D: Domain.T)(Decoder: Decoder.Make) =
 struct
 
-  module Decoder = Decoder(D)(Stubs)
-  module Cfa = Decoder.Cfa
- 
-
- (* Hash table to know when a widening has to be processed, that is when the associated value reaches the threshold Config.unroll *)
-  let unroll_tbl: ((Data.Address.t, int * D.t) Hashtbl.t) ref = ref (Hashtbl.create 1000)
-                                                              
-  (* Hash table to store number of times a function has been analysed *)
-  let fun_unroll_tbl: (Data.Address.t, int) Hashtbl.t = Hashtbl.create 10
-                                                      
-  (* current unroll value *)
-  (* None is for the default value set in Config *)
-  let unroll_nb = ref None
-
-  (** widen the given state with all previous vertices that have the same ip as v *)
-  let widen prev v =
-    let join_v = D.join prev v.Cfa.State.v in
-    v.Cfa.State.final <- true;
-    v.Cfa.State.v <- D.widen prev join_v
-    
+    (** stubs *)
+    module Stubs = Stubs.Make(D)
+
+    (** Decoder *)
+    module Decoder = Decoder(D)(Stubs)
+
+    type import_attrib_t = {
+      mutable ia_name: string;
+      mutable ia_addr: Z.t option;
+      mutable ia_typing_rule: bool;
+      mutable ia_tainting_rule: bool;
+      mutable ia_stub: bool;
+    }
+
+
+    (** Control Flow Automaton *)
+    module Cfa = Decoder.Cfa
+
+
+    open Asm
+
+    (* Hash table to know when a widening has to be processed, that is when the associated value reaches the threshold Config.unroll *)
+    let unroll_tbl: ((Data.Address.t, int * D.t) Hashtbl.t) ref = ref (Hashtbl.create 1000)
+
+    (* Hash table to store number of times a function has been analysed *)
+    let fun_unroll_tbl: (Data.Address.t, int) Hashtbl.t = Hashtbl.create 10
+
+    (* current unroll value *)
+    (* None is for the default value set in Config *)
+    let unroll_nb = ref None
+
+    (** opposite the given comparison operator *)
+    let inv_cmp (cmp: Asm.cmp): Asm.cmp =
+      match cmp with
+      | EQ  -> NEQ
+      | NEQ -> EQ
+      | LT  -> GEQ
+      | GEQ -> LT
+      | LEQ -> GT
+      | GT  -> LEQ
+
+    let restrict (d: D.t) (e: Asm.bexp) (b: bool): (D.t * Taint.Set.t) =
+      L.debug (fun p -> p "restrict: e=%s b=%B" (Asm.string_of_bexp e true) b);
+      let rec process e b =
+        match e with
+        | BConst b'           -> if b = b' then d, Taint.Set.singleton Taint.U else D.bot, Taint.Set.singleton Taint.BOT
+        | BUnOp (LogNot, e)  -> process e (not b)
+
+        | BBinOp (LogOr, e1, e2)  ->
+           let v1, taint1 = process e1 b in
+           let v2, taint2 = process e2 b in
+           let taint_sources =
+             if b then Taint.Set.union taint1 taint2
+             else Taint.Set.inter taint1 taint2
+           in
+           if b then D.join v1 v2, taint_sources
+           else D.meet v1 v2, taint_sources
+
+        | BBinOp (LogAnd, e1, e2) ->
+           let v1, taint1 = process e1 b in
+           let v2, taint2 = process e2 b in
+           let taint_sources =
+             if b then Taint.Set.inter taint1 taint2
+             else Taint.Set.union taint1 taint2 in
+           if b then D.meet v1 v2, taint_sources
+           else D.join v1 v2, taint_sources
+
+        | Asm.Cmp (cmp, e1, e2)   ->
+           let cmp' = if b then cmp else inv_cmp cmp in
+           D.compare d e1 cmp' e2
+      in
+      process e b
+
+
+    (** widen the given state with all previous vertices that have the same ip as v *)
+    let widen prev v =
+      let join_v = D.join prev v.Cfa.State.v in
+      v.Cfa.State.final <- true;
+      v.Cfa.State.v <- D.widen prev join_v
+
+
     (** update the abstract value field of the given vertices wrt to their list of statements and the abstract value of their predecessor
-    the widening may be also launched if the threshold is reached *)    
+    the widening may be also launched if the threshold is reached *)
     let update_abstract_value (g: Cfa.t) (v: Cfa.State.t) (get_field: Cfa.State.t -> D.t) (ip: Data.Address.t) (process_stmts: Cfa.t -> Cfa.State.t -> Data.Address.t -> Cfa.State.t list): Cfa.State.t list =
       try
+        let old_ip = v.Cfa.State.ip in
         let l = process_stmts g v ip in
+        List.iter (fun v ->
+          let d = get_field v in
+          try
+            let n', jd' = Hashtbl.find !unroll_tbl ip in
+            let d' = D.join jd' d in
+            Hashtbl.replace !unroll_tbl ip (n'+1, d');
+          with Not_found ->
+            Hashtbl.add !unroll_tbl v.Cfa.State.ip (1, d)
+        ) l;
         List.iter (fun v ->
           let d = get_field v in
           let n, jd =
@@ -72,24 +143,488 @@ struct
               widen jd v
             end
         ) l;
-        
+
+        L.info(fun p -> p "Addr: %s/%s" (Data.Address.to_string old_ip) (Data.Address.to_string ip));
+        try
+          (* Update the list of new states according to the Config Table *)
+          let _, addr_list = Hashtbl.find Config.cfgTbl (Data.Address.to_int old_ip) in
+          match l with
+            | [v] -> (
+              let new_states = (List.fold_left(fun (l':Cfa.State.t list) addr ->
+                let v' = Cfa.copy_state g v in
+                L.info(fun p -> p "State id is %d with ip %s" v'.Cfa.State.id (Data.Address.to_string v'.Cfa.State.ip));
+                v'.Cfa.State.ip <- Data.Address.global_of_int addr;
+                (* let reg = Register.of_name reg_name in
+                 *)
+                (* v'.Cfa.State. ; *) (* UPDATE ALSO REGISTER *)
+                Cfa.add_successor g v v';
+                L.info(fun p -> p "Add state with ip: %x" (Z.to_int addr));
+                v'::l'
+              ) [] addr_list) in
+              Cfa.remove_state g v;
+              new_states
+            )
+            | _ -> l;
+        with Not_found ->
+          ();
+
         List.fold_left (fun l' v ->
-          if D.is_bot (get_field v) then
+          if D.is_bot (get_field v) || (Cfa.has_ip g v) then
             begin
-              L.analysis (fun p -> p "unreachable state at address %s" (Data.Address.to_string ip));
+              if Cfa.has_ip g v then (
+                L.info(fun p -> p "Unreachable state because already explored")
+              ) else (
+                L.info(fun p -> p "Unreachable state because is bot")
+              );
               Cfa.remove_state g v; l'
             end
-          else v::l') [] l (* TODO: optimize by avoiding creating a state then removing it if its abstract value is bot *)
+          else (
+            v::l'
+          )
+          ) [] l (* TODO: optimize by avoiding creating a state then removing it if its abstract value is bot *)
       with Exceptions.Empty _ -> L.analysis (fun p -> p "No new reachable states from %s\n" (Data.Address.to_string ip)); []
-                                 
 
- (** [filter_vertices subsuming g vertices] returns vertices in _vertices_ that are not already in _g_ (same address and same decoding context and subsuming abstract value if subsuming = true) *)
+
+    (*************************** Forward from binary file ************************)
+    (*****************************************************************************)
+
+
+    (** returns true whenever the given list of statements has a jump stmt (Jmp, Call, Return) *)
+    let rec has_jmp stmts =
+        match stmts with
+        | [] -> false
+        | s::stmts' ->
+             match s with
+             | Call _ | Return  | Jmp _ -> true
+             | If (_, tstmts, estmts)   -> (has_jmp tstmts) || (has_jmp estmts)
+             | _                -> (has_jmp stmts')
+
+    let unroll_wrapper (f: unit -> int): unit =
+      try
+        match !unroll_nb with
+        | Some _ -> ()
+        | None ->
+           let n = max (f ()) !Config.unroll in
+           unroll_nb := Some n;
+           L.analysis (fun p -> p "automatic loop unrolling detection. Computed value is 0x%x" n)
+      with _ -> ()
+
+    exception Jmp_exn
+
+    type fun_stack_t = ((string * string) option * Data.Address.t * Cfa.State.t * (Data.Address.t, int * D.t) Hashtbl.t) list ref
+
+    let rec process_value (ip: Data.Address.t) (d: D.t) (s: Asm.stmt) (fun_stack: fun_stack_t) (node_id: int): D.t * Taint.Set.t =
+        L.debug2 (fun p -> p "process_value VVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\n%s\n---------\n%s\n---------" (String.concat " " (D.to_string d node_id)) (Asm.string_of_stmt s true));
+      try
+        let res, tainted =
+            match s with
+            | Nop                -> d, Taint.Set.singleton Taint.U
+            | If (e, then_stmts, else_stmts) -> process_if ip d e then_stmts else_stmts fun_stack node_id
+            | Set (dst, src)         -> D.set dst src d
+            | Directive (Remove r)       -> let d' = D.remove_register r d in Register.remove r; d', Taint.Set.singleton Taint.U
+            | Directive (Forget lval)        -> D.forget_lval lval d, Taint.Set.singleton Taint.U
+            | Directive (Unroll (e, bs)) ->
+               begin
+                 try
+                   let f () = min ((Z.to_int (D.value_of_exp d e)) + 1) bs in
+                   unroll_wrapper f
+                 with _ -> ()
+               end;
+              d, Taint.Set.singleton Taint.U
+
+            | Directive (Default_unroll) ->
+               L.analysis (fun p -> p "set unroll parameter to its default value");
+              unroll_nb := None;
+              d, Taint.Set.singleton Taint.U
+
+            | Asm.Directive (Asm.Unroll_until (addr, cmp, terminator, upper_bound, sz)) ->
+               begin
+                 try
+                   let f () =
+                     D.get_offset_from addr cmp terminator upper_bound sz d
+                   in
+                   unroll_wrapper f;
+                 with _ -> ()
+               end;
+               d, Taint.Set.singleton Taint.U
+
+            | Directive (Taint (e, lv))      ->
+                begin
+                 match lv with
+                 | V (T r) ->
+                    begin
+                      match e with
+                      | None ->
+                         let taint_src = Taint.new_src () in
+                         Hashtbl.add Dump.taint_src_tbl taint_src (Dump.R r);
+                         let mask = Config.Taint_all taint_src in
+                         D.taint_register_mask r mask d
+                      | Some c ->
+                         let taints = D.taint_sources c d in
+                         let taint' = Taint.Set.fold Taint.logor taints Taint.U in
+                         (* TODO: could be more precise here  but  taint_sources should be inlined in span_taint_to_register *)
+                         D.span_taint_to_register r taint' d
+                    end
+
+                 | M (_, 8) ->
+                    begin
+                      try
+
+                        match Data.Address.Set.elements (fst (D.mem_to_addresses d (Lval lv))) with
+                        | [a] ->
+                           begin
+                             match e with
+                             | None ->
+                                let taint_src = Taint.new_src () in
+                                Hashtbl.add Dump.taint_src_tbl taint_src (Dump.M (a, 8));
+                                D.taint_address_mask a [Config.Taint (Z.of_int 0xff, taint_src)] d
+                             | Some c ->
+                                let taints = D.taint_sources c d  in
+                                let taint' = Taint.Set.fold Taint.logor taints Taint.U in
+                                (* TODO/ same remark on precision *)
+                                D.span_taint_to_addr a taint' d
+                           end
+                        | _ -> raise Exit
+                      with _ -> L.analysis (fun p -> p "Tainting directive ignored"); d, Taint.Set.singleton Taint.U
+                    end
+                 | _ -> L.analysis (fun p -> p "Tainting directive for %s ignored" (Asm.string_of_lval lv false)); d, Taint.Set.singleton Taint.U
+               end
+            | Directive (Type (_lv, _t)) -> L.debug(fun p -> p "Type directive is ignored"); d, Taint.Set.singleton Taint.U
+
+            | Directive (Skip (f, call_conv)) as skip_statement ->
+               L.analysis (fun p -> p "Skipping %s" (Asm.string_of_fun f));
+               (* TODO: optimize to avoid type switching *)
+               let f' =
+                 match f with
+                 | Asm.Fun_name s -> Config.Fun_name s
+                 | Asm.Fun_addr a -> Config.Fun_addr (Data.Address.to_int a)
+               in
+               let d',  taint, cleanup_stmts = Stubs.skip d f' call_conv in
+               let d', taint' =
+                 Log.Trace.trace (Data.Address.global_of_int (Z.of_int 0))  (fun p -> p "%s" (string_of_stmts (skip_statement :: cleanup_stmts) true));
+                 List.fold_left (fun (d, t) stmt ->
+                     let dd, tt = process_value ip d stmt fun_stack node_id in
+                     dd, Taint.Set.union t tt) (d', taint) cleanup_stmts
+               in
+               d', taint'
+
+            | Directive (Stub (fun_name, call_conv)) as stub_statement ->
+               let prev_ip =
+                 try
+                   let _, _, v, _ = List.hd !fun_stack in
+                   Some v.Cfa.State.ip
+                 with Failure _ -> None
+               in
+               let d', taint', cleanup_stmts = Stubs.process ip prev_ip d fun_name call_conv in
+               let d', taint' =
+                 Log.Trace.trace (Data.Address.global_of_int (Z.of_int 0))  (fun p -> p "%s" (string_of_stmts (stub_statement :: cleanup_stmts) true));
+                 List.fold_left (fun (d, t) stmt ->
+                     let dd, tt = process_value ip d stmt fun_stack node_id in
+                     dd, Taint.Set.union t tt) (d', taint') cleanup_stmts
+               in
+               d', taint'
+
+            | _ -> raise Jmp_exn
+
+        in
+        res, tainted
+      with Exceptions.Empty _ -> D.bot, Taint.Set.singleton Taint.BOT
+
+    and process_if (ip: Data.Address.t) (d: D.t) (e: Asm.bexp) (then_stmts: Asm.stmt list) (else_stmts: Asm.stmt list) fun_stack (node_id: int) =
+      if has_jmp then_stmts || has_jmp else_stmts then
+             raise Jmp_exn
+           else
+             let dt, bt = List.fold_left (fun (d, b) s -> let d', b' = process_value ip d s fun_stack node_id in d', Taint.Set.union b b') (restrict d e true) then_stmts in
+             let de, be = List.fold_left (fun (d, b) s -> let d', b' = process_value ip d s fun_stack node_id in d', Taint.Set.union b b') (restrict d e false) else_stmts in
+             D.join dt de, Taint.Set.union bt be
+
+    (** returns the result of the transfert function corresponding to the statement on the given abstract value *)
+    let skip_or_import_call vertices a fun_stack =
+      (* will raise Not_found if no import or skip is found *)
+      L.debug2 (fun p -> p "skip_or_import_tbl at %s" (Data.Address.to_string a));
+      let fundec =
+        try
+          let import_desc = Hashtbl.find Decoder.Imports.tbl a in
+            Decoder.Imports.skip (Some import_desc) a
+        with
+        | Not_found -> Decoder.Imports.skip None a
+      in
+        let stmts = fundec.Asm.prologue @ fundec.Asm.stub @ fundec.Asm.epilogue in
+        let ret_addr_exp = fundec.Asm.ret_addr in
+        let t =
+            List.fold_left (fun t v ->
+                let d', t' =
+                  List.fold_left (fun (d, t) stmt ->
+                      let d', t' = process_value a d stmt fun_stack v.Cfa.State.id in
+                      d', Taint.Set.union t t') (v.Cfa.State.v, Taint.Set.singleton Taint.U) stmts
+                in
+                v.Cfa.State.v <- d';
+                let addrs, _ = D.mem_to_addresses d' ret_addr_exp in
+                let a =
+                  match Data.Address.Set.elements addrs with
+                  | [a] -> a
+                  | []  -> L.abort (fun p->p "no return address")
+                  | _l  -> L.abort (fun p->p "multiple return addresses")
+                in
+                L.analysis (fun p -> p "returning from stub to %s" (Data.Address.to_string a));
+                v.Cfa.State.ip <- a;
+                Log.Trace.trace a (fun p -> p "%s"
+                                              (Asm.string_of_stmts [ Asm.Jmp(R ret_addr_exp) ] true));
+                Taint.Set.union t t') (Taint.Set.singleton Taint.U) vertices
+        in
+        vertices, t
+
+
+    let process_stmts fun_stack g (v: Cfa.State.t) (ip: Data.Address.t): Cfa.State.t list =
+
+      let fold_to_target (apply: Data.Address.t -> unit) (vertices: Cfa.State.t list) (target: Asm.exp) : (Cfa.State.t list * Taint.Set.t) =
+        let import = ref false
+        in
+        let res = List.fold_left (fun (l, t) v ->
+          try
+            let addrs, taint_sources = D.mem_to_addresses v.Cfa.State.v target in
+            let addresses = Data.Address.Set.elements addrs in
+            match addresses with
+            | [a] ->
+              begin
+                  L.debug (fun p->p "fold_to_target addr : %s" (Data.Address.to_string a));
+                  try
+                    let res = skip_or_import_call [v] a fun_stack in
+                    import := true;
+                    (* apply a; *)  (* TODO(dm) I guess that could do it ?*)
+                    res
+                  with Not_found -> (
+                    v.Cfa.State.ip <- a;
+                    apply a;
+                    v::l, Taint.Set.union t taint_sources
+                  )
+              end
+            | [] -> (L.error (fun p -> p "Unreachable jump target from ip = %s\n" (Data.Address.to_string v.Cfa.State.ip));
+                    raise Exceptions.Jump_target)
+            | l -> L.abort (fun p -> p "Please select between the addresses %s for jump target from %s\n"
+                                  (List.fold_left (fun s a -> s^(Data.Address.to_string a)) "" l) (Data.Address.to_string v.Cfa.State.ip))
+          with
+          | Exceptions.Too_many_concrete_elements _ as e ->
+              L.exc_and_abort e (fun p -> p "Uncomputable set of address targets for jump at ip = %s\n" (Data.Address.to_string v.Cfa.State.ip))
+        ) ([], Taint.Set.singleton Taint.U) vertices
+        in
+        if !import && (List.length !fun_stack) > 0 then
+          fun_stack := List.tl !fun_stack;
+        res
+        in
+
+        let add_to_fun_stack a =
+          begin
+            try
+              let n' = (Hashtbl.find fun_unroll_tbl a) + 1 in
+              (* if n' <= !Config.fun_unroll then *)
+              Hashtbl.replace fun_unroll_tbl a n'
+              (* else
+                L.abort (fun p -> p "function at %s has been analysed more than %d times. Analysis stops" (Data.Address.to_string a) !Config.fun_unroll) *)
+            with Not_found -> Hashtbl.add fun_unroll_tbl a 1
+          end;
+          let f =
+            try
+              Some (Hashtbl.find Config.import_tbl (Data.Address.to_int a))
+            with Not_found -> None
+        in
+        fun_stack := (f, ip, v, !unroll_tbl)::!fun_stack;
+        L.info2(fun p -> p "Lenght of fun_stack: %d" (List.length !fun_stack));
+        unroll_tbl := Hashtbl.create 1000
+        in
+
+        let copy v d branch is_pred =
+          (* TODO: optimize with Cfa.State.copy that copies every field and then here some are updated => copy them directly *)
+          let v' = Cfa.copy_state g v in
+            L.info(fun p -> p "Copy state %d" v'.Cfa.State.id);
+            v'.Cfa.State.stmts <- [];
+            v'.Cfa.State.v <- d;
+            v'.Cfa.State.branch <- branch;
+            v'.Cfa.State.bytes <- [];
+            v'.Cfa.State.taint_sources <- Taint.Set.singleton Taint.U;
+            if is_pred then
+              Cfa.add_successor g v v'
+            else
+              Cfa.add_successor g (Cfa.pred g v) v';
+            v'
+        in
+
+        let iprocess_ret ipstack v fun_stack =
+          let d = v.Cfa.State.v in
+          let sp = Register.stack_pointer () in
+          let ip_on_stack, taint_sources = D.mem_to_addresses d (Asm.Lval (Asm.M (Asm.Lval (Asm.V (Asm.T sp)), (Register.size sp)))) in
+          match Data.Address.Set.elements (ip_on_stack) with
+          | [a] ->
+            begin
+              match ipstack with
+              | Some ip' ->
+                  if not (Data.Address.equal ip' a) then
+                    L.analysis (fun p -> p "computed instruction pointer %s differs from instruction pointer found on the stack %s at RET instruction"
+                                          (Data.Address.to_string ip') (Data.Address.to_string a))
+              | None -> ()
+            end;
+
+            begin
+              try
+                add_to_fun_stack a;
+                let vert, t = skip_or_import_call [v] a fun_stack in
+                Some vert, t
+              with Not_found ->
+                v.Cfa.State.ip <- a;
+                Some [v], taint_sources
+            end
+          | _ -> L.abort (fun p -> p "computed instruction pointer at return instruction is either undefined or imprecise")
+
+        in
+
+        let process_ret (fun_stack: fun_stack_t) v =
+          try
+            let _f, ipstack, _v, prev_unroll_tbl = List.hd !fun_stack in
+            fun_stack := List.tl !fun_stack;
+            unroll_tbl := prev_unroll_tbl;
+            iprocess_ret (Some ipstack) v fun_stack
+          with Failure _ ->
+            L.analysis (fun p -> p "RET without previous CALL at address %s" (Data.Address.to_string v.Cfa.State.ip));
+            iprocess_ret None v fun_stack
+        in
+
+        let rec process_if_with_jmp (vertices: Cfa.State.t list) (e: Asm.bexp) (istmts: Asm.stmt list) (estmts: Asm.stmt list) =
+          let process_branch stmts branch =
+            let vertices', b = (List.fold_left (fun (l, b) v ->
+              try
+                let d, taint_sources = restrict v.Cfa.State.v e branch in
+                if D.is_bot d then
+                  l, b
+                else
+                  (copy v d (Some true) false)::l, Taint.Set.union b taint_sources
+              with Exceptions.Empty "Interpreter.process_if_with_jmp" -> l, b) ([], Taint.Set.singleton Taint.U) vertices)
+            in
+            let vert, b' = process_list vertices' stmts in
+            vert, Taint.Set.union b b'
+          in
+          let then', bt = process_branch istmts true in
+          let else', be = process_branch estmts false in
+          List.iter (fun v ->
+            L.info(fun p -> p "Old State id %d is with ip %s" v.Cfa.State.id (Data.Address.to_string v.Cfa.State.ip) );
+            Cfa.remove_state g v;
+            Cfa.update_states g v.Cfa.State.ip
+          ) vertices;
+          (* Cfa.update_states g v.Cfa.State.ip; *)
+          then' @ else', Taint.Set.union be bt
+
+      and process_vertices (vertices: Cfa.State.t list) (s: Asm.stmt) : (Cfa.State.t list * Taint.Set.t) =
+        try
+          List.fold_left (fun (l, b) v -> let d, b' = process_value v.Cfa.State.ip v.Cfa.State.v s fun_stack v.Cfa.State.id in v.Cfa.State.v <- d;
+
+          let taint = Taint.Set.union b b' in
+                                          (*v.Cfa.State.taint_sources <- taint;*)
+              v::l, taint) ([], Taint.Set.singleton Taint.U) vertices
+
+        with Jmp_exn ->
+          match s with
+            | If (e, then_stmts, else_stmts) -> process_if_with_jmp vertices e then_stmts else_stmts
+
+            | Jmp (A a) ->
+              begin
+                try
+                  let res = skip_or_import_call vertices a fun_stack in
+                  begin (* Try to reduce the stack but it may be wrong *)
+                    try fun_stack := List.tl !fun_stack; with Failure _ -> ();
+                  end;
+                  res
+                with Not_found ->
+                  List.map (fun v -> v.Cfa.State.ip <- a; v) vertices, Taint.Set.singleton Taint.U
+              end
+
+            | Jmp (R target) ->
+              begin
+                match target with
+                | Lval (M (Const c, _)) ->
+                    begin
+                      let a = Data.Address.of_word c in
+                      try
+                        let res = skip_or_import_call vertices a fun_stack in
+                        fun_stack := List.tl !fun_stack;
+                        res
+                      with Not_found ->
+                        List.map (fun v -> v.Cfa.State.ip <- a; v) vertices, Taint.Set.singleton Taint.U
+                    end
+
+                | target -> fold_to_target (fun _a -> ()) vertices target
+              end
+
+             | Call (A a) ->
+                add_to_fun_stack a;
+                begin
+                  try
+                    skip_or_import_call vertices a fun_stack
+                  with Not_found ->
+                    List.iter (fun v -> v.Cfa.State.ip <- a) vertices;
+                    vertices, Taint.Set.singleton Taint.U
+                end
+
+             | Call (R target) ->
+              L.info(fun p -> p "Call a target with a register");
+              fold_to_target add_to_fun_stack vertices target
+
+             | Return ->
+                List.fold_left (fun (l, b) v ->
+                    let v', b' = process_ret fun_stack v in
+                    match v' with
+                    | None -> l, Taint.Set.union b b'
+                    | Some v -> v@l, Taint.Set.union b b') ([], Taint.Set.singleton Taint.U) vertices
+
+             | _       -> vertices, Taint.Set.singleton Taint.U
+
+      and process_list (vertices: Cfa.State.t list) (stmts: Asm.stmt list): Cfa.State.t list * Taint.Set.t =
+        match stmts with
+        | s::stmts ->
+           let new_vert, tainted =
+             begin
+               try
+                 let (new_vertices: Cfa.State.t list), (t: Taint.Set.t) = process_vertices vertices s in
+                 let vert, t' = process_list new_vertices stmts in
+                 vert, Taint.Set.union t t'
+               with Exceptions.Bot_deref -> [], Taint.Set.singleton Taint.BOT (* in case of undefined dereference corresponding vertices are no more explored. They are not added to the waiting list neither *)
+             end
+           in
+
+           new_vert, tainted
+        | []       -> vertices, Taint.Set.singleton Taint.U
+      in
+
+      let vstart = copy v v.Cfa.State.v None true in
+      L.info2(fun p -> p "Update ip here (old)? %s" (Data.Address.to_string v.Cfa.State.ip));
+      vstart.Cfa.State.ip <- ip;
+      L.info2(fun p -> p "Update ip here (new? %s" (Data.Address.to_string vstart.Cfa.State.ip));
+      (* check if the instruction has to be skiped *)
+      let ia = Data.Address.to_int v.Cfa.State.ip in
+      if not (Config.SAddresses.mem ia !Config.nopAddresses) then
+        let vertices, taint = process_list [vstart] v.Cfa.State.stmts in
+        begin
+          try
+            v.Cfa.State.taint_sources <- taint;
+            List.iter (fun (_f, _ip, v, _tbl) -> v.Cfa.State.taint_sources <- Taint.Set.union v.Cfa.State.taint_sources taint) !fun_stack;
+          with _ as e -> raise e;
+        end;
+        vertices
+      else
+        begin
+          Log.Trace.trace v.Cfa.State.ip (fun p -> p "nop ; forced by config");
+          L.analysis(fun p -> p "Instruction at address %s nopped by config"
+                                (Data.Address.to_string v.Cfa.State.ip));
+          [vstart]
+        end
+
+
+    (** [filter_vertices subsuming g vertices] returns vertices in _vertices_ that are not already in _g_ (same address and same decoding context and subsuming abstract value if subsuming = true) *)
     let filter_vertices (subsuming: bool) g vertices =
+      (* TODO(dm) Change this to only allow new IPs *)
       (* predicate to check whether a new state has to be explored or not *)
       let same prev v' =
           prev.Cfa.State.ctx.Cfa.State.addr_sz = v'.Cfa.State.ctx.Cfa.State.addr_sz &&
             prev.Cfa.State.ctx.Cfa.State.op_sz = v'.Cfa.State.ctx.Cfa.State.op_sz &&
-            prev.Cfa.State.ip = v'.Cfa.State.ip && (* both ips should be the same *)
+            prev.Cfa.State.ip = v'.Cfa.State.ip && (* both ips should be the same otherwise it has no sense *)
               (* fixpoint reached *)
               D.is_subset v'.Cfa.State.v prev.Cfa.State.v
       in
@@ -103,7 +638,7 @@ struct
               raise Exit
               end
             else
-              
+
               (* explore if a greater abstract state of v has already been explored *)
               if subsuming then
                 begin
@@ -118,8 +653,437 @@ struct
           with
             Exit -> l
           ) [] vertices
-     
-                
+
+
+    (** fixpoint iterator to build the CFA corresponding to the provided code starting from the initial state s.
+     g is the initial CFA reduced to the singleton s *)
+    let forward_bin (mapped_mem: Mapped_mem.t) (g: Cfa.t) (s: Cfa.State.t) (dump: Cfa.t -> unit): Cfa.t =
+      let module Vertices = Set.Make(Cfa.State) in
+      (* check whether the instruction pointer is in the black list of addresses to decode *)
+      if Config.SAddresses.mem (Data.Address.to_int s.Cfa.State.ip) !Config.blackAddresses then
+        L.abort (fun p -> p "Interpreter not started as the entry point belongs to the cut off branches\n");
+      (* boolean variable used as condition for exploration of the CFA *)
+      let continue = ref true             in
+      (* set of waiting nodes in the CFA waiting to be processed *)
+      let waiting  = ref (Vertices.singleton s) in
+      (* set d to the initial internal state of the decoder *)
+      let d = ref (Decoder.init ())             in
+      (* function stack *)
+      let fun_stack = ref []                    in
+      let hash_add_or_append htbl key rules =
+        try
+        let existing = Hashtbl.find htbl key in
+            Hashtbl.replace htbl key (rules @ existing)
+        with Not_found -> Hashtbl.add htbl key rules
+      in
+      (* compute override rules to apply *)
+      let overrides = Hashtbl.create 5 in
+      Hashtbl.iter (fun z rules ->
+        let ip = Data.Address.of_int Data.Address.Global z !Config.address_sz in
+        let rules' =
+          List.map (fun (rname, rfun) ->
+              let reg = Register.of_name rname in
+              let rule = rfun reg in
+            Init_check.check_register_init reg rule;
+            D.set_register_from_config reg rule) rules
+        in
+        hash_add_or_append overrides ip rules'
+      ) Config.reg_override;
+      if L.log_info () then
+        begin
+          let empty_desc = {
+              ia_name = "n/a";
+              ia_addr = None;
+              ia_typing_rule = false;
+              ia_tainting_rule = false;
+              ia_stub = false;
+            } in
+          let yesno b = if b then "YES" else "no" in
+          let itbl = Hashtbl.create 5 in
+          Hashtbl.iter (fun a (libname, fname) ->
+            let func_desc = { empty_desc with
+              ia_name = libname ^ "." ^ fname;
+              ia_addr = Some a;
+            } in
+            Hashtbl.add itbl fname func_desc) Config.import_tbl;
+          Hashtbl.iter (fun name _typing_rule ->
+            let func_desc =
+              try
+                Hashtbl.find itbl name
+              with Not_found -> { empty_desc with ia_name = "?." ^ name } in
+            Hashtbl.replace itbl name { func_desc with ia_typing_rule=true })  Config.typing_rules;
+          Hashtbl.iter (fun  (libname, name) (_callconv, _taint_ret, _taint_args) ->
+            let func_desc =
+              try
+                Hashtbl.find itbl name
+              with Not_found -> { empty_desc with ia_name = libname ^ "." ^ name } in
+            Hashtbl.replace itbl name { func_desc with ia_tainting_rule=true })  Config.tainting_rules;
+          Hashtbl.iter (fun name _ ->
+            let func_desc =
+              try
+                Hashtbl.find itbl name
+              with Not_found -> { empty_desc with ia_name = "?." ^ name } in
+            Hashtbl.replace itbl name { func_desc with ia_stub=true })  Stubs.stubs;
+
+          let addr_to_str x = match x with
+            | Some a ->
+               begin (* too bad we can't format "%%0%ix" to make a new format *)
+                 match !Config.address_sz with
+                 | 16 -> Printf.sprintf "%04x" (Z.to_int a)
+                 | 32 -> Printf.sprintf "%08x" (Z.to_int a)
+                 | 64 -> Printf.sprintf "%016x" (Z.to_int a)
+                 | _ ->  Printf.sprintf "%x" (Z.to_int a)
+               end
+            | None -> "?"
+          in
+          Hashtbl.iter (fun _name func_desc ->
+            L.info (fun p -> p "| IMPORT %-30s addr=%-16s typing=%-3s tainting=%-3s stub=%-3s"
+              func_desc.ia_name (addr_to_str func_desc.ia_addr)
+              (yesno func_desc.ia_typing_rule) (yesno func_desc.ia_tainting_rule) (yesno func_desc.ia_stub)))
+            itbl;
+          (* Hashtbl.iter (fun z (reg_name, addr_list) ->
+            let ip = Data.Address.of_int Data.Address.Global z !Config.address_sz in
+            let addr_str = List.fold_left (fun acc s -> (Z.to_string s)^","^acc) "" addr_list in
+            L.info(fun p -> p "Going further with addr %s with reg_name %s and addr list %s" (Data.Address.to_string ip) reg_name addr_str);
+            (* (fun src acc -> (Src.to_string src)^", "^acc) srcs "" *)
+          ) Config.cfgTbl; *)
+        end;
+
+      List.iter (fun (tbl, region) ->
+        Hashtbl.iter (fun z rules ->
+            let ip = Data.Address.of_int Data.Address.Global z !Config.address_sz in
+            let rules' =
+              List.map (fun ((addr, nb), rule) ->
+                  L.analysis (fun p -> p "Adding override rule for address 0x%x" (Z.to_int addr));
+                  Init_check.check_mem rule None;
+                  let addr' = Data.Address.of_int region addr !Config.address_sz in
+                  match rule with
+                       | (Some _, _) -> D.set_memory_from_config addr' rule nb
+                       | (None, t) -> D.taint_address_mask addr' t
+                ) rules
+            in
+            hash_add_or_append overrides ip rules'
+
+        ) tbl)
+        [Config.mem_override, Data.Address.Global ];
+
+        Hashtbl.iter (fun z rules ->
+          let ip = Data.Address.of_int Data.Address.Global z !Config.address_sz in
+          try
+            let rules' =
+              List.map (fun (((id, offset), nb), rule) ->
+                let id' = Z.to_int id in
+                L.analysis (fun p -> p "Adding override rule for heap id %d" id');
+                let heap_sz = Data.Address.size_of_heap_region id' in
+                Init_check.check_mem rule (Some heap_sz);
+                let addr' = Data.Address.of_int (Data.Address.Heap(id', heap_sz)) offset !Config.address_sz in
+                match rule with
+                | (Some _, _) -> D.set_memory_from_config addr' rule nb
+                | (None, t) -> D.taint_address_mask addr' t
+              ) rules
+            in
+            hash_add_or_append overrides ip rules'
+              with _ -> raise (Exceptions.Error "id of heap is too large")
+        ) Config.heap_override;
+
+      while !continue do
+        (* a waiting node is randomly chosen to be explored *)
+        let v = Vertices.choose !waiting in
+        waiting := Vertices.remove v !waiting;
+        begin
+          try
+            L.info2 (fun p -> p "################### %s (with id %d)" (Data.Address.to_string v.Cfa.State.ip) v.Cfa.State.id);
+            Log.current_address := Some v.Cfa.State.ip;
+            (* the subsequence of instruction bytes starting at the offset provided the field ip of v is extracted *)
+            let text'        = Mapped_mem.string_from_addr mapped_mem v.Cfa.State.ip !Config.max_instruction_size in
+            (* the corresponding instruction is decoded and the successor state of v are computed and added to    *)
+            (* the CFA                                                                                             *)
+            (* except the abstract value field which is set to v.Cfa.State.value. The right value will be          *)
+            (* computed next step                                                                                  *)
+            (* the new instruction pointer (offset variable) is also returned                                      *)
+            let r =
+              match text' with
+                | Some text'' ->  Decoder.parse text'' g !d v v.Cfa.State.ip (new Cfa.oracle v.Cfa.State.v)
+                | None ->
+                  L.error(fun p -> p "Could not retrieve %i bytes at %s to decode next instruction" !Config.max_instruction_size (Data.Address.to_string v.Cfa.State.ip) );
+                  None
+            in
+            begin
+              match r with
+                | Some (v', ip', d') ->
+                  Log.Trace.trace v.Cfa.State.ip (fun p -> p "%s" (Asm.string_of_stmts v.Cfa.State.stmts true));
+                  (* add overrides if needed *)
+                  begin
+                    try
+                      let rules = Hashtbl.find overrides v'.Cfa.State.ip in
+                      let d', taint =
+                          List.fold_left (fun (d, taint) rule -> let d', taint' = rule d in d', Taint.Set.union taint taint'
+                              ) (v.Cfa.State.v, v.Cfa.State.taint_sources) rules
+                      in
+                      v.Cfa.State.v <- d';
+                      v.Cfa.State.taint_sources <- taint
+                    with
+                      Not_found -> ()
+                  end;
+                  begin
+                    try
+                      (* these vertices are updated by their right abstract values and the new ip  *)
+                      let new_vertices = update_abstract_value g v' (fun v -> v.Cfa.State.v) ip' (process_stmts fun_stack) in
+                      (* among these computed vertices only new are added to the waiting set of vertices to compute       *)
+                      let vertices'  = filter_vertices true g new_vertices in
+                      List.iter (fun v -> waiting := Vertices.add v !waiting) vertices';
+                          (* udpate the internal state of the decoder *)
+                          d := d'
+                    with
+                      Exceptions.Jump_target -> ()
+                  end;
+                | None -> ()
+            end;
+            Log.latest_finished_address := Some v.Cfa.State.ip;  (* v.Cfa.State.ip can change because of calls and jumps *)
+
+          with
+          | Exceptions.Too_many_concrete_elements msg ->
+             L.analysis (fun p -> p "%s" msg);
+
+
+          | Exceptions.Use_after_free msg ->
+            L.analysis (fun p -> p "possible use after free in alloc %s, at: %s" msg (Data.Address.to_string v.Cfa.State.ip));
+
+
+          | Exceptions.Undefined_free msg ->
+             L.analysis (fun p -> p "undefined free detected here: %s" msg);
+
+
+          | Exceptions.Double_free ->
+              L.analysis (fun p -> p "possible double free detected");
+
+
+          | Exceptions.Stop msg ->
+             L.analysis (fun p -> p "analysis stopped for the current context: %s" msg)
+
+          | e             -> L.exc e (fun p -> p "Unexpected exception"); dump g; raise e
+        end;
+        (* boolean condition of loop iteration is updated *)
+        continue := not (Vertices.is_empty !waiting);
+      done;
+      g
+
+
+    (******************** BACKWARD *******************************)
+    (*************************************************************)
+
+    let shift_and_add shift len =
+      let one = Const (Data.Word.one len) in
+      let one' = Const (Data.Word.of_int (Z.of_int (len-1)) len) in
+      let shifted_one = BinOp (Asm.Shl, one, one') in
+      BinOp (Asm.Add, shift, shifted_one)
+
+    let back_add_sub op dst e1 e2 d =
+      match e1, e2 with
+      | Lval lv1, Lval lv2 ->
+        if Asm.equal_lval lv1 lv2 then
+            if op = Asm.Sub then
+             let len = Asm.lval_length lv1 in
+             let shift = BinOp (Asm.Shr, Lval dst, Const (Data.Word.of_int (Z.of_int 1) len)) in
+             let d', taint =
+               try
+                 if Z.compare Z.one (D.value_of_exp d (Decoder.overflow_expression())) = 0 then
+                   D.set lv1 (shift_and_add shift len) d
+                 else
+                   D.set lv1 shift d
+               with _ ->
+                 let d1, taint1 = D.set lv1 shift d in
+                 let d2, taint2 = D.set lv1 (shift_and_add shift len) d in
+                 D.join d1 d2, Taint.Set.union taint1 taint2
+             in
+             if Asm.with_lval dst (Lval lv1) then
+               d', taint
+             else D.forget_lval dst d', taint
+           else
+             D.forget_lval dst d, Taint.Set.singleton Taint.TOP
+         else
+          if (Asm.with_lval dst e1) || (Asm.with_lval dst e2) then
+            D.set lv1 (BinOp (op, Lval dst, e2)) d
+          else D.forget_lval dst d, Taint.Set.singleton Taint.TOP
+
+      | Lval lv, Const c | Const c, Lval lv ->
+         let d', taint = D.set lv (BinOp (op, Lval dst, Const c)) d in
+         if Asm.with_lval dst (Lval lv) then
+           d', taint
+         else D.forget_lval dst d', taint
+
+      | Lval lv, e | e, Lval lv ->
+           if (Asm.with_lval dst e1) || (Asm.with_lval dst e2) then
+             D.set lv (BinOp (op, Lval dst, e)) d
+           else D.forget_lval dst d, Taint.Set.singleton Taint.TOP
+
+      | _ ->  D.forget_lval dst d, Taint.Set.singleton Taint.TOP
+
+
+    let back_set (dst: Asm.lval) (src: Asm.exp) (d: D.t): (D.t * Taint.Set.t) =
+      match src with
+      | Lval lv ->
+         let d', taint = D.set lv (Lval dst) d in
+         if Asm.equal_lval lv dst then d', taint
+         else D.forget_lval dst d', taint
+
+      | UnOp (Not, Lval lv) ->
+        let d', taint = D.set lv (UnOp (Not, Lval dst)) d in
+        if Asm.equal_lval lv dst then d', taint
+        else D.forget_lval dst d, taint
+
+      | BinOp (Add, e1, e2)  -> back_add_sub Sub dst e1 e2 d
+      | BinOp (Sub, e1, e2) -> back_add_sub Add dst e1 e2 d
+
+      | _ -> D.forget_lval dst d, Taint.Set.singleton Taint.TOP
+
+    (** backward transfert function on the given abstract value *)
+    let backward_process (branch: bool option) (d: D.t) (stmt: Asm.stmt) : (D.t * Taint.Set.t) =
+      (* BE CAREFUL: this function does not apply to nested if statements *)
+      let rec back d stmt =
+        L.debug (fun p -> p "back of %s.........." (Asm.string_of_stmt stmt true));
+        match stmt with
+        | Call _
+        | Return
+        | Jmp _
+        | Nop -> d, Taint.Set.singleton Taint.U
+        | Directive (Forget _) -> d, Taint.Set.singleton Taint.U
+        | Directive (Remove r) -> D.add_register r d, Taint.Set.singleton Taint.U
+        | Directive (Taint _) -> D.forget d, Taint.Set.singleton Taint.TOP
+        | Directive (Type _) -> D.forget d, Taint.Set.singleton Taint.U
+        | Directive (Unroll _) -> d, Taint.Set.singleton Taint.U
+        | Directive (Unroll_until _) -> d, Taint.Set.singleton Taint.U
+        | Directive Default_unroll -> d, Taint.Set.singleton Taint.U
+        | Directive (Stub _) -> d, Taint.Set.singleton Taint.U
+        | Directive (Skip _) -> d, Taint.Set.singleton Taint.U
+        | Set (dst, src) -> back_set dst src d
+        | Assert (_bexp, _msg) -> d, Taint.Set.singleton Taint.U (* TODO *)
+        | If (_e, istmts, estmts) ->
+           match branch with
+           | Some true -> List.fold_left (fun (d, b) s -> let d', b' = back d s in d', Taint.Set.union b b') (d, Taint.Set.singleton Taint.U) (List.rev istmts)
+           | Some false -> List.fold_left (fun (d, b) s -> let d', b' = back d s in d', Taint.Set.union b b') (d, Taint.Set.singleton Taint.U) (List.rev estmts)
+           | None -> D.forget d, Taint.Set.singleton Taint.U
+      in
+      back d stmt
+
+    let back_update_abstract_value (g:Cfa.t) (v: Cfa.State.t) (ip: Data.Address.t) (pred: Cfa.State.t): Cfa.State.t list =
+      let backward _g v _ip =
+        let start_v =
+          match v.Cfa.State.back_v with
+          | Some d -> d
+          | None -> raise (Exceptions.Empty "undefined abstract value used in backward mode")
+        in
+        let d', taint_sources =
+          List.fold_left (fun (d, b) s ->
+            let d', b' = backward_process v.Cfa.State.branch d s in
+            d', Taint.Set.union b b'
+          ) (start_v, Taint.Set.singleton Taint.U) (List.rev pred.Cfa.State.stmts)
+        in
+        let v' = D.meet pred.Cfa.State.v d' in
+        begin
+          match pred.Cfa.State.back_v, pred.Cfa.State.back_taint_sources with
+          | None, None ->
+             pred.Cfa.State.back_v <- Some v';
+            pred.Cfa.State.back_taint_sources <- Some taint_sources
+          | Some v2, Some t2 ->
+             pred.Cfa.State.back_v <- Some (D.join v' v2);
+            pred.Cfa.State.back_taint_sources <- Some (Taint.Set.union t2 taint_sources)
+          | _, _ ->
+             raise (Exceptions.Error "inconsistent state in backward mode")
+        end;
+        [pred]
+      in
+      let get_field v =
+        match v.Cfa.State.back_v with
+        | Some d -> d
+        | None -> raise (Exceptions.Error "Illegal call to get_field in interpreter")
+      in
+      update_abstract_value g v get_field ip backward
+
+
+    let back_unroll g v pred =
+      if v.Cfa.State.final then
+        begin
+          v.Cfa.State.final <- false;
+          let new_pred = Cfa.copy_state g v in
+          new_pred.Cfa.State.back_loop <- true;
+          Cfa.remove_successor g pred v;
+          Cfa.add_state g new_pred;
+          Cfa.add_successor g pred new_pred;
+          Cfa.add_successor g new_pred v;
+          new_pred
+        end
+      else
+        pred
+
+    (*************************************)
+    (* FORWARD AUXILARY FUNCTIONS ON CFA *)
+    (*************************************)
+    let unroll g v succ =
+      if v.Cfa.State.final then
+        begin
+          v.Cfa.State.final <- false;
+          let new_succ = Cfa.copy_state g v in
+          new_succ.Cfa.State.forward_loop <- true;
+          Cfa.remove_successor g v succ;
+          Cfa.add_state g new_succ;
+          Cfa.add_successor g v new_succ;
+          Cfa.add_successor g new_succ succ;
+          new_succ
+        end
+      else
+        succ
+
+
+    let forward_process (ip: Data.Address.t) (d: D.t) (stmt: Asm.stmt) (branch: bool option) (node_id: int): (D.t * Taint.Set.t) =
+      (* function stack *)
+      let fun_stack = ref [] in
+      let rec forward (d: D.t) (stmt: Asm.stmt): (D.t * Taint.Set.t) =
+        match stmt with
+        | Asm.Nop
+        | Asm.Directive (Asm.Forget _)
+        | Asm.Directive (Asm.Remove _)
+        | Asm.Directive (Asm.Taint _)
+        | Asm.Directive (Asm.Type _)
+        | Asm.Directive (Asm.Unroll _)
+        | Asm.Directive (Asm.Stub _)
+        | Asm.Directive (Asm.Skip _)
+        | Asm.Directive (Asm.Unroll_until _)
+        | Asm.Directive Asm.Default_unroll
+        | Asm.Jmp (Asm.A _)
+        | Asm.Return
+        | Asm.Call (Asm.A _) -> d, Taint.Set.singleton Taint.U
+        | Asm.Set (dst, src) -> D.set dst src d
+        | Assert (_bexp, _msg) -> d, Taint.Set.singleton Taint.U (* TODO *)
+        | Asm.If (e, istmts, estmts) ->
+           begin
+             try process_if ip d e istmts estmts fun_stack node_id
+             with Jmp_exn ->
+               match branch with
+               | Some true -> List.fold_left (fun (d, b) stmt -> let d', b' = forward d stmt in d', Taint.Set.union b b') (restrict d e true) istmts
+               | Some false -> List.fold_left (fun (d, b) stmt -> let d', b' = forward d stmt in d', Taint.Set.union b b') (restrict d e false) estmts
+               | None -> L.abort (fun p -> p "Illegal call to Interpreter.forward_process")
+           end
+        | Asm.Call (Asm.R _) -> D.forget d, Taint.Set.singleton Taint.TOP
+        | Asm.Jmp (Asm.R _) -> D.forget d, Taint.Set.singleton Taint.TOP (* TODO may be more precise but check whether the target is really in the CFA. If not then go back to forward_bin for that branch *)
+      in
+      forward d stmt
+
+    let forward_abstract_value (g:Cfa.t) (succ: Cfa.State.t) (ip: Data.Address.t) (v: Cfa.State.t): Cfa.State.t list =
+      let forward _g v _ip =
+        let d', taint_sources = List.fold_left (fun (d, b) s ->
+          let d', b' = forward_process v.Cfa.State.ip d s (succ.Cfa.State.branch) v.Cfa.State.id in
+          d', Taint.Set.union b b') (v.Cfa.State.v, Taint.Set.singleton Taint.U) (succ.Cfa.State.stmts)
+        in
+        succ.Cfa.State.v <- D.meet succ.Cfa.State.v d';
+        succ.Cfa.State.taint_sources <- taint_sources;
+        [succ]
+      in
+      update_abstract_value g v (fun v -> v.Cfa.State.v) ip forward
+
+    (****************************)
+    (* FIXPOINT ON CFA *)
+    (****************************)
     let cfa_iteration (update_abstract_value: Cfa.t -> Cfa.State.t -> Data.Address.t -> Cfa.State.t list -> Cfa.State.t list)
         (next: Cfa.t -> Cfa.State.t -> Cfa.State.t list)
         (unroll: Cfa.t -> Cfa.State.t -> Cfa.State.t -> Cfa.State.t) (g: Cfa.t) (s: Cfa.State.t) (dump: Cfa.t -> unit): Cfa.t =
@@ -137,9 +1101,7 @@ struct
             let v = Vertices.choose !waiting in
             waiting := Vertices.remove v !waiting;
             let v' = next g v in
-            let new_vertices =
-              List.fold_left (fun l v' -> (update_abstract_value g v v'.Cfa.State.ip [v'])@l) [] v'
-            in
+            let new_vertices = List.fold_left (fun l v' -> (update_abstract_value g v v'.Cfa.State.ip [v'])@l) [] v' in
             let new_vertices' = List.map (unroll g v) new_vertices in
             let vertices' = filter_vertices false g new_vertices' in
             List.iter (fun v -> waiting := Vertices.add v !waiting) vertices';
@@ -150,31 +1112,25 @@ struct
         | Invalid_argument _ -> L.analysis (fun p -> p "entry node of the CFA reached"); g
         | e -> dump g; raise e
 
-    module Core =
-      struct
-        type ctx_t = Decoder.ctx_t
-        let unroll_nb = unroll_nb
-        let cfa_iteration = cfa_iteration
-        let update_abstract_value = update_abstract_value
-        let parse = Decoder.parse
-        let init = Decoder.init
-        let unroll_tbl = unroll_tbl
-        let fun_unroll_tbl = fun_unroll_tbl
-        let filter_vertices = filter_vertices
-      end
-      
-    module Forward = Forward.Make(D)(Cfa)(Stubs)(Decoder)(Core)
-    module Backward = Backward.Make(D)(Cfa)(Decoder)(Core)
-   
+    let backward (g: Cfa.t) (s: Cfa.State.t) (dump: Cfa.t -> unit): Cfa.t =
+      cfa_iteration (fun g v ip vert -> back_update_abstract_value g v ip (List.hd vert))
+        (fun g v -> [Cfa.pred g v]) back_unroll g s dump
+
+    let forward_cfa (g: Cfa.t) (s: Cfa.State.t) (dump: Cfa.t -> unit): Cfa.t =
+      cfa_iteration (fun g v ip vert -> List.fold_left (fun l v' -> (forward_abstract_value g v ip v')@l) [] vert)
+        Cfa.succs unroll g s dump
+
     (************* INTERLEAVING OF FORWARD/BACKWARD ANALYSES *******)
+    (***************************************************************)
+
     let interleave_from_cfa (g: Cfa.t) (dump: Cfa.t -> unit): Cfa.t =
       L.analysis (fun p -> p "entering interleaving mode");
       let process mode cfa =
         Hashtbl.clear !unroll_tbl;
         List.fold_left (fun g s0 -> mode g s0 dump) cfa (Cfa.sinks cfa)
       in
-      let g_bwd = process Backward.from_cfa g in
-      process Forward.from_cfa g_bwd
-      
+      let g_bwd = process backward g in
+      process forward_cfa g_bwd
     let make_registers () = Decoder.init_registers ()
 end
+
diff --git a/ocaml/src/fixpoint/stubs.ml b/ocaml/src/fixpoint/stubs.ml
index ad6a42c4..4facd4fc 100644
--- a/ocaml/src/fixpoint/stubs.ml
+++ b/ocaml/src/fixpoint/stubs.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -22,20 +22,21 @@ module type T =
 sig
   type domain_t
 
-  val process : Data.Address.t -> Data.Address.t option -> domain_t -> string -> Asm.calling_convention_t -> 
+  val process : Data.Address.t -> Data.Address.t option -> domain_t -> string -> Asm.calling_convention_t ->
     domain_t * Taint.Set.t * Asm.stmt list
 
   val skip: domain_t -> Config.fun_t -> Asm.calling_convention_t -> domain_t *  Taint.Set.t * Asm.stmt list
-    
+
   val init: unit -> unit
 
-  val default_handler: int -> Asm.stmt list
-    
   val stubs : (string, (Data.Address.t -> Data.Address.t option -> domain_t -> Asm.lval -> (int -> Asm.lval) ->
+
                          domain_t * Taint.Set.t) * int) Hashtbl.t
 end
 
-module Make(D: Domain.T) = struct
+
+module Make (D: Domain.T) : (T with type domain_t := D.t)  =
+struct
 
     type domain_t = D.t
 
@@ -49,20 +50,18 @@ module Make(D: Domain.T) = struct
         let d' = D.allocate_on_heap d id in
         let zero = Data.Word.zero !Config.address_sz in
         let addr = region, zero in
-        let success_msg = "successfull heap allocation " in
-        let failure_msg = "heap allocation failed  " in
-        let postfix =
-          match calling_ip with
-          | Some ip -> let ip_str = Data.Address.to_string ip in "at " ^ ip_str
-          | None -> ""
-        in
-        let success_msg = success_msg ^ postfix in
-        let failure_msg = failure_msg ^ postfix in
-        D.set_lval_to_addr ret [ (addr, success_msg) ; (Data.Address.of_null (), failure_msg) ] d'
+          let success_msg = "successful heap allocation " in
+          let failure_msg = "heap allocation failed  " in
+          let postfix =
+            match calling_ip with
+            | Some ip -> let ip_str = Data.Address.to_string ip in "at " ^ ip_str
+            | None -> ""
+          in
+          let success_msg = success_msg ^ postfix in
+          let failure_msg = failure_msg ^ postfix in
+          D.set_lval_to_addr ret [ (addr, success_msg) ; (Data.Address.of_null (), failure_msg) ] d'
       with Z.Overflow -> raise (Exceptions.Too_many_concrete_elements "heap allocation: imprecise size to allocate")
 
-
-
     let check_free (ip: Data.Address.t) (a: Data.Address.t): Data.Address.heap_id_t =
       match a with
       | Data.Address.Heap (id, _), o ->
@@ -79,29 +78,29 @@ module Make(D: Domain.T) = struct
                   (Printf.sprintf "at instruction %s: base address (%s) to free not in the heap or NULL"
                   (Data.Address.to_string ip)
                   (Data.Address.to_string a)))
-           
+
     let heap_deallocator (ip: Data.Address.t) _ (d: domain_t) _ret args: domain_t * Taint.Set.t =
       let mem = Asm.Lval (args 0) in
       try
         let addrs, taint = D.mem_to_addresses d mem in
-        let addrs' = Data.Address.Set.elements addrs in 
+        let addrs' = Data.Address.Set.elements addrs in
         match addrs' with
         | [a] ->
            let id = check_free ip a in
            L.debug2 (fun p -> p "check_free");
            D.deallocate d id, taint
-             
+
         | _::_ ->
            let ids = List.fold_left (fun ids a -> (check_free ip a)::ids) [] addrs' in
            D.weak_deallocate d ids, taint
-             
+
         | [] ->
            let msg = Printf.sprintf "Illegal dereference of %s (null)" (Asm.string_of_lval (args 0) true) in
            raise (Exceptions.Null_deref msg)
       with
-        Exceptions.Too_many_concrete_elements _  ->
+        Exceptions.Too_many_concrete_elements _ ->
           raise (Exceptions.Too_many_concrete_elements "Stubs: too many addresses to deallocate")
-      
+
     let strlen (_ip: Data.Address.t) _ (d: domain_t) ret args: domain_t * Taint.Set.t =
       let zero = Asm.Const (Data.Word.zero 8) in
       let len = D.get_offset_from (Asm.Lval (args 0)) Asm.EQ zero 10000 8 d in
@@ -130,24 +129,20 @@ module Make(D: Domain.T) = struct
         let n = Z.to_int (D.value_of_exp d sz) in
         let lv1 = Asm.M (Asm.Lval (args 0), 8*n) in
         let lv2 = Asm.M (Asm.Lval (args 1), 8*n) in
-        let taint =
-          try
-            Taint.join (D.get_taint lv1 d) (D.get_taint lv2 d)
-          with _ -> Taint.TOP
-        in
         let v1 = D.value_of_exp d (Asm.Lval lv1) in
         let v2 = D.value_of_exp d (Asm.Lval lv2) in
         let res = Asm.Const (Data.Word.of_int (Z.sub v1 v2) !Config.operand_sz) in
         let d' = fst (D.set ret res d) in
+        let taint = Taint.join (D.get_taint lv1 d') (D.get_taint lv2 d') in
         D.taint_lval ret taint d'
-      with _ -> D.forget_lval ret d, Taint.Set.singleton Taint.TOP
-      
+      with _ -> D.forget_lval ret d, Taint.Set.singleton Taint.TOP (* TODO: check soundness of the returned taint *)
+
     let memset (_ip: Data.Address.t) _ (d: domain_t) ret args: domain_t * Taint.Set.t =
       let arg0 = args 0 in
       let dst = Asm.Lval arg0 in
       let src = args 1 in
       let nb = Asm.Lval (args 2) in
-      
+
       try
         let nb' = D.value_of_exp d nb in
         let byte =
@@ -166,14 +161,14 @@ module Make(D: Domain.T) = struct
             fst (D.set (Asm.M(addr, 8)) byte_exp d) (* we ignore taint as the source is a constant *)
           else
             d
-        in            
+        in
         let rec set_loop d i = if Z.sign i < 0 then d
                                else let d'=one_set d i in set_loop d' (Z.pred i) in
         let d' = set_loop d nb' in
         (* result is tainted if the destination to copy the byte is tainted *)
         D.set ret dst d'
       with _ -> L.abort (fun p -> p "too large number of bytes to copy in memset stub")
-        
+
     let print (d: domain_t) ret format_addr va_args (to_buffer: Asm.exp option): domain_t * Taint.Set.t =
         (* ret has to contain the number of bytes stored in dst ;
            format_addr is the address of the format string ;
@@ -181,7 +176,7 @@ module Make(D: Domain.T) = struct
         try
             let zero = Asm.Const (Data.Word.of_int Z.zero 8) in
             let str_len, format_string = D.get_bytes format_addr Asm.EQ zero 1000 8 d in
-            L.info (fun p -> p "(s)printf stub, format string: \"%s\"" (String.escaped (Bytes.to_string format_string)));
+            L.info (fun p -> p "(s)printf stub, format string: \"%s\" (%d)" (String.escaped (Bytes.to_string format_string)) str_len);
             let format_num d dst_off c fmt_pos arg pad_char pad_left: int * int * domain_t =
               let rec compute digit_nb fmt_pos =
                 let c = Bytes.get format_string fmt_pos in
@@ -223,7 +218,7 @@ module Make(D: Domain.T) = struct
                        let d', dst_off' = copy arg digit_nb (Char.compare c 'X' = 0) (Some (pad_char, pad_left)) !Config.operand_sz in
                        fmt_pos+1, dst_off', d'
 
-                       
+
                     | 's' ->
                       let dump =
                           match to_buffer with
@@ -231,7 +226,7 @@ module Make(D: Domain.T) = struct
                             let dst' = Asm.BinOp (Asm.Add, dst, Asm.Const (Data.Word.of_int (Z.of_int dst_off) !Config.stack_width))
                             in
                             D.copy_chars d dst'
-                          | _ -> (fun arg1 arg2 arg3 -> fst (D.print_chars d arg1 arg2 arg3))
+                          | _ -> D.print_chars d
                       in
                       fmt_pos+1, digit_nb, dump arg digit_nb (Some (pad_char, pad_left))
 
@@ -285,14 +280,15 @@ module Make(D: Domain.T) = struct
                 | _ -> L.abort (fun p -> p "Unknown format or modifier in format string: %c" c)
             in
             let rec copy_char d c (fmt_pos: int) dst_off arg_nb: int * domain_t =
-                let src = (Asm.Const (Data.Word.of_int (Z.of_int (Char.code c)) 8)) in
+                let src = (L.info(fun p->p "here-6"); Asm.Const (Data.Word.of_int (Z.of_int (Char.code c)) 8)) in
                 let dump =
                     match to_buffer with
-                    | Some dst ->  D.copy d (Asm.BinOp (Asm.Add, dst, Asm.Const (Data.Word.of_int (Z.of_int dst_off) !Config.address_sz)))
-                    | _ -> D.print d
+                    | Some dst ->  (L.info(fun p->p "here-5"); D.copy d (Asm.BinOp (Asm.Add, dst, Asm.Const (Data.Word.of_int (Z.of_int dst_off) !Config.address_sz))))
+                    | _ -> (L.info(fun p -> p "here-2"); D.print d)
                 in
-                let d' = dump src 8 in
-                    fill_buffer d' (fmt_pos+1) 0 (dst_off+1) arg_nb
+                let d' = dump src 8 in (
+                  L.info(fun p->p "here-4 %d" fmt_pos);
+                    fill_buffer d' (fmt_pos+1) 0 (dst_off+1) arg_nb)
             (* state machine for format string parsing *)
             and fill_buffer (d: domain_t) (fmt_pos: int) (state_id: int) (dst_off: int) arg_nb: int * domain_t =
                 if fmt_pos < str_len then
@@ -300,8 +296,8 @@ module Make(D: Domain.T) = struct
                     | 0 -> (* look for % *)
                       begin
                           match Bytes.get format_string fmt_pos with
-                          | '%' -> fill_buffer d (fmt_pos+1) 1 dst_off arg_nb
-                          | c -> copy_char d c fmt_pos dst_off arg_nb
+                          | '%' -> (L.info(fun p->p "here-3"); fill_buffer d (fmt_pos+1) 1 dst_off arg_nb)
+                          | c -> begin L.info(fun p -> p "here-1 %d" fmt_pos); copy_char d c fmt_pos dst_off arg_nb end;
                       end
                     | 1 -> (* % found, do we have %% ? *)
                       let c = Bytes.get format_string fmt_pos in
@@ -311,9 +307,10 @@ module Make(D: Domain.T) = struct
                           | _ -> fill_buffer d fmt_pos 2 dst_off arg_nb
                       end
                     | _ (* = 2 ie previous char is % *) ->
+                      (L.info(fun p -> p "here-7");
                       let arg = Asm.Lval (va_args arg_nb) in
                       let fmt_pos', buf_len, d' = format_arg d fmt_pos dst_off arg in
-                      fill_buffer d' fmt_pos' 0 (dst_off+buf_len) (arg_nb+1)
+                      fill_buffer d' fmt_pos' 0 (dst_off+buf_len) (arg_nb+1))
                 else
                     (* add a zero to the end of the buffer *)
                     match to_buffer with
@@ -354,7 +351,7 @@ module Make(D: Domain.T) = struct
       let d', is_tainted = print d ret format_addr va_args None in
       d', is_tainted
 
-    let printf_chk (ip: Data.Address.t) calling_ip d ret args = printf ip calling_ip d ret (shift args 1) 
+    let printf_chk (ip: Data.Address.t) calling_ip d ret args = printf ip calling_ip d ret (shift args 1)
 
     let puts (_ip: Data.Address.t) _ d ret args =
       let str = Asm.Lval (args 0) in
@@ -364,46 +361,6 @@ module Make(D: Domain.T) = struct
       L.info (fun p -> p "--- end of puts--");
       d', taint
 
-
-    let write _ip _ d ret args =
-      L.info (fun p -> p "write output");
-      let fd =
-        try
-         Z.to_int (D.value_of_exp d (Asm.Lval (args 0)))
-        with _ -> L.abort (fun p -> p "imprecise file descriptor as argument of write")
-      in
-      if fd = 1 then
-        let buf = Asm.Lval (args 1) in
-        try
-          let char_nb = Z.to_int (D.value_of_exp d (Asm.Lval (args 2))) in
-          let d', len = D.print_chars d buf char_nb None in
-          let d', taint = D.set ret (Asm.Const (Data.Word.of_int (Z.of_int len) !Config.operand_sz)) d' in
-          L.info (fun p -> p "--- end of write--");
-          d', taint
-        with Exceptions.Too_many_concrete_elements _ -> L.abort (fun p -> p "imprecise number of char to write")
-      else
-        L.abort (fun p -> p "write output implemented only for stdout")
-      
-    let stubs = Hashtbl.create 5
-
-    let signal_process d call_conv: domain_t * Taint.Set.t * Asm.stmt list =
-      let args = call_conv.Asm.arguments in
-      let d, taint, stmts =
-        try
-        let int_nb = Z.to_int (D.value_of_exp d (Asm.Lval (args 0))) in
-        let addrs, taint = D.mem_to_addresses d (Asm.Lval (args 1)) in
-        (* int_nb and addr has to be concrete values *)
-        match Data.Address.Set.elements addrs with
-        | [a] -> d, taint, [Asm.Directive (Asm.Handler (int_nb, a))]
-        | _ -> raise (Exceptions.Too_many_concrete_elements "several possible handler addresses")
-        with Exceptions.Too_many_concrete_elements _ ->
-          L.warn (fun p -> p "uncomputable argument of signal call (signal number or handler address). Skipped");
-          d, Taint.Set.singleton Taint.U, []
-      in
-      let cleanup_stmts = (call_conv.Asm.callee_cleanup 2) in
-      d, taint, stmts@cleanup_stmts
-
-             
     let putchar (_ip) _ d ret args =
       let str = Asm.Lval (args 0) in
       L.info (fun p -> p "putchar output:");
@@ -418,16 +375,15 @@ module Make(D: Domain.T) = struct
         D.taint_lval ret taint_mask d'
       else
         d', Taint.Set.singleton Taint.U
-      
+
     let getchar = getc
-                                                 
+
     let bin_exit (_ip) _ _d _ret _args =
       raise (Exceptions.Stop "on exit call")
 
+    let stubs = Hashtbl.create 5
+
     let process ip calling_ip d fun_name call_conv: domain_t * Taint.Set.t * Asm.stmt list =
-       if String.compare fun_name "signal" = 0 then
-        signal_process d call_conv 
-      else     
       let apply_f, arg_nb =
         try Hashtbl.find stubs fun_name
         with Not_found -> L.abort (fun p -> p "No stub available for function [%s]" fun_name)
@@ -436,7 +392,7 @@ module Make(D: Domain.T) = struct
         try apply_f ip calling_ip d call_conv.Asm.return call_conv.Asm.arguments
         with
         | Exit -> d, Taint.Set.singleton Taint.U
-        | Exceptions.Use_after_free _ as e -> raise e 
+        | Exceptions.Use_after_free _ as e -> raise e
         | Exceptions.Double_free -> raise Exceptions.Double_free
         | Exceptions.Null_deref _ as e  -> raise e
         | Exceptions.Stop _ as e -> raise e
@@ -444,15 +400,12 @@ module Make(D: Domain.T) = struct
         | e ->
           L.exc e (fun p -> p "error while processing stub [%s]" fun_name);
           L.warn (fun p -> p "uncomputable stub for [%s]. Skipped." fun_name);
-          d, Taint.Set.singleton Taint.U 
-           
+          d, Taint.Set.singleton Taint.U
+
       in
       let cleanup_stmts = (call_conv.Asm.callee_cleanup arg_nb) in
       d', taint, cleanup_stmts
 
-
-  
-        
     let skip d f call_conv: domain_t * Taint.Set.t * Asm.stmt list =
       let arg_nb, ret_val = Hashtbl.find Config.funSkipTbl f in
       let d, taint =
@@ -461,67 +414,32 @@ module Make(D: Domain.T) = struct
         | Some ret_val' ->
            let sz = Config.size_of_config ret_val' in
            match call_conv.Asm.return with
-           | Asm.V (Asm.T r)  when Register.size r = sz -> D.set_register_from_config r ret_val' d 
+           | Asm.V (Asm.T r)  when Register.size r = sz -> D.set_register_from_config r ret_val' d
            | Asm.M (e, n) when sz = n ->
               let addrs, _ = D.mem_to_addresses d e in
               let d', taint' =
                 match Data.Address.Set.elements addrs with
-                | [a] ->     
+                | [a] ->
                    D.set_memory_from_config a  ret_val' 1 d
                 | _ -> D.forget d, Taint.Set.singleton Taint.TOP (* TODO: be more precise *)
               in
               d', taint'
-              
+
            | _ -> D.forget d, Taint.Set.singleton Taint.TOP (* TODO: be more precise *)
       in
       let cleanup_stmts = call_conv.Asm.callee_cleanup (Z.to_int arg_nb) in
       d,taint, cleanup_stmts
 
-    let default_handler sig_nb =
-      (* see man 7 signal. Implementation of POSIX.1-2001 *)
-      let ignore_sig sig_text =
-        L.analysis (fun p -> p "Handling signal %s: ignored" sig_text);
-        []
-      in
-      let abort sig_text =
-        L.analysis (fun p -> p "Handling signal %s: analysis stops" sig_text);
-        L.abort (fun p -> p "see above")
-      in
-      match sig_nb with
-      | 1 (* SIGHUP *) -> abort "SIGHUP"
-      | 2 (* SIGINT *) -> abort "SIGINT"                        
-      | 3 (* SIGQUIT *) -> abort "SIGQUIT"
-      | 4 (* SIGIL *) -> abort "SIGIL"
-      | 5 (* SIGTRAP *) -> abort "SIGTRAP"
-      | 6 (* SIGABRT *) -> abort "SIGABRT"
-      | 7 | 10 (* SIGBUS *) -> abort "SIGBUS"
-      | 8 (* SIGFPE *) -> abort "SIGFPE"
-      | 9 (* SIGKILL *) -> abort "SIGKILL"
-      | 11 (* SIGSEGV *) -> abort "SIGSEGV"
-      | 12 | 31 (* SIGSYS *) -> abort "SIGSYS"
-      | 13 (* SIGPIPE *) -> abort "SIGPIPE"
-      | 14 (* SIGALRM *) -> ignore_sig "SIGALRM"
-      | 15 (* SIGTERM *) -> abort "SIGTERM"
-      | 16 (* SIGUSR1 *) -> ignore_sig "SIGUSR1"
-      | 17 | 18 (* SIGCHLD *) -> abort "SIGCHLD"
-      | 19 | 25 (* SIGCONT *) -> ignore_sig "SIGCONT"
-      | 20 | 24 (* SIGTSTP *) -> ignore_sig "SIGSTP"
-      | 26 (* SIGTTIN *) -> ignore_sig "SIGTTIN"
-      | 27 (* SIGTTOU *) -> ignore_sig "SIGTTOU"
-      | _ -> L.analysis (fun p -> p "received Illegal signal %d. Ignored" sig_nb); []
-      
     let init () =
       Hashtbl.replace stubs "memcpy"        (memcpy,      3);
       Hashtbl.replace stubs "memcmp"        (memcmp,      3);
       Hashtbl.replace stubs "memset"        (memset,      3);
       Hashtbl.replace stubs "sprintf"       (sprintf,     0);
       Hashtbl.replace stubs "printf"        (printf,      0);
-      Hashtbl.replace stubs "write" (write, 3);
       Hashtbl.replace stubs "__sprintf_chk" (sprintf_chk, 0);
       Hashtbl.replace stubs "__printf_chk"  (printf_chk,  0);
       Hashtbl.replace stubs "puts"          (puts,        1);
       Hashtbl.replace stubs "strlen"        (strlen,      1);
-      Hashtbl.replace stubs "signal"        ((fun _ _ _ _ _ -> raise (Exceptions.Stop "on signal that stops execution of the program")),  0); (* special treatment for signal see signal_process *)
       Hashtbl.replace stubs "putchar"        (putchar,      1);
       Hashtbl.replace stubs "getchar" (getchar, 0);
       Hashtbl.replace stubs "getc" (getc, 1);
diff --git a/ocaml/src/fixpoint/stubs.mli b/ocaml/src/fixpoint/stubs.mli
new file mode 100644
index 00000000..e7743b43
--- /dev/null
+++ b/ocaml/src/fixpoint/stubs.mli
@@ -0,0 +1,41 @@
+(*
+    This file is part of BinCAT.
+    Copyright 2014-2019 - Airbus
+
+    BinCAT is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Affero General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or (at your
+    option) any later version.
+
+    BinCAT is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Affero General Public License for more details.
+
+    You should have received a copy of the GNU Affero General Public License
+    along with BinCAT.  If not, see <http://www.gnu.org/licenses/>.
+*)
+
+module type T =
+sig
+  type domain_t
+
+  (** [process ip calling_ip d fun args] applies to the abstract value [d] the tranfer function corresponding to the call to the function library named [fun] with arguments [args]. Parameter [ip] is the address in the code of the call
+It returns also a boolean true whenever the result is tainted. Parameter [calling_ip] is the ip of the call site of the function to stub *)
+  val process : Data.Address.t -> Data.Address.t option -> domain_t -> string -> Asm.calling_convention_t -> 
+    domain_t * Taint.Set.t * Asm.stmt list
+
+  val skip: domain_t -> Config.fun_t -> Asm.calling_convention_t -> domain_t *  Taint.Set.t * Asm.stmt list
+    
+  val init: unit -> unit
+
+
+  val stubs : (string, (Data.Address.t -> Data.Address.t option -> domain_t -> Asm.lval -> (int -> Asm.lval) -> 
+                         domain_t * Taint.Set.t) * int) Hashtbl.t
+
+
+end
+
+(** functor to generate transfer functions on the given abstract value that simulates the behavior of common library functions *)
+
+module Make: functor (D: Domain.T) -> (T with type domain_t := D.t)
diff --git a/ocaml/src/frontend/lexer.mll b/ocaml/src/frontend/lexer.mll
index 6df640e2..3cf9ca1c 100644
--- a/ocaml/src/frontend/lexer.mll
+++ b/ocaml/src/frontend/lexer.mll
@@ -114,6 +114,7 @@ let _ =
     "forward_binary", FORWARD_BIN;
     "forward_cfa", FORWARD_CFA;
     "backward", BACKWARD;
+    "cfg", CFG;
     (* misc left operands *)
     "headers", HEADER;
     "override", OVERRIDE;
@@ -122,13 +123,7 @@ let _ =
     "TAINT_ALL", TAINT_ALL;
     "TAINT_NONE", TAINT_NONE;
     "null", NULL;
-    "os", OS;
-    "linux", LINUX;
-    "windows", WINDOWS;
     "taint_input", TAINT_INPUT;
-    "MPX", MPX;
-    "enabled", ENABLED;
-    "disabled", DISABLED;
     ]
 
 let strip_int s =
diff --git a/ocaml/src/frontend/parser.conflicts b/ocaml/src/frontend/parser.conflicts
new file mode 100644
index 00000000..be917956
--- /dev/null
+++ b/ocaml/src/frontend/parser.conflicts
@@ -0,0 +1,30 @@
+
+** Conflict (reduce/reduce) in state 67.
+** Tokens involved: LEFT_SQ_BRACKET EOF
+** The following explanations concentrate on token LEFT_SQ_BRACKET.
+** This state is reached from process after reading:
+
+LEFT_SQ_BRACKET X86 RIGHT_SQ_BRACKET x86_item 
+
+** The derivations that appear below have the following common factor:
+** (The question mark symbol (?) represents the spot where the derivations begin to differ.)
+
+process 
+sections EOF 
+sections section // lookahead token appears because section can begin with LEFT_SQ_BRACKET
+section // lookahead token is inherited
+LEFT_SQ_BRACKET X86 RIGHT_SQ_BRACKET x86_section // lookahead token is inherited
+                                     (?)
+
+** In state 67, looking ahead at LEFT_SQ_BRACKET, reducing production
+** x86_section -> 
+** is permitted because of the following sub-derivation:
+
+x86_item x86_section // lookahead token is inherited
+         . 
+
+** In state 67, looking ahead at LEFT_SQ_BRACKET, reducing production
+** x86_section -> x86_item 
+** is permitted because of the following sub-derivation:
+
+x86_item . 
diff --git a/ocaml/src/frontend/parser.mly b/ocaml/src/frontend/parser.mly
index 4dc04649..6ecb97de 100644
--- a/ocaml/src/frontend/parser.mly
+++ b/ocaml/src/frontend/parser.mly
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -118,9 +118,9 @@
 
       (** check that the version matches the one we support *)
       let check_ini_version input_version =
-        let supported_version = 4 in
-        if input_version != supported_version then
-          L.abort (fun p->p "Invalid configuration version: '%d', expected: '%d'" input_version supported_version);;
+    let supported_version = 4 in
+    if input_version != supported_version then
+      L.abort (fun p->p "Invalid configuration version: '%d', expected: '%d'" input_version supported_version);;
 
       (** footer function *)
       let check_context () =
@@ -154,7 +154,7 @@
           List.iter add (List.rev funs)
         in
         Hashtbl.iter add_tainting_rules libraries;
-        (* complete the table of function rules with type information *)
+    (* complete the table of function rules with type information *)
         List.iter (fun header ->
         try
           L.debug (fun p -> p "Open npk file [%s]" header);
@@ -162,10 +162,7 @@
           List.iter (fun (s, f) ->
             L.debug (fun p -> p "  - loaded type for [%s]" s);
         Hashtbl.add Config.typing_rules s f.TypedC.function_type) p.TypedC.function_declarations
-        with e -> L.exc e (fun p -> p "failed to load header %s" header)) !npk_headers;
-      (* update the os type *)
-        if !Config.format = Config.PE then
-          Config.os := Config.Windows
+        with _e -> L.error (fun p -> p "failed to load header %s" header)) !npk_headers
     ;;
 
     %}
@@ -174,13 +171,12 @@
 %token ANALYZER INI_VERSION UNROLL FUN_UNROLL DS CS SS ES FS GS FS_BASE GS_BASE FLAT SEGMENTED STATE
 %token FORMAT RAW MANUAL PE ELF ELFOBJ ENTRYPOINT FILEPATH MASK MODE REAL PROTECTED
 %token LANGLE_BRACKET RANGLE_BRACKET LPAREN RPAREN COMMA UNDERSCORE
-%token GDT CUT ASSERT IMPORTS CALL U T STACK HEAP SEMI_COLON PROGRAM
+%token GDT CUT ASSERT IMPORTS CALL U T STACK HEAP SEMI_COLON PROGRAM CFG
 %token ANALYSIS FORWARD_BIN FORWARD_CFA BACKWARD STORE_MCFA IN_MCFA_FILE OUT_MCFA_FILE HEADER
 %token OVERRIDE TAINT_NONE TAINT_ALL SECTION SECTIONS LOGLEVEL ARCHITECTURE X86 ARMV7 ARMV8
 %token ENDIANNESS LITTLE BIG EXT_SYM_MAX_SIZE NOP LOAD_ELF_COREDUMP FUN_SKIP KSET_BOUND
 %token POWERPC SVR SYSV MS PROCESSOR_VERSION NULL X64 LOAD_PE_CRASHDUMP RV32I RV64I
-%token IGNORE_UNKNOWN_RELOCATIONS OS WINDOWS LINUX IDA TAINT_INPUT
-%token MPX ENABLED DISABLED
+%token IGNORE_UNKNOWN_RELOCATIONS IDA TAINT_INPUT
 %token <string> STRING
 %token <string> HEX_BYTES
 %token <string> HEAP_HEX_BYTES
@@ -208,6 +204,7 @@
     | LEFT_SQ_BRACKET l=libname RIGHT_SQ_BRACKET lib=library { l; lib }
     | LEFT_SQ_BRACKET ASSERT RIGHT_SQ_BRACKET r=assert_rules { r }
     | LEFT_SQ_BRACKET IMPORTS RIGHT_SQ_BRACKET i=imports     { i }
+    | LEFT_SQ_BRACKET CFG RIGHT_SQ_BRACKET c=cfg  { c }
     | LEFT_SQ_BRACKET OVERRIDE RIGHT_SQ_BRACKET o=overrides     { o }
     | LEFT_SQ_BRACKET ARMV7 RIGHT_SQ_BRACKET a=armv7_section     { a }
     | LEFT_SQ_BRACKET ARMV8 RIGHT_SQ_BRACKET a=armv8_section     { a }
@@ -284,6 +281,19 @@
                                                  Hashtbl.replace Config.import_tbl a (libname, fname);
                                                  Hashtbl.replace Config.import_tbl_rev fname a
                                                }
+    cfg:
+    | { () }
+    | c=cfg_entry l=cfg { c ; l }
+
+
+    //{ List.iter (fun a -> Config.nopAddresses := Config.SAddresses.add a !Config.nopAddresses) l }
+    cfg_entry:
+    | addr=INT EQUAL regname=STRING LPAREN addrs=addresses RPAREN {
+      Hashtbl.replace Config.cfgTbl addr (regname, addrs)
+    }
+
+    // addr_list:
+    //   arg_list = delimited (LPAREN, separated_list (COMMA, INT), RPAREN) { arg_list }
 
       npk:
     | { [] }
@@ -323,9 +333,7 @@
     | ARCHITECTURE EQUAL a=architecture  { update_mandatory ARCHITECTURE; Config.architecture := a }
     | FILEPATH EQUAL f=QUOTED_STRING     { update_mandatory FILEPATH; Config.binary := f }
     | FORMAT EQUAL f=format      { update_mandatory FORMAT; Config.format := f }
-    | NULL EQUAL v=INT { Config.null_cst := v }
-    | OS EQUAL s=os_kind { Config.os := s }
-    | MPX EQUAL b=mpx_enabled { Config.mpx := b }
+    | NULL EQUAL v=INT { Config.null_cst := v}
 
       format:
     | PE  { Config.PE }
@@ -371,13 +379,7 @@
     | GS_BASE EQUAL i=init       { update_x64_mandatory GS_BASE; init_register "gs_base" i }
     | GDT LEFT_SQ_BRACKET i=INT RIGHT_SQ_BRACKET EQUAL v=INT { update_x64_mandatory GDT; Hashtbl.replace Config.gdt i v }
 
-    os_kind:
-    | WINDOWS { Config.Windows }
-    | LINUX { Config.Linux }
 
-    mpx_enabled:
-    | ENABLED { true }
-    | DISABLED { false }
     memmodel:
     | FLAT  { Config.Flat }
     | SEGMENTED { Config.Segmented }
@@ -472,7 +474,7 @@
 
     fun_skip:
     | s=STRING LPAREN p=pair_skip RPAREN { Config.Fun_name s, p }                        
-    | i = INT LPAREN p=pair_skip RPAREN { Config.Fun_addr i, p }
+    | i=INT LPAREN p=pair_skip RPAREN { Config.Fun_addr i, p }
       
     pair_skip:
     | bytes=INT COMMA ret=init { bytes, Some ret }
diff --git a/ocaml/src/loaders/custom_section.ml b/ocaml/src/loaders/custom_section.ml
new file mode 100644
index 00000000..f89c2745
--- /dev/null
+++ b/ocaml/src/loaders/custom_section.ml
@@ -0,0 +1,78 @@
+(*
+    This file is part of BinCAT.
+    Copyright 2014-2017 - Airbus Group
+
+    BinCAT is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Affero General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or (at your
+    option) any later version.
+
+    BinCAT is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Affero General Public License for more details.
+
+    You should have received a copy of the GNU Affero General Public License
+    along with BinCAT.  If not, see <http://www.gnu.org/licenses/>.
+*)
+
+(* manual loader using [sections] section in config file *)
+
+module L = Log.Make(struct let name = "loader.custom_section" end)
+
+open Mapped_mem
+
+let section_from_config_entry filename mapped_file config_section_entry =
+  match config_section_entry
+  with (lvirt_addr, lvirt_size, lraw_addr, lraw_size, lname) ->
+    {
+      mapped_file_name = filename ;
+      mapped_file = mapped_file ;
+      virt_addr = Data.Address.global_of_int lvirt_addr ;
+      virt_addr_end = Data.Address.global_of_int (Z.add lvirt_addr lvirt_size) ;
+      virt_size = lvirt_size;
+      raw_addr = lraw_addr;
+      raw_addr_end = Z.add lraw_addr lraw_size;
+      raw_size = lraw_size;
+      name = lname;
+    }
+
+let top_section filepath mapped_file max_addr =
+  {
+    mapped_file_name = filepath;
+    mapped_file = mapped_file;
+    virt_addr = Data.Address.global_of_int max_addr;
+    virt_addr_end = Data.Address.global_of_int (Z.add max_addr (Z.of_int 0x100));
+    name = "topsection";
+    raw_addr = Z.zero ;
+    raw_addr_end = Z.zero ;
+    raw_size = Z.zero ;
+    virt_size = Z.of_int 0x100;
+  }
+
+let call_section_from_entry (filepath: string) mapped_file (call_number: int) (start_addr: Z.t) =
+  let end_addr = Z.add start_addr (Z.of_int 0x100) in
+  {
+    mapped_file_name = filepath;
+    mapped_file = mapped_file;
+    virt_addr = Data.Address.global_of_int start_addr;
+    virt_addr_end = Data.Address.global_of_int end_addr;
+    name = "call" ^ string_of_int call_number;
+    raw_addr = Z.zero ;
+    raw_addr_end = Z.zero ;
+    raw_size = Z.zero ;
+    virt_size = Z.of_int 0x100;
+  }
+
+let get_custom_sections (filepath: string) mapped_file (previous_max: Z.t) =
+  let sections = List.map (fun s -> section_from_config_entry filepath mapped_file s) !Config.sections in
+  let max_addr = List.fold_left (fun acc section -> Z.max (Data.Address.to_int section.virt_addr_end) acc) Z.zero sections in
+  let start_call_addr = Z.add Z.one (Z.max previous_max max_addr) in
+  L.info(fun p -> p "Start of call is %s" (Z.to_string start_call_addr));
+  let call_sections, call_count = Hashtbl.fold ( fun _k _v (sections, index) ->
+    let start_addr = Z.add start_call_addr (Z.of_int (index * 0x100)) in
+    (call_section_from_entry filepath mapped_file index start_addr) :: sections, index + 1
+  ) Config.funSkipTbl ([], 0) in
+  let start_top = Z.add Z.one (Z.add start_call_addr (Z.of_int (call_count * 0x100))) in
+  let topsec = top_section filepath mapped_file start_top in
+  sections @ call_sections @ [ topsec ]
diff --git a/ocaml/src/loaders/elf.ml b/ocaml/src/loaders/elf.ml
index d00cdc98..6f259e11 100644
--- a/ocaml/src/loaders/elf.ml
+++ b/ocaml/src/loaders/elf.ml
@@ -21,6 +21,7 @@
 
 open Mapped_mem
 open Elf_core
+open Custom_section
 
 module L = Log.Make(struct let name = "elf" end)
 
@@ -166,16 +167,25 @@ let make_mapped_mem filepath entrypoint =
     let sym_name = sym.Elf_core.p_st_name in
     L.analysis (fun p -> p "REL COPY: %s: no lib to copy value from => ignored" sym_name) in
 
+  let reloc_simple _sym _offset _addend =
+    (* DM: Implementation of RELOC_X86_64 | RELOC_X86_64_32 *)
+    (* let value = Z.add offset addend in
+    let addr = offset in
+    L.debug(fun p -> p "REL SIMPLE: write %s at %s " (Log.zaddr_to_string value) (Log.zaddr_to_string addr));
+    patch_elf elf mapped_file sections addr value in *)
+    () in
+
   let get_reloc_func = function
     | R_ARM_JUMP_SLOT | R_386_JUMP_SLOT | R_AARCH64_JUMP_SLOT | R_X86_64_JUMP_SLOT
       -> reloc_jump_slot (Z.of_int (!Config.address_sz/8))
     | R_ARM_GLOB_DAT | R_386_GLOB_DAT | R_AARCH64_GLOB_DAT | R_X86_64_GLOB_DAT
-      | R_PPC_GLOB_DAT -> reloc_glob_dat (Z.of_int (!Config.address_sz/8))
+      | R_PPC_GLOB_DAT | R_ARM_ABS32 -> reloc_glob_dat (Z.of_int (!Config.address_sz/8))
     | R_386_TLS_TPOFF
     | R_386_32 -> reloc_obj (Z.of_int (!Config.external_symbol_max_size))
     | R_386_PC32 -> reloc_obj_rel (Z.of_int (!Config.external_symbol_max_size))
     | R_386_RELATIVE | R_X86_64_RELATIVE | R_PPC_RELATIVE -> reloc_relative Z.zero
-    | R_ARM_RELATIVE -> fun _ _ _ -> L.debug(fun p -> p "do nothing")
+    | R_X86_64_32 | R_X86_64_64 -> reloc_simple
+    | R_ARM_RELATIVE -> fun _ _ _ -> ()
     | R_PPC_ADDR32 -> reloc_obj_rel (Z.of_int (!Config.external_symbol_max_size))
     | R_PPC_JMP_SLOT -> reloc_jump_slot (Z.of_int (!Config.address_sz/8))
     | R_386_COPY | R_ARM_COPY | R_X86_64_COPY | R_AARCH64_COPY | R_PPC_COPY
@@ -184,7 +194,7 @@ let make_mapped_mem filepath entrypoint =
        let reltype = reloc_type_to_string rt in
        begin
          if (!Config.ignore_unknown_relocations)
-         then
+         then (* R_X86_64_PLT32 *)
            begin
              L.analysis (fun p-> p "Ignored unsupported relocation type [%s]" reltype);
              fun _ _ _ -> ()
@@ -216,7 +226,8 @@ let make_mapped_mem filepath entrypoint =
     raw_size = Z.zero ;
     name = "relocations" ;
   } in
+  L.info(fun p -> p "Min Addr is %s" (Z.to_string min_addr'));
   {
-    sections  = sections @ [ reloc_sec ] ;
+    sections  = sections @ [ reloc_sec ] @ get_custom_sections filepath mapped_file !reloc_external_addr;
     entrypoint = entrypoint ;
   }
diff --git a/ocaml/src/loaders/elf_core.ml b/ocaml/src/loaders/elf_core.ml
index 6f1438e0..cdc2f80b 100644
--- a/ocaml/src/loaders/elf_core.ml
+++ b/ocaml/src/loaders/elf_core.ml
@@ -687,7 +687,7 @@ type reloc_type_t =
  | R_X86_64_32S | R_X86_64_16 | R_X86_64_PC16 | R_X86_64_8 | R_X86_64_PC8 | R_X86_64_PC64
  | R_X86_64_GOTOFF64 | R_X86_64_GOTPC32 | R_X86_64_SIZE32 | R_X86_64_SIZE64 | R_X86_64_IRELATIV
   (* ARM relocation types *)
-  | R_ARM_NONE | R_ARM_COPY | R_ARM_GLOB_DAT | R_ARM_JUMP_SLOT | R_ARM_RELATIVE
+  | R_ARM_NONE | R_ARM_COPY | R_ARM_GLOB_DAT | R_ARM_JUMP_SLOT | R_ARM_RELATIVE | R_ARM_ABS32
   (* AARCH64 relocation types *)
   | R_AARCH64_COPY | R_AARCH64_GLOB_DAT | R_AARCH64_JUMP_SLOT | R_AARCH64_RELATIVE
   | R_AARCH64_TLS_DTPREL64 | R_AARCH64_TLS_DTPMOD64 | R_AARCH64_TLS_TPREL64
@@ -726,6 +726,7 @@ let to_reloc_type r hdr =
        begin
          match r with
          | 0 -> R_ARM_NONE
+         | 2 -> R_ARM_ABS32
          | 20 -> R_ARM_COPY
          | 21 -> R_ARM_GLOB_DAT
          | 22 -> R_ARM_JUMP_SLOT
@@ -781,7 +782,7 @@ let reloc_type_to_string rel =
   | R_X86_64_GOTPC32 -> "R_X86_64_GOTPC32"    | R_X86_64_SIZE32 -> "R_X86_64_SIZE32"        | R_X86_64_SIZE64 -> "R_X86_64_SIZE64"
   | R_X86_64_IRELATIV -> "R_X86_64_IRELATIV"
   | R_ARM_NONE -> "R_ARM_NONE"
-  | R_ARM_COPY -> "R_ARM_COPY" | R_ARM_GLOB_DAT -> "R_ARM_GLOB_DAT"  | R_ARM_JUMP_SLOT -> "R_ARM_JUMP_SLOT" | R_ARM_RELATIVE -> "R_ARM_RELATIVE"
+  | R_ARM_COPY -> "R_ARM_COPY" | R_ARM_GLOB_DAT -> "R_ARM_GLOB_DAT"  | R_ARM_JUMP_SLOT -> "R_ARM_JUMP_SLOT" | R_ARM_RELATIVE -> "R_ARM_RELATIVE" | R_ARM_ABS32 -> "R_ARM_ABS32"
   | R_AARCH64_COPY -> "R_AARCH64_COPY"                 | R_AARCH64_GLOB_DAT -> "R_AARCH64_GLOB_DAT"
   | R_AARCH64_JUMP_SLOT -> "R_AARCH64_JUMP_SLOT"       | R_AARCH64_RELATIVE -> "R_AARCH64_RELATIVE"
   | R_AARCH64_TLS_DTPREL64 -> "R_AARCH64_TLS_DTPREL64" | R_AARCH64_TLS_DTPMOD64 -> "R_AARCH64_TLS_DTPMOD64"
diff --git a/ocaml/src/loaders/manual.ml b/ocaml/src/loaders/manual.ml
index 25a5c538..86b3a540 100644
--- a/ocaml/src/loaders/manual.ml
+++ b/ocaml/src/loaders/manual.ml
@@ -21,27 +21,11 @@
 module L = Log.Make(struct let name = "loader.manual" end)
 
 open Mapped_mem
-
-
-let section_from_config_entry filename mapped_file config_section_entry =
-  match config_section_entry
-  with (lvirt_addr, lvirt_size, lraw_addr, lraw_size, lname) ->
-    {
-      mapped_file_name = filename ;
-      mapped_file = mapped_file ;
-      virt_addr = Data.Address.global_of_int lvirt_addr ;
-      virt_addr_end = Data.Address.global_of_int (Z.add lvirt_addr lvirt_size) ;
-      virt_size = lvirt_size;
-      raw_addr = lraw_addr;
-      raw_addr_end = Z.add lraw_addr lraw_size;
-      raw_size = lraw_size;
-      name = lname;
-    }
+open Custom_section
 
 let make_mapped_mem filepath entrypoint =
   let mapped_file = map_file filepath in
-  let sections = List.map (fun s -> section_from_config_entry filepath mapped_file s) !Config.sections in
   {
-    sections  = sections ;
+    sections  = get_custom_sections filepath mapped_file Z.zero;
     entrypoint = entrypoint ;
-  }
+  }
\ No newline at end of file
diff --git a/ocaml/src/main.ml b/ocaml/src/main.ml
index f91e15ed..5eee41ae 100644
--- a/ocaml/src/main.ml
+++ b/ocaml/src/main.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -18,107 +18,8 @@
 
 module L = Log.Make(struct let name = "main" end)
 
-(** internal auxilliary functor to setup the environment before lauching the interpreter itself *) 
-module IEnv(Stubs: Stubs.T) = struct
+(** Entry points of the library *)
 
-  type import_attrib_t = {
-      mutable ia_name: string;
-      mutable ia_addr: Z.t option;
-      mutable ia_typing_rule: bool;
-      mutable ia_tainting_rule: bool;
-      mutable ia_stub: bool;
-    }
-
-  let dump () =
-    let empty_desc = {
-        ia_name = "n/a";
-        ia_addr = None;
-        ia_typing_rule = false;
-        ia_tainting_rule = false;
-        ia_stub = false;
-      }
-    in
-    let yesno b = if b then "YES" else "no" in
-    let itbl = Hashtbl.create 5 in
-    Hashtbl.iter (fun a (libname, fname) ->
-        let func_desc = { empty_desc with
-                          ia_name = libname ^ "." ^ fname;
-                          ia_addr = Some a;
-                        }
-        in
-        Hashtbl.add itbl fname func_desc) Config.import_tbl;
-    Hashtbl.iter (fun name _typing_rule ->
-        let func_desc =
-          try
-            Hashtbl.find itbl name
-          with Not_found -> { empty_desc with ia_name = "?." ^ name } in
-        Hashtbl.replace itbl name { func_desc with ia_typing_rule=true })  Config.typing_rules;
-    Hashtbl.iter (fun  (libname, name) (_callconv, _taint_ret, _taint_args) ->
-        let func_desc =
-          try
-            Hashtbl.find itbl name
-          with Not_found -> { empty_desc with ia_name = libname ^ "." ^ name } in
-        Hashtbl.replace itbl name { func_desc with ia_tainting_rule=true })  Config.tainting_rules;
-    Hashtbl.iter (fun name _ ->
-        let func_desc =
-          try
-            Hashtbl.find itbl name
-          with Not_found -> { empty_desc with ia_name = "?." ^ name } in
-        Hashtbl.replace itbl name { func_desc with ia_stub=true })  Stubs.stubs;
-    
-    let addr_to_str x = match x with
-      | Some a ->
-         begin (* too bad we can't format "%%0%ix" to make a new format *)
-           match !Config.address_sz with
-           | 16 -> Printf.sprintf "%04x" (Z.to_int a)
-           | 32 -> Printf.sprintf "%08x" (Z.to_int a)
-           | 64 -> Printf.sprintf "%016x" (Z.to_int a)
-           | _ ->  Printf.sprintf "%x" (Z.to_int a)
-         end
-      | None -> "?"
-    in
-    L.info (fun p -> p "Dumping state of imports");
-    Hashtbl.iter (fun _name func_desc ->
-        L.info (fun p -> p "| IMPORT %-30s addr=%-16s typing=%-3s tainting=%-3s stub=%-3s"
-                           func_desc.ia_name (addr_to_str func_desc.ia_addr)
-                           (yesno func_desc.ia_typing_rule) (yesno func_desc.ia_tainting_rule) (yesno func_desc.ia_stub)))
-      itbl;
-      L.info (fun p -> p "End of dump")
-      
-  let mapped_infos () =
-    let do_map_file =
-      match !Config.format with
-      | Config.PE -> L.abort (fun p -> p "PE file format not implemented yet")
-      | Config.ELF | Config.ELFOBJ -> Elf.make_mapped_mem
-      | Config.RAW -> Raw.make_mapped_mem
-      | Config.MANUAL -> Manual.make_mapped_mem
-    in
-    let exe_map = do_map_file !Config.binary (Data.Address.global_of_int !Config.ep) in
-    let complete_map = Elf_coredump.add_coredumps exe_map !Config.dumps in
-    Mapped_mem.current_mapping := Some complete_map;
-    if L.log_info2 () then
-      begin
-        L.info2(fun p -> p "-- Dump of mapped sections");
-        List.iter
-          (fun sec ->
-            L.info2 (
-                fun p -> p "Mapped section vaddr=%s-%s (0x%s bytes) paddr=%s->%s (0x%s bytes) %-15s %s"
-                           (Log.zaddr_to_string (Data.Address.to_int sec.Mapped_mem.virt_addr))
-                           (Log.zaddr_to_string (Data.Address.to_int sec.Mapped_mem.virt_addr_end))
-                           (Log.zaddr_to_string sec.Mapped_mem.virt_size)
-                           (Log.zaddr_to_string sec.Mapped_mem.raw_addr)
-                           (Log.zaddr_to_string sec.Mapped_mem.raw_addr_end)
-                           (Log.zaddr_to_string sec.Mapped_mem.raw_size)
-                           sec.Mapped_mem.name
-                           sec.Mapped_mem.mapped_file_name))
-          complete_map.Mapped_mem.sections;
-        L.info2(fun p -> p "-- End of mapped sections dump")
-        end
-    
-end
-                           
-
-                           
 (** [process cfile rfile lfile] launches an analysis run such that:
     - [configfile] is the name of the configuration file
     - [resultfile] is the name of the result file
@@ -129,6 +30,7 @@ let process (configfile:string) (resultfile:string) (logfile:string): unit =
   Taint.clear();
   Dump.clear();
   Register.clear();
+  (* setting the log file *)
   Log.init logfile;
   L.info (fun m -> m "BinCAT version %s" Bincat_ver.version_string);
   try
@@ -171,14 +73,38 @@ let process (configfile:string) (resultfile:string) (logfile:string): unit =
     (* override config with arguments from command line *)
     Config.apply_arg_options();
 
-    
-
     (* generating modules needed for the analysis wrt to the provided configuration *)
-    
+    let do_map_file =
+      match !Config.format with
+      | Config.PE -> L.abort (fun p -> p "PE file format not implemented yet")
+      | Config.ELF | Config.ELFOBJ -> Elf.make_mapped_mem
+      | Config.RAW -> Raw.make_mapped_mem
+      | Config.MANUAL -> Manual.make_mapped_mem
+    in
+    let exe_map = do_map_file !Config.binary (Data.Address.global_of_int !Config.ep) in
+    let complete_map = Elf_coredump.add_coredumps exe_map !Config.dumps in
+    Mapped_mem.current_mapping := Some complete_map;
+    if L.log_info2 () then
+      begin
+        L.info2(fun p -> p "-- Dump of mapped sections");
+        List.iter
+          (fun sec ->
+            L.info2 (
+                fun p -> p "Mapped section vaddr=%s-%s (0x%s bytes) paddr=%s->%s (0x%s bytes) %-15s %s"
+                           (Log.zaddr_to_string (Data.Address.to_int sec.Mapped_mem.virt_addr))
+                           (Log.zaddr_to_string (Data.Address.to_int sec.Mapped_mem.virt_addr_end))
+                           (Log.zaddr_to_string sec.Mapped_mem.virt_size)
+                           (Log.zaddr_to_string sec.Mapped_mem.raw_addr)
+                           (Log.zaddr_to_string sec.Mapped_mem.raw_addr_end)
+                           (Log.zaddr_to_string sec.Mapped_mem.raw_size)
+                           sec.Mapped_mem.name
+                           sec.Mapped_mem.mapped_file_name))
+              complete_map.Mapped_mem.sections;
+        L.info2(fun p -> p "-- End of mapped sections dump");
+      end;
     let module Vector    = Vector.Make(Reduced_bit_tainting) in
     let module Pointer   = Pointer.Make(Vector) in
     let module Domain   = Reduced_unrel_typenv_heap.Make(Pointer) in
-   
     let decoder =
       match !Config.architecture with
       | Config.X86 -> (module Core_x86.Make(Core_x86.X86): Decoder.Make)
@@ -189,12 +115,7 @@ let process (configfile:string) (resultfile:string) (logfile:string): unit =
       | _ -> failwith "Decoder still in progress"
     in
     let module Decoder = (val decoder: Decoder.Make) in
-    let module Stubs = Stubs.Make(Domain) in
-    let module Interpreter = Interpreter.Make(Domain)(Decoder)(Stubs) in
-    let module IEnv = IEnv(Stubs) in
-
-    IEnv.mapped_infos();
-    IEnv.dump();
+    let module Interpreter = Interpreter.Make(Domain)(Decoder) in
     (* defining the dump function to provide to the fixpoint engine *)
     let dump cfa = Interpreter.Cfa.print resultfile cfa in
 
@@ -224,12 +145,12 @@ let process (configfile:string) (resultfile:string) (logfile:string): unit =
          (* 7: generate the initial cfa with only an initial state *)
          let ep' = Data.Address.of_int Data.Address.Global !Config.ep !Config.address_sz in
          Interpreter.make_registers();
-         let s = Interpreter.Cfa.init_state ep' Stubs.default_handler in
+         let s = Interpreter.Cfa.init_state ep' in
          let g = Interpreter.Cfa.create () in
          Interpreter.Cfa.add_state g s;
          let cfa =
            match !Mapped_mem.current_mapping with
-            | Some mm -> Interpreter.Forward.from_bin mm g s dump
+            | Some mm -> Interpreter.forward_bin mm g s dump
             | None -> L.abort(fun p -> p "File to be analysed not mapped")
           in
           (* launch an interleaving of backward/forward if an inferred property can be backward propagated *)
@@ -239,10 +160,10 @@ let process (configfile:string) (resultfile:string) (logfile:string): unit =
             cfa
 
       (* forward analysis from a CFA *)
-      | Config.Forward Config.Cfa -> from_cfa Interpreter.Forward.from_cfa
+      | Config.Forward Config.Cfa -> from_cfa Interpreter.forward_cfa
 
       (* backward analysis from a CFA *)
-      | Config.Backward -> from_cfa Interpreter.Backward.from_cfa
+      | Config.Backward -> from_cfa Interpreter.backward
     in
 
     (* dumping results *)
diff --git a/ocaml/src/npk/Makefile b/ocaml/src/npk/Makefile
index 5f3c14d4..45db5675 100644
--- a/ocaml/src/npk/Makefile
+++ b/ocaml/src/npk/Makefile
@@ -15,6 +15,7 @@ ML=\
   utils/listUtils.ml\
   utils/strSet.ml\
   newspeak/conf.ml\
+  newspeak/eBigInt.ml\
   newspeak/temps.ml\
   newspeak/newspeak.ml\
   newspeak/npkcontext.ml\
@@ -70,6 +71,7 @@ MLI=\
   newspeak/conf.mli\
   newspeak/lowspeak.mli\
   newspeak/x2newspeak.mli\
+  newspeak/eBigInt.mli\
   newspeak/npkil.mli\
   newspeak/linker.mli\
   newspeak/npk2lpk.mli\
@@ -81,8 +83,8 @@ OPTS-newspeak := -w -7
 OPTS-lowspeak := -w -7
 OPTS-npk2lpk := -w -7
 
-EXTLIB := str unix graph zarith bigarray
-PACKAGES := ocamlgraph zarith
+EXTLIB := nums str unix graph zarith bigarray
+PACKAGES := ocamlgraph zarith num
 
 EXTLIBINCL := $(foreach P,$(PACKAGES), -I $(shell ocamlfind query $(P)))
 LIBINCL = $(EXTLIBINCL) -I utils -I newspeak -I c2newspeak
diff --git a/ocaml/src/npk/newspeak/cir.ml b/ocaml/src/npk/newspeak/cir.ml
index 14ef8c8e..82f3a084 100644
--- a/ocaml/src/npk/newspeak/cir.ml
+++ b/ocaml/src/npk/newspeak/cir.ml
@@ -148,7 +148,7 @@ let string_of_ftyp (args_t, ret_t) =
 
 let rec string_of_exp margin e =
   match e with
-      Const (CInt i) -> Big_int_Z.string_of_big_int (Npk.Nat.to_z i)
+      Const (CInt i) -> EBigInt.string_of_big_int (Npk.Nat.to_big_int i)
     | Const _ -> "cst"
     | Lval (lv, _) -> string_of_lv margin lv
     | AddrOf (lv, t) -> "&("^(string_of_lv margin lv)^")_"^(string_of_typ t)
@@ -484,7 +484,7 @@ let rec mask e1 e2 =
       | e1, Unop(Npkil.BNot _, e2') -> e1, e2'
       | _, _ -> Npkcontext.report_error "Cir.eval_exp" "static expression expected"
   in
-  let n1 = Npk.Nat.to_z (eval_exp e1) in
+  let n1 = Npk.Nat.to_big_int (eval_exp e1) in
   let n2 = 
     try 
       Npk.Nat.to_int (eval_exp e2) 
@@ -498,51 +498,51 @@ let rec mask e1 e2 =
 	    268435455; 536870911; 1073741823 ]
   in
   if List.mem n2 l then
-    let m = Big_int_Z.big_int_of_int (n2+1)  in
-      Big_int_Z.mult_big_int (Big_int_Z.div_big_int n1 m) m
+    let m = EBigInt.big_int_of_int (n2+1)  in
+      EBigInt.mult_big_int (EBigInt.div_big_int n1 m) m
   else Npkcontext.report_error "Cir.eval_exp" "static expression expected"
 
 and eval_exp e =
   let apply_bop op v1 v2 =
     match op with
-	Npk.PlusI -> Big_int_Z.add_big_int v1 v2
-      | Npk.MinusI -> Big_int_Z.sub_big_int v1 v2
-      | Npk.MultI -> Big_int_Z.mult_big_int v1 v2
+	Npk.PlusI -> EBigInt.add_big_int v1 v2
+      | Npk.MinusI -> EBigInt.sub_big_int v1 v2
+      | Npk.MultI -> EBigInt.mult_big_int v1 v2
       | Npk.DivI -> 
-	  if (Big_int_Z.compare_big_int v2 Big_int_Z.zero_big_int = 0) 
+	  if (EBigInt.compare_big_int v2 EBigInt.zero_big_int = 0) 
 	  then Npkcontext.report_error "Cir.eval_exp" "division by zero";
-	  Big_int_Z.div_big_int v1 v2
+	  EBigInt.div_big_int v1 v2
       | Npk.Shiftlt -> 
-	  let p = Big_int_Z.power_int_positive_big_int 2 v2 in
-	    Big_int_Z.mult_big_int v1 p
+	  let p = EBigInt.power_int_positive_big_int 2 v2 in
+	    EBigInt.mult_big_int v1 p
       | Npk.Shiftrt -> 
-	  let p = Big_int_Z.power_int_positive_big_int 2 v2 in
-	    Big_int_Z.div_big_int v1 p
+	  let p = EBigInt.power_int_positive_big_int 2 v2 in
+	    EBigInt.div_big_int v1 p
       | Npk.Eq (Npk.Int _) ->
-	  if Big_int_Z.compare_big_int v1 v2 = 0 then Big_int_Z.unit_big_int
-	  else Big_int_Z.zero_big_int
+	  if EBigInt.compare_big_int v1 v2 = 0 then EBigInt.unit_big_int
+	  else EBigInt.zero_big_int
       | Npk.Gt (Npk.Int _) -> 
-	  if Big_int_Z.compare_big_int v1 v2 > 0 then Big_int_Z.unit_big_int
-	  else Big_int_Z.zero_big_int
-      | Npk.PlusPI -> Big_int_Z.add_big_int v1 v2
+	  if EBigInt.compare_big_int v1 v2 > 0 then EBigInt.unit_big_int
+	  else EBigInt.zero_big_int
+      | Npk.PlusPI -> EBigInt.add_big_int v1 v2
       | Npk.BAnd _ ->
-	  if Big_int_Z.sign_big_int v1 < 0 || Big_int_Z.sign_big_int v2 < 0 then 
+	  if EBigInt.sign_big_int v1 < 0 || EBigInt.sign_big_int v2 < 0 then 
 	    Npkcontext.report_error "Cir.eval_exp" "static expression expected";
-	  Big_int_Z.and_big_int v1 v2
+	  EBigInt.and_big_int v1 v2
       | Npk.BOr _ -> 
-	  if Big_int_Z.sign_big_int v1 < 0 || Big_int_Z.sign_big_int v2 < 0 then
+	  if EBigInt.sign_big_int v1 < 0 || EBigInt.sign_big_int v2 < 0 then
 	    Npkcontext.report_error "Cir.eval_exp" "static expression expected"; 
-	  Big_int_Z.or_big_int v1 v2
+	  EBigInt.or_big_int v1 v2
       | Npk.BXor _ -> 
-	  if Big_int_Z.sign_big_int v1 < 0 || Big_int_Z.sign_big_int v2 < 0 then 
+	  if EBigInt.sign_big_int v1 < 0 || EBigInt.sign_big_int v2 < 0 then 
 	    Npkcontext.report_error "Cir.eval_exp" "static expression expected";
-	      Big_int_Z.xor_big_int v1 v2
+	      EBigInt.xor_big_int v1 v2
       | _ -> 
 	  Npkcontext.report_error "Cir.eval_exp" "static expression expected"
   in
   let rec eval_exp (e: exp) =
     match e with
-	Const (CInt i) -> Npk.Nat.to_z i
+	Const (CInt i) -> Npk.Nat.to_big_int i
       | Binop (op, e1, e2) -> 
 	  if is_mask op e1 e2 then mask e1 e2
 	  else apply_bop op (eval_exp e1) (eval_exp e2)
@@ -550,7 +550,7 @@ and eval_exp e =
       | Unop (Npkil.Cast (Npk.Int _, Npk.Ptr), e) -> eval_exp e
       | Unop (Npkil.Coerce b, e) -> 
 	  let i = eval_exp e in
-	    if Newspeak.belongs (Npk.Nat.of_z i) b then i 
+	    if Newspeak.belongs (Npk.Nat.of_big_int i) b then i 
 	    else Npkcontext.report_error "Cir.eval_exp" "integer overflow"
       | _ -> 
 	  Npkcontext.report_error "Cir.eval_exp" "static expression expected"
@@ -560,7 +560,7 @@ and eval_exp e =
       Npkcontext.report_error "Cir.eval_exp" 
 	"expression without side-effects expected"
     end;
-    Npk.Nat.of_z (eval_exp e)
+    Npk.Nat.of_big_int (eval_exp e)
 
 module Int =
 struct
diff --git a/ocaml/src/npk/newspeak/eBigInt.ml b/ocaml/src/npk/newspeak/eBigInt.ml
new file mode 100644
index 00000000..68dc43c8
--- /dev/null
+++ b/ocaml/src/npk/newspeak/eBigInt.ml
@@ -0,0 +1,838 @@
+(***********************************************************************)
+(*                                                                     *)
+(*                           Objective Caml                            *)
+(*                                                                     *)
+(*    Valerie Menissier-Morain, projet Cristal, INRIA Rocquencourt     *)
+(*                                                                     *)
+(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
+(*  en Automatique.  All rights reserved.  This file is distributed    *)
+(*  under the terms of the GNU Library General Public License, with    *)
+(*  the special exception on linking described in file ../../LICENSE.  *)
+(*                                                                     *)
+(***********************************************************************)
+
+(* $Id: big_int.ml 10327 2010-04-29 13:53:01Z xleroy $ *)
+
+let rec num_bits_int_aux n =
+  if n = 0 then 0 else succ(num_bits_int_aux (n lsr 1));;
+
+let num_bits_int n = num_bits_int_aux (abs n);;
+
+let sign_int i = if i = 0 then 0 else if i > 0 then 1 else -1;;
+
+let length_of_int = Sys.word_size - 2;;
+
+let monster_int = 1 lsl length_of_int;;
+let biggest_int = monster_int - 1;;
+
+open Nat
+
+type big_int =
+   { sign : int;
+     abs_value : nat }
+
+let create_big_int sign nat =
+ if sign = 1 || sign = -1 ||
+    (sign = 0 &&
+     is_zero_nat nat 0 (num_digits_nat nat 0 (length_nat nat)))
+ then { sign = sign;
+         abs_value = nat }
+ else invalid_arg "create_big_int"
+
+(* Sign of a big_int *)
+let sign_big_int bi = bi.sign
+
+let zero_big_int =
+ { sign = 0;
+   abs_value = make_nat 1 }
+
+let unit_big_int =
+  { sign = 1;
+    abs_value = nat_of_int 1 }
+
+(* Number of digits in a big_int *)
+let num_digits_big_int bi =
+ num_digits_nat (bi.abs_value) 0 (length_nat bi.abs_value)
+
+(* Opposite of a big_int *)
+let minus_big_int bi =
+ { sign = - bi.sign;
+   abs_value = copy_nat (bi.abs_value) 0 (num_digits_big_int bi)}
+
+(* Absolute value of a big_int *)
+let abs_big_int bi =
+    { sign = if bi.sign = 0 then 0 else 1;
+      abs_value = copy_nat (bi.abs_value) 0 (num_digits_big_int bi)}
+
+(* Comparison operators on big_int *)
+
+(*
+   compare_big_int (bi, bi2) = sign of (bi-bi2)
+   i.e. 1 if bi > bi2
+        0 if bi = bi2
+        -1 if bi < bi2
+*)
+let compare_big_int bi1 bi2 =
+  if bi1.sign = 0 && bi2.sign = 0 then 0
+  else if bi1.sign < bi2.sign then -1
+  else if bi1.sign > bi2.sign then 1
+  else if bi1.sign = 1 then
+            compare_nat (bi1.abs_value) 0 (num_digits_big_int bi1)
+                        (bi2.abs_value) 0 (num_digits_big_int bi2)
+  else
+            compare_nat (bi2.abs_value) 0 (num_digits_big_int bi2)
+                        (bi1.abs_value) 0 (num_digits_big_int bi1)
+
+let eq_big_int bi1 bi2 = compare_big_int bi1 bi2 = 0
+and le_big_int bi1 bi2 = compare_big_int bi1 bi2 <= 0
+and ge_big_int bi1 bi2 = compare_big_int bi1 bi2 >= 0
+and lt_big_int bi1 bi2 = compare_big_int bi1 bi2 < 0
+and gt_big_int bi1 bi2 = compare_big_int bi1 bi2 > 0
+
+let max_big_int bi1 bi2 = if lt_big_int bi1 bi2 then bi2 else bi1
+and min_big_int bi1 bi2 = if gt_big_int bi1 bi2 then bi2 else bi1
+
+(* Operations on big_int *)
+
+let pred_big_int bi =
+ match bi.sign with
+    0 -> { sign = -1; abs_value = nat_of_int 1}
+  | 1 -> let size_bi = num_digits_big_int bi in
+          let copy_bi = copy_nat (bi.abs_value) 0 size_bi in
+            ignore (decr_nat copy_bi 0 size_bi 0);
+            { sign = if is_zero_nat copy_bi 0 size_bi then 0 else 1;
+              abs_value = copy_bi }
+  | _ -> let size_bi = num_digits_big_int bi in
+         let size_res = succ (size_bi) in
+         let copy_bi = create_nat (size_res) in
+          blit_nat copy_bi 0 (bi.abs_value) 0 size_bi;
+          set_digit_nat copy_bi size_bi 0;
+          ignore (incr_nat copy_bi 0 size_res 1);
+          { sign = -1;
+            abs_value = copy_bi }
+
+let succ_big_int bi =
+ match bi.sign with
+    0 -> {sign = 1; abs_value = nat_of_int 1}
+  | -1 -> let size_bi = num_digits_big_int bi in
+           let copy_bi = copy_nat (bi.abs_value) 0 size_bi in
+            ignore (decr_nat copy_bi 0 size_bi 0);
+            { sign = if is_zero_nat copy_bi 0 size_bi then 0 else -1;
+              abs_value = copy_bi }
+  | _ -> let size_bi = num_digits_big_int bi in
+         let size_res = succ (size_bi) in
+         let copy_bi = create_nat (size_res) in
+          blit_nat copy_bi 0 (bi.abs_value) 0 size_bi;
+          set_digit_nat copy_bi size_bi 0;
+          ignore (incr_nat copy_bi 0 size_res 1);
+          { sign = 1;
+            abs_value = copy_bi }
+
+let add_big_int bi1 bi2 =
+ let size_bi1 = num_digits_big_int bi1
+ and size_bi2 = num_digits_big_int bi2 in
+  if bi1.sign = bi2.sign
+   then    (* Add absolute values if signs are the same *)
+    { sign = bi1.sign;
+      abs_value =
+       match compare_nat (bi1.abs_value) 0 size_bi1
+                         (bi2.abs_value) 0 size_bi2 with
+        -1 -> let res = create_nat (succ size_bi2) in
+                (blit_nat res 0 (bi2.abs_value) 0 size_bi2;
+                 set_digit_nat res size_bi2 0;
+                 ignore
+                   (add_nat res 0 (succ size_bi2)
+                      (bi1.abs_value) 0 size_bi1 0);
+                 res)
+       |_  -> let res = create_nat (succ size_bi1) in
+               (blit_nat res 0 (bi1.abs_value) 0 size_bi1;
+                set_digit_nat res size_bi1 0;
+                ignore (add_nat res 0 (succ size_bi1)
+                         (bi2.abs_value) 0 size_bi2 0);
+                res)}
+
+  else      (* Subtract absolute values if signs are different *)
+    match compare_nat (bi1.abs_value) 0 size_bi1
+                      (bi2.abs_value) 0 size_bi2 with
+       0 -> zero_big_int
+     | 1 -> { sign = bi1.sign;
+               abs_value =
+                let res = copy_nat (bi1.abs_value) 0 size_bi1 in
+                 (ignore (sub_nat res 0 size_bi1
+                            (bi2.abs_value) 0 size_bi2 1);
+                  res) }
+     | _ -> { sign = bi2.sign;
+              abs_value =
+               let res = copy_nat (bi2.abs_value) 0 size_bi2 in
+                 (ignore (sub_nat res 0 size_bi2
+                            (bi1.abs_value) 0 size_bi1 1);
+                  res) }
+
+(* Coercion with int type *)
+let big_int_of_int i =
+  { sign = sign_int i;
+    abs_value =
+      let res = (create_nat 1)
+      in (if i = monster_int
+             then (set_digit_nat res 0 biggest_int;
+                   ignore (incr_nat res 0 1 1))
+             else set_digit_nat res 0 (abs i));
+      res }
+
+let add_int_big_int i bi = add_big_int (big_int_of_int i) bi
+
+let sub_big_int bi1 bi2 = add_big_int bi1 (minus_big_int bi2)
+
+(* Returns i * bi *)
+let mult_int_big_int i bi =
+ let size_bi = num_digits_big_int bi in
+ let size_res = succ size_bi in
+  if i = monster_int
+     then let res = create_nat size_res in
+            blit_nat res 0 (bi.abs_value) 0 size_bi;
+            set_digit_nat res size_bi 0;
+            ignore (mult_digit_nat res 0 size_res (bi.abs_value) 0 size_bi
+                      (nat_of_int biggest_int) 0);
+            { sign = - (sign_big_int bi);
+              abs_value = res }
+     else let res = make_nat (size_res) in
+          ignore (mult_digit_nat res 0 size_res (bi.abs_value) 0 size_bi
+                    (nat_of_int (abs i)) 0);
+          { sign = (sign_int i) * (sign_big_int bi);
+            abs_value = res }
+
+let mult_big_int bi1 bi2 =
+ let size_bi1 = num_digits_big_int bi1
+ and size_bi2 = num_digits_big_int bi2 in
+ let size_res = size_bi1 + size_bi2 in
+ let res = make_nat (size_res) in
+  { sign = bi1.sign * bi2.sign;
+    abs_value =
+         if size_bi2 > size_bi1
+           then (ignore (mult_nat res 0 size_res (bi2.abs_value) 0 size_bi2
+                           (bi1.abs_value) 0 size_bi1);res)
+           else (ignore (mult_nat res 0 size_res (bi1.abs_value) 0 size_bi1
+                           (bi2.abs_value) 0 size_bi2);res) }
+
+(* (quotient, rest) of the euclidian division of 2 big_int *)
+let quomod_big_int bi1 bi2 =
+ if bi2.sign = 0 then raise Division_by_zero
+ else
+  let size_bi1 = num_digits_big_int bi1
+  and size_bi2 = num_digits_big_int bi2 in
+   match compare_nat (bi1.abs_value) 0 size_bi1
+                     (bi2.abs_value) 0 size_bi2 with
+      -1 -> (* 1/2  -> 0, reste 1, -1/2  -> -1, reste 1 *)
+            (* 1/-2 -> 0, reste 1, -1/-2 -> 1, reste 1 *)
+             if bi1.sign >= 0 then
+               (big_int_of_int 0, bi1)
+             else if bi2.sign >= 0 then
+               (big_int_of_int(-1), add_big_int bi2 bi1)
+             else
+               (big_int_of_int 1, sub_big_int bi1 bi2)
+    | 0 -> (big_int_of_int (bi1.sign * bi2.sign), zero_big_int)
+    | _ -> let bi1_negatif = bi1.sign = -1 in
+           let size_q =
+            if bi1_negatif
+             then succ (max (succ (size_bi1 - size_bi2)) 1)
+             else max (succ (size_bi1 - size_bi2)) 1
+           and size_r = succ (max size_bi1 size_bi2)
+            (* r is long enough to contain both quotient and remainder *)
+            (* of the euclidian division *)
+           in
+            (* set up quotient, remainder *)
+            let q = create_nat size_q
+            and r = create_nat size_r in
+            blit_nat r 0 (bi1.abs_value) 0 size_bi1;
+            set_to_zero_nat r size_bi1 (size_r - size_bi1);
+
+            (* do the division of |bi1| by |bi2|
+               - at the beginning, r contains |bi1|
+               - at the end, r contains
+                 * in the size_bi2 least significant digits, the remainder
+                 * in the size_r-size_bi2 most significant digits, the quotient
+              note the conditions for application of div_nat are verified here
+             *)
+            div_nat r 0 size_r (bi2.abs_value) 0 size_bi2;
+
+            (* separate quotient and remainder *)
+            blit_nat q 0 r size_bi2 (size_r - size_bi2);
+            let not_null_mod = not (is_zero_nat r 0 size_bi2) in
+
+            (* correct the signs, adjusting the quotient and remainder *)
+            if bi1_negatif && not_null_mod
+             then
+              (* bi1<0, r>0, noting r for (r, size_bi2) the remainder,      *)
+              (* we have |bi1|=q * |bi2| + r with 0 < r < |bi2|,            *)
+              (* thus -bi1 = q * |bi2| + r                                  *)
+              (* and bi1 = (-q) * |bi2| + (-r) with -|bi2| < (-r) < 0       *)
+              (* thus bi1 = -(q+1) * |bi2| + (|bi2|-r)                      *)
+              (* with 0 < (|bi2|-r) < |bi2|                                 *)
+              (* so the quotient has for sign the opposite of the bi2'one   *)
+              (*                 and for value q+1                          *)
+              (* and the remainder is strictly positive                     *)
+              (*                  has for value |bi2|-r                     *)
+              (let new_r = copy_nat (bi2.abs_value) 0 size_bi2 in
+                      (* new_r contains (r, size_bi2) the remainder *)
+                { sign = - bi2.sign;
+                  abs_value = (set_digit_nat q (pred size_q) 0;
+                               ignore (incr_nat q 0 size_q 1); q) },
+                { sign = 1;
+                 abs_value =
+                      (ignore (sub_nat new_r 0 size_bi2 r 0 size_bi2 1);
+                      new_r) })
+             else
+              (if bi1_negatif then set_digit_nat q (pred size_q) 0;
+                { sign = if is_zero_nat q 0 size_q
+                          then 0
+                          else bi1.sign * bi2.sign;
+                  abs_value = q },
+                { sign = if not_null_mod then 1 else 0;
+                  abs_value = copy_nat r 0 size_bi2 })
+
+let div_big_int bi1 bi2 = fst (quomod_big_int bi1 bi2)
+and mod_big_int bi1 bi2 = snd (quomod_big_int bi1 bi2)
+
+let gcd_big_int bi1 bi2 =
+ let size_bi1 = num_digits_big_int bi1
+ and size_bi2 = num_digits_big_int bi2 in
+  if is_zero_nat (bi1.abs_value) 0 size_bi1 then abs_big_int bi2
+  else if is_zero_nat (bi2.abs_value) 0 size_bi2 then
+        { sign = 1;
+          abs_value = bi1.abs_value }
+  else
+        { sign = 1;
+          abs_value =
+           match compare_nat (bi1.abs_value) 0 size_bi1
+                             (bi2.abs_value) 0 size_bi2 with
+           0 -> bi1.abs_value
+         | 1 ->
+            let res = copy_nat (bi1.abs_value) 0 size_bi1 in
+            let len =
+              gcd_nat res 0 size_bi1 (bi2.abs_value) 0 size_bi2 in
+            copy_nat res 0 len
+         | _ ->
+            let res = copy_nat (bi2.abs_value) 0 size_bi2 in
+            let len =
+              gcd_nat res 0 size_bi2 (bi1.abs_value) 0 size_bi1 in
+            copy_nat res 0 len
+         }
+
+(* Coercion operators *)
+
+let monster_big_int = big_int_of_int monster_int;;
+
+let monster_nat = monster_big_int.abs_value;;
+
+let is_int_big_int bi =
+  num_digits_big_int bi == 1 &&
+  match compare_nat bi.abs_value 0 1 monster_nat 0 1 with
+  | 0 -> bi.sign == -1
+  | -1 -> true
+  | _ -> false;;
+
+let int_of_big_int bi =
+  try let n = int_of_nat bi.abs_value in
+      if bi.sign = -1 then - n else n
+  with Failure _ ->
+    if eq_big_int bi monster_big_int then monster_int
+    else failwith "int_of_big_int";;
+
+let big_int_of_nativeint i =
+  if i = 0n then
+    zero_big_int
+  else if i > 0n then begin
+    let res = create_nat 1 in
+    set_digit_nat_native res 0 i;
+    { sign = 1; abs_value = res }
+  end else begin
+    let res = create_nat 1 in
+    set_digit_nat_native res 0 (Nativeint.neg i);
+    { sign = -1; abs_value = res }
+  end
+
+let nativeint_of_big_int bi =
+  if num_digits_big_int bi > 1 then failwith "nativeint_of_big_int";
+  let i = nth_digit_nat_native bi.abs_value 0 in
+  if bi.sign >= 0 then
+    if i >= 0n then i else failwith "nativeint_of_big_int"
+  else
+    if i >= 0n || i = Nativeint.min_int
+    then Nativeint.neg i
+    else failwith "nativeint_of_big_int"
+
+let big_int_of_int32 i = big_int_of_nativeint (Nativeint.of_int32 i)
+
+let int32_of_big_int bi =
+  let i = nativeint_of_big_int bi in
+  if i <= 0x7FFF_FFFFn && i >= -0x8000_0000n
+  then Nativeint.to_int32 i
+  else failwith "int32_of_big_int"
+
+let big_int_of_int64 i =
+  if Sys.word_size = 64 then
+    big_int_of_nativeint (Int64.to_nativeint i)
+  else begin
+    let (sg, absi) =
+      if i = 0L then (0, 0L)
+      else if i > 0L then (1, i)
+      else (-1, Int64.neg i) in
+    let res = create_nat 2 in
+    set_digit_nat_native res 0 (Int64.to_nativeint absi);
+    set_digit_nat_native res 1 (Int64.to_nativeint (Int64.shift_right absi 32));
+    { sign = sg; abs_value = res }
+  end
+
+let int64_of_big_int bi =
+  if Sys.word_size = 64 then
+    Int64.of_nativeint (nativeint_of_big_int bi)
+  else begin
+    let i =
+      match num_digits_big_int bi with
+      | 1 -> Int64.logand
+               (Int64.of_nativeint (nth_digit_nat_native bi.abs_value 0))
+               0xFFFFFFFFL
+      | 2 -> Int64.logor
+               (Int64.logand
+                 (Int64.of_nativeint (nth_digit_nat_native bi.abs_value 0))
+                 0xFFFFFFFFL)
+               (Int64.shift_left
+                 (Int64.of_nativeint (nth_digit_nat_native bi.abs_value 1))
+                 32)
+      | _ -> failwith "int64_of_big_int" in
+    if bi.sign >= 0 then
+      if i >= 0L then i else failwith "int64_of_big_int"
+    else
+      if i >= 0L || i = Int64.min_int
+      then Int64.neg i
+      else failwith "int64_of_big_int"
+  end
+
+(* Coercion with nat type *)
+let nat_of_big_int bi =
+ if bi.sign = -1
+ then failwith "nat_of_big_int"
+ else copy_nat (bi.abs_value) 0 (num_digits_big_int bi)
+
+let sys_big_int_of_nat nat off len =
+ let length = num_digits_nat nat off len in
+    { sign = if is_zero_nat nat off  length then 0 else 1;
+      abs_value = copy_nat nat off length }
+
+let big_int_of_nat nat =
+ sys_big_int_of_nat nat 0 (length_nat nat)
+
+(* Coercion with string type *)
+
+let string_of_big_int bi =
+  if bi.sign = -1
+  then "-" ^ string_of_nat bi.abs_value
+  else string_of_nat bi.abs_value
+
+
+let sys_big_int_of_string_aux s ofs len sgn =
+  if len < 1 then failwith "sys_big_int_of_string";
+  let n = sys_nat_of_string 10 s ofs len in
+  if is_zero_nat n 0 (length_nat n) then zero_big_int
+  else {sign = sgn; abs_value = n}
+;;
+
+let sys_big_int_of_string s ofs len =
+  if len < 1 then failwith "sys_big_int_of_string";
+  match s.[ofs] with
+  | '-' -> sys_big_int_of_string_aux s (ofs+1) (len-1) (-1)
+  | '+' -> sys_big_int_of_string_aux s (ofs+1) (len-1) 1
+  | _ -> sys_big_int_of_string_aux s ofs len 1
+;;
+
+let big_int_of_string s =
+  sys_big_int_of_string s 0 (String.length s)
+
+let power_base_nat base nat off len =
+  if base = 0 then nat_of_int 0 else
+  if is_zero_nat nat off len || base = 1 then nat_of_int 1 else
+  let power_base = make_nat (succ length_of_digit) in
+  let (pmax, _pint) = make_power_base base power_base in
+  let (n, rem) =
+      let (x, y) = quomod_big_int (sys_big_int_of_nat nat off len)
+                                  (big_int_of_int (succ pmax)) in
+        (int_of_big_int x, int_of_big_int y) in
+  if n = 0 then copy_nat power_base (pred rem) 1 else
+   begin
+    let res = make_nat n
+    and res2 = make_nat (succ n)
+    and l = num_bits_int n - 2 in
+    let p = ref (1 lsl l) in
+      blit_nat res 0 power_base pmax 1;
+      for _i = l downto 0 do
+        let len = num_digits_nat res 0 n in
+        let len2 = min n (2 * len) in
+        let succ_len2 = succ len2 in
+          ignore (square_nat res2 0 len2 res 0 len);
+          begin
+           if n land !p > 0
+              then (set_to_zero_nat res 0 len;
+                    ignore (mult_digit_nat res 0 succ_len2
+                              res2 0 len2 power_base pmax))
+              else blit_nat res 0 res2 0 len2
+          end;
+          set_to_zero_nat res2 0 len2;
+          p := !p lsr 1
+      done;
+    if rem > 0
+     then (ignore (mult_digit_nat res2 0 (succ n)
+                     res 0 n power_base (pred rem));
+           res2)
+     else res
+  end
+
+let power_int_positive_int i n =
+  match sign_int n with
+    0 -> unit_big_int
+  | -1 -> invalid_arg "power_int_positive_int"
+  | _ -> let nat = power_base_int (abs i) n in
+           { sign = if i >= 0
+                       then sign_int i
+                       else if n land 1 = 0
+                               then 1
+                               else -1;
+             abs_value = nat}
+
+let power_big_int_positive_int bi n =
+  match sign_int n with
+    0 -> unit_big_int
+  | -1 -> invalid_arg "power_big_int_positive_int"
+  | _ -> let bi_len = num_digits_big_int bi in
+         let res_len = bi_len * n in
+         let res = make_nat res_len
+         and res2 = make_nat res_len
+         and l = num_bits_int n - 2 in
+         let p = ref (1 lsl l) in
+         blit_nat res 0 bi.abs_value 0 bi_len;
+         for _i = l downto 0 do
+           let len = num_digits_nat res 0 res_len in
+           let len2 = min res_len (2 * len) in
+           set_to_zero_nat res2 0 len2;
+           ignore (square_nat res2 0 len2 res 0 len);
+           if n land !p > 0 then begin
+             let lenp = min res_len (len2 + bi_len) in
+             set_to_zero_nat res 0 lenp;
+             ignore(mult_nat res 0 lenp res2 0 len2 (bi.abs_value) 0 bi_len)
+           end else begin
+             blit_nat res 0 res2 0 len2
+           end;
+           p := !p lsr 1
+         done;
+         {sign = if bi.sign >=  0 then bi.sign
+                 else if n land 1 = 0 then 1 else -1;
+            abs_value = res}
+
+let power_int_positive_big_int i bi =
+  match sign_big_int bi with
+    0 -> unit_big_int
+  | -1 -> invalid_arg "power_int_positive_big_int"
+  | _ -> let nat = power_base_nat
+                     (abs i) (bi.abs_value) 0 (num_digits_big_int bi) in
+           { sign = if i >= 0
+                       then sign_int i
+                       else if is_digit_odd (bi.abs_value) 0
+                               then -1
+                               else 1;
+             abs_value = nat }
+
+let power_big_int_positive_big_int bi1 bi2 =
+  match sign_big_int bi2 with
+    0 -> unit_big_int
+  | -1 -> invalid_arg "power_big_int_positive_big_int"
+  | _ -> try
+           power_big_int_positive_int bi1 (int_of_big_int bi2)
+         with Failure _ ->
+         try
+           power_int_positive_big_int (int_of_big_int bi1) bi2
+         with Failure _ ->
+           raise Out_of_memory
+           (* If neither bi1 nor bi2 is a small integer, bi1^bi2 is not
+              representable.  Indeed, on a 32-bit platform,
+              |bi1| >= 2 and |bi2| >= 2^30, hence bi1^bi2 has at least
+              2^30 bits = 2^27 bytes, greater than the max size of
+              allocated blocks.  On a 64-bit platform,
+              |bi1| >= 2 and |bi2| >= 2^62, hence bi1^bi2 has at least
+              2^62 bits = 2^59 bytes, greater than the max size of
+              allocated blocks. *)
+
+(* base_power_big_int compute bi*base^n *)
+let base_power_big_int base n bi =
+  match sign_int n with
+    0 -> bi
+  | -1 -> let nat = power_base_int base (-n) in
+           let len_nat = num_digits_nat nat 0 (length_nat nat)
+           and len_bi = num_digits_big_int bi in
+             if len_bi < len_nat then
+               invalid_arg "base_power_big_int"
+             else if len_bi = len_nat &&
+                     compare_digits_nat (bi.abs_value) len_bi nat len_nat = -1
+               then invalid_arg "base_power_big_int"
+             else
+               let copy = create_nat (succ len_bi) in
+                      blit_nat copy 0 (bi.abs_value) 0 len_bi;
+                      set_digit_nat copy len_bi 0;
+                      div_nat copy 0 (succ len_bi)
+                              nat 0 len_nat;
+                      if not (is_zero_nat copy 0 len_nat)
+                         then invalid_arg "base_power_big_int"
+                         else { sign = bi.sign;
+                                abs_value = copy_nat copy len_nat 1 }
+  | _ -> let nat = power_base_int base n in
+         let len_nat = num_digits_nat nat 0 (length_nat nat)
+         and len_bi = num_digits_big_int bi in
+         let new_len = len_bi + len_nat in
+         let res = make_nat new_len in
+         ignore
+           (if len_bi > len_nat
+               then mult_nat res 0 new_len
+                              (bi.abs_value) 0 len_bi
+                              nat 0 len_nat
+               else mult_nat res 0 new_len
+                              nat 0 len_nat
+                              (bi.abs_value) 0 len_bi)
+          ; if is_zero_nat res 0 new_len
+               then zero_big_int
+               else create_big_int (bi.sign) res
+
+(* Coercion with float type *)
+
+let float_of_big_int bi =
+  float_of_string (string_of_big_int bi)
+
+(* XL: suppression de big_int_of_float et nat_of_float. *)
+
+(* Other functions needed *)
+
+(* Integer part of the square root of a big_int *)
+let sqrt_big_int bi =
+ match bi.sign with
+ | 0 -> zero_big_int
+ | -1 -> invalid_arg "sqrt_big_int"
+ | _ -> {sign = 1;
+         abs_value = sqrt_nat (bi.abs_value) 0 (num_digits_big_int bi)}
+
+let square_big_int bi =
+  if bi.sign == 0 then zero_big_int else
+  let len_bi = num_digits_big_int bi in
+  let len_res = 2 * len_bi in
+  let res = make_nat len_res in
+  ignore (square_nat res 0 len_res (bi.abs_value) 0 len_bi);
+  {sign = 1; abs_value = res}
+
+let round_futur_last_digit_bytes (s:bytes) off_set length =
+ let l = pred (length + off_set) in
+  if Char.code(Bytes.get s l) >= Char.code '5'
+    then
+     let rec round_rec l =
+       if l < off_set then true else begin
+         let current_char = Bytes.get s l in
+         if current_char = '9' then
+           (Bytes.set s l '0'; round_rec (pred l))
+         else
+           (Bytes.set s l (Char.chr (succ (Char.code current_char)));
+            false)
+       end
+     in round_rec (pred l)
+   else false
+(* round off of the futur last digit (of the integer represented by the string
+   argument of the function) that is now the previous one.
+   if s contains an integer of the form (10^n)-1
+    then s <- only 0 digits and the result_int is true
+   else s <- the round number and the result_int is false *)
+let round_futur_last_digit (s:string) off_set length =
+  let b = Bytes.of_string s in 
+    let res = round_futur_last_digit_bytes b off_set length
+    in res
+
+
+(* Approximation with floating decimal point a` la approx_ratio_exp *)
+let approx_big_int prec bi =
+  let len_bi = num_digits_big_int bi in
+  let n =
+    max 0
+        (int_of_big_int (
+          add_int_big_int
+            (-prec)
+            (div_big_int (mult_big_int (big_int_of_int (pred len_bi))
+                                      (big_int_of_string "963295986"))
+                        (big_int_of_string "100000000")))) in
+  let s =
+    string_of_big_int (div_big_int bi (power_int_positive_int 10 n)) in
+  let (sign, off, _len) =
+    if String.get s 0 = '-'
+       then ("-", 1, succ prec)
+       else ("", 0, prec) in
+  if (round_futur_last_digit s off (succ prec))
+       then (sign^"1."^(String.make prec '0')^"e"^
+             (string_of_int (n + 1 - off + String.length s)))
+       else (sign^(String.sub s off 1)^"."^
+             (String.sub s (succ off) (pred prec))
+             ^"e"^(string_of_int (n - succ off + String.length s)))
+
+(* Logical operations *)
+
+(* Shift left by N bits *)
+
+let shift_left_big_int bi n =
+  if n < 0 then invalid_arg "shift_left_big_int"
+  else if n = 0 then bi
+  else if bi.sign = 0 then bi
+  else begin
+    let size_bi = num_digits_big_int bi in
+    let size_res = size_bi + ((n + length_of_digit - 1) / length_of_digit) in
+    let res = create_nat size_res in
+    let ndigits = n / length_of_digit in
+    set_to_zero_nat res 0 ndigits;
+    blit_nat res ndigits bi.abs_value 0 size_bi;
+    let nbits = n mod length_of_digit in
+    if nbits > 0 then
+      shift_left_nat res ndigits size_bi res (ndigits + size_bi) nbits;
+    { sign = bi.sign; abs_value = res }
+  end
+
+(* Shift right by N bits (rounds toward zero) *)
+
+let shift_right_towards_zero_big_int bi n =
+  if n < 0 then invalid_arg "shift_right_towards_zero_big_int"
+  else if n = 0 then bi
+  else if bi.sign = 0 then bi
+  else begin
+    let size_bi = num_digits_big_int bi in
+    let ndigits = n / length_of_digit in
+    let nbits = n mod length_of_digit in
+    if ndigits >= size_bi then zero_big_int else begin
+      let size_res = size_bi - ndigits in
+      let res = create_nat size_res in
+      blit_nat res 0 bi.abs_value ndigits size_res;
+      if nbits > 0 then begin
+        let tmp = create_nat 1 in
+        shift_right_nat res 0 size_res tmp 0 nbits
+      end;
+      { sign = bi.sign; abs_value = res }
+    end
+  end
+
+(* Compute 2^n - 1 *)
+
+let two_power_m1_big_int n =
+  if n < 0 then invalid_arg "two_power_m1_big_int"
+  else if n = 0 then zero_big_int
+  else begin
+    let size_res = (n + length_of_digit - 1) / length_of_digit in
+    let res = make_nat size_res in
+    set_digit_nat_native res (n / length_of_digit)
+                             (Nativeint.shift_left 1n (n mod length_of_digit));
+    ignore (decr_nat res 0 size_res 0);
+    { sign = 1; abs_value = res }
+  end
+
+(* Shift right by N bits (rounds toward minus infinity) *)
+
+let shift_right_big_int bi n =
+  if n < 0 then invalid_arg "shift_right_big_int"
+  else if bi.sign >= 0 then shift_right_towards_zero_big_int bi n
+  else shift_right_towards_zero_big_int (sub_big_int bi (two_power_m1_big_int n)) n
+
+(* Extract N bits starting at ofs.
+   Treats bi in two's complement.
+   Result is always positive. *)
+
+let extract_big_int bi ofs n =
+  if ofs < 0 || n < 0 then invalid_arg "extract_big_int"
+  else if bi.sign = 0 then bi
+  else begin
+    let size_bi = num_digits_big_int bi in
+    let size_res = (n + length_of_digit - 1) / length_of_digit in
+    let ndigits = ofs / length_of_digit in
+    let nbits = ofs mod length_of_digit in
+    let res = make_nat size_res in
+    if ndigits < size_bi then
+      blit_nat res 0 bi.abs_value ndigits (min size_res (size_bi - ndigits));
+    if bi.sign < 0 then begin
+      (* Two's complement *)
+      complement_nat res 0 size_res;
+      ignore (incr_nat res 0 size_res 1)
+    end;
+    if nbits > 0 then begin
+      let tmp = create_nat 1 in
+      shift_right_nat res 0 size_res tmp 0 nbits
+    end;
+    let n' = n mod length_of_digit in
+    if n' > 0 then begin
+      let tmp = create_nat 1 in
+      set_digit_nat_native tmp 0
+          (Nativeint.shift_right_logical (-1n) (length_of_digit - n'));
+      land_digit_nat res (size_res - 1) tmp 0
+    end;
+    if is_zero_nat res 0 size_res
+    then zero_big_int
+    else { sign = 1; abs_value = res }
+  end
+
+(* Bitwise logical operations.  Arguments must be >= 0. *)
+
+let and_big_int a b =
+  if a.sign < 0 || b.sign < 0 then invalid_arg "and_big_int"
+  else if a.sign = 0 || b.sign = 0 then zero_big_int
+  else begin
+    let size_a = num_digits_big_int a
+    and size_b = num_digits_big_int b in
+    let size_res = min size_a size_b in
+    let res = create_nat size_res in
+    blit_nat res 0 a.abs_value 0 size_res;
+    for i = 0 to size_res - 1 do
+      land_digit_nat res i b.abs_value i
+    done;
+    if is_zero_nat res 0 size_res
+    then zero_big_int
+    else { sign = 1; abs_value = res }
+  end
+
+let or_big_int a b =
+  if a.sign < 0 || b.sign < 0 then invalid_arg "or_big_int"
+  else if a.sign = 0 then b
+  else if b.sign = 0 then a
+  else begin
+    let size_a = num_digits_big_int a
+    and size_b = num_digits_big_int b in
+    let size_res = max size_a size_b in
+    let res = create_nat size_res in
+    let or_aux a' b' size_b' =
+      blit_nat res 0 a'.abs_value 0 size_res;
+      for i = 0 to size_b' - 1 do
+        lor_digit_nat res i b'.abs_value i
+      done in
+    if size_a >= size_b
+    then or_aux a b size_b
+    else or_aux b a size_a;
+    if is_zero_nat res 0 size_res
+    then zero_big_int
+    else { sign = 1; abs_value = res }
+  end
+
+let xor_big_int a b =
+  if a.sign < 0 || b.sign < 0 then invalid_arg "xor_big_int"
+  else if a.sign = 0 then b
+  else if b.sign = 0 then a
+  else begin
+    let size_a = num_digits_big_int a
+    and size_b = num_digits_big_int b in
+    let size_res = max size_a size_b in
+    let res = create_nat size_res in
+    let xor_aux a' b' size_b' =
+      blit_nat res 0 a'.abs_value 0 size_res;
+      for i = 0 to size_b' - 1 do
+        lxor_digit_nat res i b'.abs_value i
+      done in
+    if size_a >= size_b
+    then xor_aux a b size_b
+    else xor_aux b a size_a;
+    if is_zero_nat res 0 size_res
+    then zero_big_int
+    else { sign = 1; abs_value = res }
+  end
diff --git a/ocaml/src/npk/newspeak/eBigInt.mli b/ocaml/src/npk/newspeak/eBigInt.mli
new file mode 100644
index 00000000..8480db22
--- /dev/null
+++ b/ocaml/src/npk/newspeak/eBigInt.mli
@@ -0,0 +1,241 @@
+(***********************************************************************)
+(*                                                                     *)
+(*                           Objective Caml                            *)
+(*                                                                     *)
+(*    Valerie Menissier-Morain, projet Cristal, INRIA Rocquencourt     *)
+(*                                                                     *)
+(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
+(*  en Automatique.  All rights reserved.  This file is distributed    *)
+(*  under the terms of the GNU Library General Public License, with    *)
+(*  the special exception on linking described in file ../../LICENSE.  *)
+(*                                                                     *)
+(***********************************************************************)
+
+(* $Id: big_int.mli 10327 2010-04-29 13:53:01Z xleroy $ *)
+
+(** Operations on arbitrary-precision integers.
+
+   Big integers (type [big_int]) are signed integers of arbitrary size.
+*)
+
+open Nat
+
+type big_int
+        (** The type of big integers. *)
+
+val zero_big_int : big_int
+        (** The big integer [0]. *)
+
+val unit_big_int : big_int
+        (** The big integer [1]. *)
+
+(** {6 Arithmetic operations} *)
+
+val minus_big_int : big_int -> big_int
+        (** Unary negation. *)
+
+val abs_big_int : big_int -> big_int
+        (** Absolute value. *)
+
+val add_big_int : big_int -> big_int -> big_int
+        (** Addition. *)
+
+val succ_big_int : big_int -> big_int
+        (** Successor (add 1). *)
+
+val add_int_big_int : int -> big_int -> big_int
+        (** Addition of a small integer to a big integer. *)
+
+val sub_big_int : big_int -> big_int -> big_int
+        (** Subtraction. *)
+
+val pred_big_int : big_int -> big_int
+        (** Predecessor (subtract 1). *)
+
+val mult_big_int : big_int -> big_int -> big_int
+        (** Multiplication of two big integers. *)
+
+val mult_int_big_int : int -> big_int -> big_int
+        (** Multiplication of a big integer by a small integer *)
+
+val square_big_int: big_int -> big_int
+        (** Return the square of the given big integer *)
+
+val sqrt_big_int: big_int -> big_int
+        (** [sqrt_big_int a] returns the integer square root of [a],
+           that is, the largest big integer [r] such that [r * r <= a].
+           Raise [Invalid_argument] if [a] is negative. *)
+
+val quomod_big_int : big_int -> big_int -> big_int * big_int
+        (** Euclidean division of two big integers.
+           The first part of the result is the quotient,
+           the second part is the remainder.
+           Writing [(q,r) = quomod_big_int a b], we have
+           [a = q * b + r] and [0 <= r < |b|].
+           Raise [Division_by_zero] if the divisor is zero. *)
+
+val div_big_int : big_int -> big_int -> big_int
+        (** Euclidean quotient of two big integers.
+           This is the first result [q] of [quomod_big_int] (see above). *)
+
+val mod_big_int : big_int -> big_int -> big_int
+        (** Euclidean modulus of two big integers.
+           This is the second result [r] of [quomod_big_int] (see above). *)
+
+val gcd_big_int : big_int -> big_int -> big_int
+        (** Greatest common divisor of two big integers. *)
+
+val power_int_positive_int: int -> int -> big_int
+
+val power_big_int_positive_int: big_int -> int -> big_int
+
+val power_int_positive_big_int: int -> big_int -> big_int
+
+val power_big_int_positive_big_int: big_int -> big_int -> big_int
+        (** Exponentiation functions.  Return the big integer
+           representing the first argument [a] raised to the power [b]
+           (the second argument).  Depending
+           on the function, [a] and [b] can be either small integers
+           or big integers.  Raise [Invalid_argument] if [b] is negative. *)
+
+(** {6 Comparisons and tests} *)
+
+val sign_big_int : big_int -> int
+        (** Return [0] if the given big integer is zero,
+           [1] if it is positive, and [-1] if it is negative. *)
+
+val compare_big_int : big_int -> big_int -> int
+        (** [compare_big_int a b] returns [0] if [a] and [b] are equal,
+           [1] if [a] is greater than [b], and [-1] if [a] is smaller
+           than [b]. *)
+
+val eq_big_int : big_int -> big_int -> bool
+
+val le_big_int : big_int -> big_int -> bool
+
+val ge_big_int : big_int -> big_int -> bool
+
+val lt_big_int : big_int -> big_int -> bool
+
+val gt_big_int : big_int -> big_int -> bool
+        (** Usual boolean comparisons between two big integers. *)
+
+val max_big_int : big_int -> big_int -> big_int
+        (** Return the greater of its two arguments. *)
+
+val min_big_int : big_int -> big_int -> big_int
+        (** Return the smaller of its two arguments. *)
+
+val num_digits_big_int : big_int -> int
+        (** Return the number of machine words used to store the
+           given big integer.  *)
+
+(** {6 Conversions to and from strings} *)
+
+val string_of_big_int : big_int -> string
+        (** Return the string representation of the given big integer,
+           in decimal (base 10). *)
+
+val big_int_of_string : string -> big_int
+        (** Convert a string to a big integer, in decimal.
+           The string consists of an optional [-] or [+] sign,
+           followed by one or several decimal digits. *)
+
+(** {6 Conversions to and from other numerical types} *)
+
+val big_int_of_int : int -> big_int
+        (** Convert a small integer to a big integer. *)
+
+val is_int_big_int : big_int -> bool
+        (** Test whether the given big integer is small enough to
+           be representable as a small integer (type [int])
+           without loss of precision.  On a 32-bit platform,
+           [is_int_big_int a] returns [true] if and only if
+           [a] is between 2{^30} and 2{^30}-1.  On a 64-bit platform,
+           [is_int_big_int a] returns [true] if and only if
+           [a] is between -2{^62} and 2{^62}-1. *)
+
+val int_of_big_int : big_int -> int
+        (** Convert a big integer to a small integer (type [int]).
+           Raises [Failure "int_of_big_int"] if the big integer
+           is not representable as a small integer. *)
+
+val big_int_of_int32 : int32 -> big_int
+        (** Convert a 32-bit integer to a big integer. *)
+
+val big_int_of_nativeint : nativeint -> big_int
+        (** Convert a native integer to a big integer. *)
+
+val big_int_of_int64 : int64 -> big_int
+        (** Convert a 64-bit integer to a big integer. *)
+
+val int32_of_big_int : big_int -> int32
+        (** Convert a big integer to a 32-bit integer.
+            Raises [Failure] if the big integer is outside the
+            range [[-2{^31}, 2{^31}-1]]. *)
+
+val nativeint_of_big_int : big_int -> nativeint
+        (** Convert a big integer to a native integer.
+            Raises [Failure] if the big integer is outside the
+            range [[Nativeint.min_int, Nativeint.max_int]]. *)
+
+val int64_of_big_int : big_int -> int64
+        (** Convert a big integer to a 64-bit integer.
+            Raises [Failure] if the big integer is outside the
+            range [[-2{^63}, 2{^63}-1]]. *)
+
+val float_of_big_int : big_int -> float
+        (** Returns a floating-point number approximating the
+           given big integer. *)
+
+(** {6 Bit-oriented operations} *)
+
+val and_big_int : big_int -> big_int -> big_int
+        (** Bitwise logical ``and''.
+            The arguments must be positive or zero. *)
+
+val or_big_int : big_int -> big_int -> big_int
+        (** Bitwise logical ``or''.
+            The arguments must be positive or zero. *)
+
+val xor_big_int : big_int -> big_int -> big_int
+        (** Bitwise logical ``exclusive or''.
+            The arguments must be positive or zero. *)
+
+val shift_left_big_int : big_int -> int -> big_int
+        (** [shift_left_big_int b n] returns [b] shifted left by [n] bits.
+            Equivalent to multiplication by [2^n]. *)
+
+val shift_right_big_int : big_int -> int -> big_int
+        (** [shift_right_big_int b n] returns [b] shifted right by [n] bits.
+            Equivalent to division by [2^n] with the result being
+            rounded towards minus infinity. *)
+
+val shift_right_towards_zero_big_int : big_int -> int -> big_int
+        (** [shift_right_towards_zero_big_int b n] returns [b] shifted
+            right by [n] bits.  The shift is performed on the absolute
+            value of [b], and the result has the same sign as [b].
+            Equivalent to division by [2^n] with the result being
+            rounded towards zero. *)
+
+val extract_big_int : big_int -> int -> int -> big_int
+        (** [extract_big_int bi ofs n] returns a nonnegative number
+            corresponding to bits [ofs] to [ofs + n - 1] of the
+            binary representation of [bi].  If [bi] is negative,
+            a two's complement representation is used. *)
+
+(**/**)
+
+(** {6 For internal use} *)
+val nat_of_big_int : big_int -> nat
+
+val big_int_of_nat : nat -> big_int
+
+val base_power_big_int: int -> int -> big_int -> big_int
+
+val sys_big_int_of_string: string -> int -> int -> big_int
+
+val round_futur_last_digit : string -> int -> int -> bool
+
+val approx_big_int: int -> big_int -> string
+
diff --git a/ocaml/src/npk/newspeak/newspeak.ml b/ocaml/src/npk/newspeak/newspeak.ml
index 6fc5a34a..c062871e 100644
--- a/ocaml/src/npk/newspeak/newspeak.ml
+++ b/ocaml/src/npk/newspeak/newspeak.ml
@@ -1,7 +1,7 @@
 (*
   C2Newspeak: compiles C code into Newspeak. Newspeak is a minimal language 
   well-suited for static analysis.
-  Copyright (C) 2007-2021  Charles Hymans, Sarah Zennou
+  Copyright (C) 2007-2011  Charles Hymans, Sarah Zennou
   
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
@@ -32,54 +32,54 @@ struct
       
   let zero = "0"
   let one = "1"
-  let of_z = Z.to_string
-  let to_z = Z.of_string
+  let of_big_int = EBigInt.string_of_big_int
+  let to_big_int = EBigInt.big_int_of_string
   let of_int x = string_of_int x
   let to_int x = 
-    let i = to_z x in
-    if not (Big_int_Z.is_int_big_int i) 
+    let i = to_big_int x in
+    if not (EBigInt.is_int_big_int i) 
     then invalid_arg "Newspeak.Nat.to_int";
-    Big_int_Z.int_of_big_int i
+    EBigInt.int_of_big_int i
 
   let apply_big_int_op op x y =
-    let x = Big_int_Z.big_int_of_string x in
-    let y = Big_int_Z.big_int_of_string y in
+    let x = EBigInt.big_int_of_string x in
+    let y = EBigInt.big_int_of_string y in
     let z = op x y in
-      Big_int_Z.string_of_big_int z
+      EBigInt.string_of_big_int z
 
-  let add = apply_big_int_op Big_int_Z.add_big_int
+  let add = apply_big_int_op EBigInt.add_big_int
 
-  let sub = apply_big_int_op Big_int_Z.sub_big_int
+  let sub = apply_big_int_op EBigInt.sub_big_int
 
-  let mul = apply_big_int_op Big_int_Z.mult_big_int
+  let mul = apply_big_int_op EBigInt.mult_big_int
 
-  let div = apply_big_int_op Big_int_Z.div_big_int
+  let div = apply_big_int_op EBigInt.div_big_int
 
   let neg x = 
-    let x = Big_int_Z.big_int_of_string x in
-    let y = Big_int_Z.minus_big_int x in
-      Big_int_Z.string_of_big_int y
+    let x = EBigInt.big_int_of_string x in
+    let y = EBigInt.minus_big_int x in
+      EBigInt.string_of_big_int y
 
   let add_int i x = 
-    let x = Big_int_Z.big_int_of_string x in
-    let y = Big_int_Z.add_int_big_int i x in
-      Big_int_Z.string_of_big_int y
+    let x = EBigInt.big_int_of_string x in
+    let y = EBigInt.add_int_big_int i x in
+      EBigInt.string_of_big_int y
 
   let mul_int i x = 
-    let x = Big_int_Z.big_int_of_string x in
-    let y = Big_int_Z.mult_int_big_int i x in
-      Big_int_Z.string_of_big_int y
+    let x = EBigInt.big_int_of_string x in
+    let y = EBigInt.mult_int_big_int i x in
+      EBigInt.string_of_big_int y
 
   let shift_left x n =
-    let x = Big_int_Z.big_int_of_string x in
-    let y = Big_int_Z.power_int_positive_int 2 n in
-    let z = Big_int_Z.mult_big_int x y in
-      Big_int_Z.string_of_big_int z
+    let x = EBigInt.big_int_of_string x in
+    let y = EBigInt.power_int_positive_int 2 n in
+    let z = EBigInt.mult_big_int x y in
+      EBigInt.string_of_big_int z
 
   let compare x y = 
-    let x = Big_int_Z.big_int_of_string x in
-    let y = Big_int_Z.big_int_of_string y in
-      Big_int_Z.compare_big_int x y
+    let x = EBigInt.big_int_of_string x in
+    let y = EBigInt.big_int_of_string y in
+      EBigInt.compare_big_int x y
 
   let to_string x = x
   let of_string x = x
diff --git a/ocaml/src/npk/newspeak/newspeak.mli b/ocaml/src/npk/newspeak/newspeak.mli
index 5937260e..9821ed95 100644
--- a/ocaml/src/npk/newspeak/newspeak.mli
+++ b/ocaml/src/npk/newspeak/newspeak.mli
@@ -1,7 +1,7 @@
 (*
   C2Newspeak: compiles C code into Newspeak. Newspeak is a minimal language 
   well-suited for static analysis.
-  Copyright (C) 2007-2021  Charles Hymans, Sarah Zennou
+  Copyright (C) 2007-2011  Charles Hymans, Sarah Zennou
   
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
@@ -70,8 +70,8 @@ module Nat: sig
       @raise Invalid_argument "Newspeak.Nat.to_int" otherwise. *)
   val to_int: t -> int
 
-  val of_z: Z.t -> t
-  val to_z: t -> Z.t
+  val of_big_int: EBigInt.big_int -> t
+  val to_big_int: t -> EBigInt.big_int
 
   val add: t -> t -> t
   val mul: t -> t -> t
diff --git a/ocaml/src/utils/config.ml b/ocaml/src/utils/config.ml
index e93af820..b069f8fd 100644
--- a/ocaml/src/utils/config.ml
+++ b/ocaml/src/utils/config.ml
@@ -1,6 +1,6 @@
 (*
     This file is part of BinCAT.
-    Copyright 2014-2021 - Airbus
+    Copyright 2014-2020 - Airbus
 
     BinCAT is free software: you can redistribute it and/or modify
     it under the terms of the GNU Affero General Public License as published by
@@ -114,7 +114,6 @@ type call_conv_t =
   | SVR (* PowerPC *)
   | SYSV (* x64 SystemV *)
   | MS (* x64 Microsoft *)
-  | RISCVI (* risc v without floating point hardware *)
 
 let call_conv_to_string cc =
   match cc with
@@ -125,11 +124,7 @@ let call_conv_to_string cc =
   | SVR -> "SVR"
   | SYSV -> "SYSV"
   | MS -> "MS"
-  | RISCVI -> "RISC V integer"
 
-(* MPX extension *)
-let mpx = ref false
-        
 let call_conv = ref CDECL
 
 let ep = ref Z.zero
@@ -153,13 +148,6 @@ let char_of_null_cst () = Char.chr (Z.to_int !null_cst)
 (* used for powerpc mfspr *)
 let processor_version = ref 0
 
-type os_t =
-  | Windows
-  | Linux
-  | Unknown_os
-
-let os = ref Unknown_os
-       
 (* if true then an interleave of backward then forward analysis from a CFA will be processed *)
 (** after the first forward analysis from binary has been performed *)
 let interleave = ref false
@@ -229,7 +217,10 @@ type fun_t =
  * (addr/name, nb_of_args_bytes * (ret value))
  *)
 let funSkipTbl: (fun_t, Z.t * ((cvalue option * tvalue list) option)) Hashtbl.t  = Hashtbl.create 5
-                                
+                 
+(* addr = reg_name(addrs, ...) *)
+let cfgTbl: (Z.t, (string * Z.t list)) Hashtbl.t = Hashtbl.create 5
+
 let reg_override: (Z.t, ((string * (Register.t -> (cvalue option * tvalue list))) list)) Hashtbl.t = Hashtbl.create 5
 let mem_override: (Z.t, ((Z.t * int) * (cvalue option * tvalue list)) list) Hashtbl.t = Hashtbl.create 5
 let heap_override: (Z.t, (((Z.t * Z.t) * int) * (cvalue option * tvalue list)) list) Hashtbl.t = Hashtbl.create 5
@@ -311,6 +302,7 @@ let clear_tables () =
   Hashtbl.clear assert_untainted_functions;
   Hashtbl.clear assert_tainted_functions;
   Hashtbl.clear import_tbl;
+  Hashtbl.clear cfgTbl;
   Hashtbl.clear reg_override;
   Hashtbl.clear mem_override;
   Hashtbl.clear heap_override;
@@ -348,6 +340,7 @@ let reset () =
   heap_content := [];
   register_content := [];
   Hashtbl.reset funSkipTbl;
+  Hashtbl.reset cfgTbl;
   Hashtbl.reset module_loglevel;
   Hashtbl.reset reg_override;
   Hashtbl.reset mem_override;
diff --git a/ocaml/src/utils/exceptions.ml b/ocaml/src/utils/exceptions.ml
index ca3312d1..2bfc7202 100644
--- a/ocaml/src/utils/exceptions.ml
+++ b/ocaml/src/utils/exceptions.ml
@@ -48,3 +48,9 @@ exception Null_deref of string
 
 (** stop the analysis for the current context *)
 exception Stop of string
+
+(** Decoding failed because instruction is unknown or unsupported **)
+exception Failed_decoding of string * int
+
+(** Failed to find the jump target **)
+exception Jump_target
\ No newline at end of file
diff --git a/ocaml/src/utils/log.ml b/ocaml/src/utils/log.ml
index 23c38bc4..a9f6d7e5 100644
--- a/ocaml/src/utils/log.ml
+++ b/ocaml/src/utils/log.ml
@@ -264,8 +264,6 @@ module History =
             paths @ acc
           ) [] preds
 
-          
-      
     let get_msg id =
       let _preds, msg = Hashtbl.find msg_id_tbl id in
       msg
diff --git a/python/idabincat/analyzer_conf.py b/python/idabincat/analyzer_conf.py
index 00f0b0f8..cb030690 100644
--- a/python/idabincat/analyzer_conf.py
+++ b/python/idabincat/analyzer_conf.py
@@ -951,7 +951,11 @@ class AnalyzerConfigurations(object):
         return wrap
 
     def _load_from_idb(self):
-        self._configs = self._netnode.get('analyzer_configs', dict())
+        try:
+            self._configs = self._netnode.get('analyzer_configs', dict())
+        except idabincat.netnode.NetnodeCorruptError:
+            self._configs ={}
+        
         self._prefs = {}
         for k, v in list(self._netnode.get('analyzer_prefs', dict()).items()):
             self._prefs[int(k)] = v
diff --git a/python/idabincat/bcplugin.py b/python/idabincat/bcplugin.py
index a6c9ea57..4d9dadcc 100644
--- a/python/idabincat/bcplugin.py
+++ b/python/idabincat/bcplugin.py
@@ -260,6 +260,8 @@ class LocalAnalyzer(Analyzer, QtCore.QProcess):
             imports_data = open(fname, 'r').read()
         else:
             imports_data = ""
+        
+        return
         try:
             npk_fname = idabincat.npkgen.NpkGen().generate_tnpk(
                 imports_data=imports_data, destfname=destfname)
@@ -640,7 +642,7 @@ class State(object):
                     self.netnode["remapped_sections"] = self.remapped_sections
             self.netnode["remap_binary"] = self.remap_binary
             if cfaoutfname is not None and os.path.isfile(cfaoutfname):
-                with open(cfaoutfname, 'rb') as f:
+                with open(cfaoutfname, 'r') as f:
                     self.last_cfaout_marshal = f.read()
             bc_log.info("Analysis results have been stored idb.")
         else:
diff --git a/python/idabincat/conf/linux-x64.ini b/python/idabincat/conf/linux-x64.ini
index 48adf378..32721e19 100644
--- a/python/idabincat/conf/linux-x64.ini
+++ b/python/idabincat/conf/linux-x64.ini
@@ -1,6 +1,3 @@
-[program]
-os = linux
-
 [x64]
 # Linux 64-bits
 
diff --git a/python/idabincat/conf/linux-x86.ini b/python/idabincat/conf/linux-x86.ini
index 957e148c..29421214 100644
--- a/python/idabincat/conf/linux-x86.ini
+++ b/python/idabincat/conf/linux-x86.ini
@@ -56,6 +56,3 @@ ss = 0x7b
 es = 0x7b
 fs = 0x00
 gs = 0x33
-
-[program]
-os = linux
\ No newline at end of file
diff --git a/python/idabincat/conf/windows-x64.ini b/python/idabincat/conf/windows-x64.ini
index 71fc541b..77172dff 100644
--- a/python/idabincat/conf/windows-x64.ini
+++ b/python/idabincat/conf/windows-x64.ini
@@ -28,6 +28,3 @@ fs = 0x53
 gs = 0x2b
 fs_base = 0x800000
 gs_base = 0x900000
-
-[program]
-os = windows
\ No newline at end of file
diff --git a/python/idabincat/conf/windows-x86.ini b/python/idabincat/conf/windows-x86.ini
index 94749623..7fb5f7d3 100644
--- a/python/idabincat/conf/windows-x86.ini
+++ b/python/idabincat/conf/windows-x86.ini
@@ -23,6 +23,3 @@ ss = 0x23
 es = 0x23
 fs = 0x3b
 gs = 0x00
-
-[program]
-os = windows
\ No newline at end of file
diff --git a/python/idabincat/gui.py b/python/idabincat/gui.py
index ef704856..7bf2b739 100644
--- a/python/idabincat/gui.py
+++ b/python/idabincat/gui.py
@@ -1399,8 +1399,8 @@ class InitConfigRegModel(QtCore.QAbstractTableModel):
         return flags
 
     def all_taint_top(self):
-        for i in xrange(0, len(self.rows)):
-            size = ConfigHelpers.register_size(ConfigHelpers.get_arch(),
+        for i in range(0, len(self.rows)):
+            size = ConfigHelpers.register_size(ConfigHelpers.get_arch(self.s.edit_config.analysis_ep),
                                                self.rows[i][0])
             if size >= 8:
                 self.rows[i][-1] = "0?0x"+"F"*(size/4)
diff --git a/python/install_plugin.py b/python/install_plugin.py
index 25b19c86..595b0897 100644
--- a/python/install_plugin.py
+++ b/python/install_plugin.py
@@ -37,8 +37,8 @@ bincat_path = os.path.dirname(os.path.realpath(__file__))
 if not os.path.isdir(userdir) or not os.path.isdir(bincat_path):
     print("Something's wrong: %s or %s is not a dir" % (plugin_dir, bincat_path))
 
-p_idabincat = os.path.join(bincat_path, "idabincat")
-p_pybincat = os.path.join(bincat_path, "pybincat")
+p_idabincat = os.path.join(bincat_path, "python", "idabincat")
+p_pybincat = os.path.join(bincat_path, "python", "pybincat")
 if os.path.isdir(p_idabincat) and os.path.isdir(p_pybincat):
     try:
         print("Copying 'idabincat' to "+plugin_dir)
@@ -51,6 +51,7 @@ if os.path.isdir(p_idabincat) and os.path.isdir(p_pybincat):
         print("Copying 'bcplugin.py' to "+plugin_dir)
         shutil.copy(os.path.join(p_idabincat, "bcplugin.py"),
                     os.path.join(plugin_dir, "bcplugin.py"))
+        print("Plugin installed, please restart IDA to use BinCAT")
     except OSError as e:
         print("Could not install! Error: "+str(e)+"\n")
 
@@ -65,8 +66,6 @@ except OSError as e:
 libpath = os.path.join(userdir, 'idabincat', 'lib')
 print("Installing default headers in "+libpath)
 try:
-    dir_util.copy_tree(os.path.join(os.path.join(bincat_path, os.pardir), "lib"), libpath)
+    dir_util.copy_tree(os.path.join(p_idabincat, "lib"), libpath)
 except OSError as e:
     print("Could not install! Error: "+str(e)+"\n")
-
-print("Plugin installed, please restart IDA to use BinCAT")
diff --git a/python/pybincat/cfa.py b/python/pybincat/cfa.py
index 16184cb3..68d1c13d 100644
--- a/python/pybincat/cfa.py
+++ b/python/pybincat/cfa.py
@@ -331,8 +331,8 @@ class Node(object):
         else:
             # v0.7+ format, tainted
             try:
-                taintsrc = list(map(unicode.strip, taintedstr.split(',')))
-            except NameError:
+                taintsrc = list(map(unicode.strip, taintedstr.split(",")))
+            except (NameError, TypeError):
                 taintsrc = list(map(str.strip, taintedstr.split(',')))
             tainted = True
         new_node.tainted = tainted
diff --git a/test/conftest.py b/test/conftest.py
index 65a831dc..1a5e2022 100644
--- a/test/conftest.py
+++ b/test/conftest.py
@@ -1,7 +1,6 @@
 
 import pytest
 import hashlib
-import itertools
 
 
 def armv8_bitmasks():
@@ -26,7 +25,8 @@ class TestValues_Meta(type):
     def __repr__(self):
         return self._name
 
-class TestValues(object, metaclass=TestValues_Meta):
+class TestValues(object):
+    __metaclass__ = TestValues_Meta
     _name = "NA"
     hash_single = False
     loop_cnt = [1, 15, 100]
@@ -53,7 +53,6 @@ class TestValues(object, metaclass=TestValues_Meta):
     x86carryop = [ "stc", "clc"]
     armv8bitmasks = armv8_bitmasks()[0:10]
     armv8off = [-512, -8, 0, 8, 504]
-    op5_couple = [(x,y) for x,y in itertools.product(op5,op5) if x+y <= 31 and y > 0]
 
 class Large(TestValues):
     _name = "large"
@@ -109,14 +108,14 @@ def pytest_addoption(parser):
 
 
 def pytest_generate_tests(metafunc):
-    func_name = metafunc.function.__name__
+    func_name = metafunc.function.func_name
     coverage = {x._name: x for x in COVERAGES}[metafunc.config.option.coverage]
     for fn in metafunc.fixturenames:
         fnstr = fn.rstrip("_")  # alias foo_, foo__, etc. to foo
         if hasattr(coverage, fnstr):
             params = getattr(coverage, fnstr)
             if coverage.hash_single:
-                hashint = int(hashlib.sha1((func_name + fnstr).encode("utf8")).hexdigest(), 16)
+                hashint = int(hashlib.sha1(func_name + fnstr).hexdigest(), 16)
                 paramidx = hashint % len(params)
                 params = [params[paramidx]]
             metafunc.parametrize(fn, params)
diff --git a/test/eggloader_armv7.c b/test/eggloader_armv7.c
index 44783137..c56212bf 100644
--- a/test/eggloader_armv7.c
+++ b/test/eggloader_armv7.c
@@ -11,7 +11,7 @@ int (*egg)();
 
 void usage(void)
 {
-        fprintf(stderr, "Usage: eggloader_armv7 <egg_file_name>\n");
+        fprintf(stderr, "Usage: eggloader_armv8 <egg_file_name>\n");
         exit(-1);
 }
 
diff --git a/test/eggloader_armv7thumb.c b/test/eggloader_armv7thumb.c
index 3078f2ae..88543e17 100644
--- a/test/eggloader_armv7thumb.c
+++ b/test/eggloader_armv7thumb.c
@@ -11,7 +11,7 @@ int (*egg)();
 
 void usage(void)
 {
-        fprintf(stderr, "Usage: eggloader_armv7thumb <egg_file_name>\n");
+        fprintf(stderr, "Usage: eggloader_armv8 <egg_file_name>\n");
         exit(-1);
 }
 
diff --git a/test/eggloader_x64 b/test/eggloader_x64
index 68efbf01..a8a06fef 100755
Binary files a/test/eggloader_x64 and b/test/eggloader_x64 differ
diff --git a/test/eggloader_x86 b/test/eggloader_x86
index 9dc90d0f..e68b5043 100755
Binary files a/test/eggloader_x86 and b/test/eggloader_x86 differ
diff --git a/test/test_armv7_isn.py b/test/test_armv7_isn.py
index b45873d8..fe46d12c 100644
--- a/test/test_armv7_isn.py
+++ b/test/test_armv7_isn.py
@@ -1,6 +1,6 @@
 import pytest
 import os
-from util import ARM,Thumb
+from util import ARM,Thumb,get_cov
 
 arm = ARM(
     os.path.join(os.path.dirname(os.path.realpath(__file__)),'armv7.ini.in')
@@ -19,6 +19,7 @@ def cmpall():
         tcompare(*args, **kargs)
     return cmpall_
 
+
 def test_nop(tmpdir, cmpall):
     asm = """
         mov r0,r0
@@ -47,6 +48,8 @@ dataop_comp_arith = pytest.mark.parametrize("op", [ "sub", "rsb", "add"])
 dataop_comp_arith_with_carry = pytest.mark.parametrize("op", [ "adc", "sbc", "rsc"])
 dataop_test_logic = pytest.mark.parametrize("op", ["tst", "teq"])
 dataop_test_arith = pytest.mark.parametrize("op", ["cmp", "cmn"])
+dataop_test_arith_thumb = pytest.mark.parametrize("op", ["cmp", "cmn", "cmp.w", "cmn.w"])
+dataop_test_cbz = pytest.mark.parametrize("op", ["cbz", "cbnz"])
 condition_codes = [ "eq", "ne", "cs", "cc", "mi", "pl",
                     "vs", "vc", "hi", "ls", "ge", "lt",
                     "gt", "le", "al" ]
@@ -57,7 +60,6 @@ def test_movs_imm(tmpdir, cmpall, op8):
     """.format(**locals())
     cmpall(tmpdir, asm, ["r0", "n", "z"])
 
-
 def test_mov_reg(tmpdir):
     asm = """
             mov r0, #0x12
@@ -293,7 +295,7 @@ def test_data_proc_test_arith(tmpdir, op, armv7op, armv7op_):
     compare(tmpdir, asm, ["r0","r1", "n", "z", "c", "v"])
 
 
-@pytest.mark.parametrize("flags", list(range(15)))
+@pytest.mark.parametrize("flags", range(15))
 def test_data_proc_msr_cpsr_reg(tmpdir,flags):
     asm = """
             mov r0, #{flags:#x}0000000
@@ -301,14 +303,14 @@ def test_data_proc_msr_cpsr_reg(tmpdir,flags):
     """.format(**locals())
     compare(tmpdir, asm, ["n", "z", "v", "c"])
 
-@pytest.mark.parametrize("flags", list(range(15)))
+@pytest.mark.parametrize("flags", range(15))
 def test_data_proc_msr_cpsr_imm(tmpdir,flags):
     asm = """
             msr cpsr, #{flags:#x}0000000
     """.format(**locals())
     compare(tmpdir, asm, ["n", "z", "v", "c"])
 
-@pytest.mark.parametrize("flags", list(range(15)))
+@pytest.mark.parametrize("flags", range(15))
 def test_data_proc_mrs_cpsr(tmpdir,flags):
     asm = """
             mov r0, #{flags:#x}0000000
@@ -333,9 +335,13 @@ def test_data_proc_read_pc(tmpdir):
 ## | |\/| | _|| |) | | / _ \   | |\__ \ .` |
 ## |_|  |_|___|___/___/_/ \_\ |___|___/_|\_|
 
-
-def test_media_ubfx(tmpdir, armv7op, op5_couple, request):
-    op5,op5_ = op5_couple
+@pytest.mark.parametrize("ubfxparams",
+                         [(x,y)
+                          for x in get_cov().op5
+                          for y in get_cov().op5
+                          if x+y <= 31 and y > 0])
+def test_media_ubfx(tmpdir, armv7op, ubfxparams):
+    op5,op5_ = ubfxparams
     asm = """
           mov r2, #{armv7op}
           ubfx r3, r2, #{op5}, #{op5_}
@@ -421,6 +427,38 @@ def test_data_xfer_push_pop1(tmpdir, cmpall):
     cmpall(tmpdir, asm, ["r0","r1","r2","r3","r4","r5"])
 
 
+def test_multiple_push(tmpdir):
+    asm = """
+        mov r0, #123
+        mov r1, r0
+        mov r2, #13
+        mov r4, #18
+        push.w { r0, r1, r2, r4 }
+        pop { r1, r2, r5 }
+    """
+
+    tcompare(tmpdir, asm, ["r0", "r1", "r2", "r4", "r5"])
+
+
+def test_add_wide(tmpdir):
+    asm = """
+        mov r0, #123
+        add.w r1, r0, #4
+    """
+
+    tcompare(tmpdir, asm, ["r0", "r1"])
+
+
+def test_decode_imm8(tmpdir):
+    asm = """
+        mov r0, #123
+        add.w r1, r0, #0x12121212
+        add.w r2, r0, #0x00990099
+        add.w r3, r0, #0x99009900
+        add.w r4, r0, #123
+    """
+    tcompare(tmpdir, asm, ["r0", "r1", "r2", "r3", "r4"])
+
 # Fails for thumb (not valid assembly)
 def test_data_xfer_offsets(tmpdir):
     asm = """
@@ -770,8 +808,7 @@ def test_swap_swap_byte_same_reg(tmpdir):
     """
     compare(tmpdir, asm, ["r0", "r1", "r2"])
 
-
-@pytest.mark.parametrize("flags", list(range(15)))
+@pytest.mark.parametrize("flags", range(15))
 @pytest.mark.parametrize("cc", condition_codes)
 def test_cond(tmpdir, flags, cc):
     asm = """
@@ -781,3 +818,67 @@ def test_cond(tmpdir, flags, cc):
             mov{cc} r1, #1
     """.format(**locals())
     compare(tmpdir, asm, ["n", "z", "v", "c", "r1"])
+
+
+## Thumb tests
+
+@dataop_test_cbz
+def test_thumb_cmp(tmpdir, op):
+    asm = """
+        mov r0, #0
+        {op} r0, .ok
+        b .end
+        .ok:
+            add r0, #1
+        .end:
+            nop
+    """.format(**locals())
+    tcompare(tmpdir, asm, ["r0"])
+
+def test_thumb_rev(tmpdir):
+    asm = """
+        movw r0, #0xabcd
+        movt r0, #0x1234
+        rev r0, r0
+    """
+
+    tcompare(tmpdir, asm, ["r0"])
+
+def test_thumb_uxth(tmpdir):
+    asm = """
+            movw r0, #0xabcd
+            movt r0, #0x1234
+            uxth r1, r0
+            uxth r2, r0, ror#8
+        """
+
+    tcompare(tmpdir, asm, ["r0", "r1", "r2"])
+
+@dataop_test_arith_thumb
+def test_thumb_cmp_reg(tmpdir, op):
+    asm = """
+       mov r0, #0xabcd
+       mov r1, #0x1234
+       {op} r0, r1 
+    """.format(**locals())
+    tcompare(tmpdir, asm, ["r0", "r1", "n", "z", "c", "v"])
+
+@dataop_test_arith_thumb
+def test_thumb_cmp_imm(tmpdir, op):
+    asm = """
+       mov r0, #0xabcd
+       {op} r0, #5
+    """.format(**locals())
+
+    tcompare(tmpdir, asm, ["r0", "n", "z", "c", "v"])
+
+@dataop_comp_logic
+def test_thumb_cmp_operations(tmpdir, op):
+    asm = """
+       mov r0, #0xabcd
+       mov r1, #0x1234
+       {op} r2, r1, r0
+    """.format(**locals())
+
+    tcompare(tmpdir, asm, ["r0", "r1", "r2", "n", "z"])
+    
\ No newline at end of file
diff --git a/test/test_coverage.py b/test/test_coverage.py
index 46981a22..bbf3254b 100644
--- a/test/test_coverage.py
+++ b/test/test_coverage.py
@@ -26,6 +26,6 @@ def test_coverage(tmpdir):
 
     bc.run()
     cfa = bc.result.cfa
-    assert len(cfa.edges[str(3)]) == 2
-    assert cfa.nodes[str(8)].statements == 'esi <- 0x0;'
+    assert len(cfa.edges[unicode(3)]) == 2
+    assert cfa.nodes[unicode(8)].statements == u'esi <- 0x0;'
 
diff --git a/test/test_powerpc_isn.py b/test/test_powerpc_isn.py
index ec38f8db..3b1c240e 100644
--- a/test/test_powerpc_isn.py
+++ b/test/test_powerpc_isn.py
@@ -264,7 +264,7 @@ def test_logic_neg(tmpdir, op32):
     compare(tmpdir, asm, ["r3", "r4", "cr:29-31", "ov" ])
 
 
-@pytest.mark.parametrize("exp", list(range(33)))
+@pytest.mark.parametrize("exp", range(33))
 def test_cntlzw(tmpdir, exp, op32):
     op32 |= 2**exp
     asm = """
@@ -324,7 +324,7 @@ def test_logic_srawi(tmpdir, op32, op5):
 ## Compare
 
 @pytest.mark.parametrize("op", ["cmp", "cmpl"])
-@pytest.mark.parametrize("crfD", list(range(8)))
+@pytest.mark.parametrize("crfD", range(8))
 def test_compare_cmp_cmpl(tmpdir, op, crfD, op32h, op32h_):
     so = op32h & 0x8000
     asm = """
@@ -338,7 +338,7 @@ def test_compare_cmp_cmpl(tmpdir, op, crfD, op32h, op32h_):
     """.format(**locals())
     compare(tmpdir, asm, ["r3", "r4", "cr"])
 
-@pytest.mark.parametrize("crfD", list(range(8)))
+@pytest.mark.parametrize("crfD", range(8))
 def test_compare_cmpli(tmpdir, crfD, op32h, op32h_):
     so = op32h & 0x8000
     asm = """
@@ -351,7 +351,7 @@ def test_compare_cmpli(tmpdir, crfD, op32h, op32h_):
     """.format(**locals())
     compare(tmpdir, asm, ["r3", "cr"])
 
-@pytest.mark.parametrize("crfD", list(range(8)))
+@pytest.mark.parametrize("crfD", range(8))
 def test_compare_cmpi(tmpdir, crfD, op32h, op16_s):
     so = op32h & 0x8000
     asm = """
@@ -444,7 +444,7 @@ VALID_COND_BYTES = [ 0x00,       0x02,       0x04, 0x05, 0x06, 0x07,
                      0x10, 0x11, 0x12, 0x13, 0x14,
                      0x18, 0x19, 0x0a, 0x1b,                         ]
 
-@pytest.mark.parametrize("cr7", list(range(16)))
+@pytest.mark.parametrize("cr7", range(16))
 @pytest.mark.parametrize("bit", ["gt", "lt", "eq", "so"])
 @pytest.mark.parametrize("cond", VALID_COND_BYTES)
 @pytest.mark.parametrize("ctr", [0, 1])
@@ -470,7 +470,7 @@ def test_branch_bclr(tmpdir, cr7, bit, cond, ctr):
     """.format(**locals())
     compare(tmpdir, asm, ["r3", "r4", "r5", "r6", "r7", "r8", "ctr"])
 
-@pytest.mark.parametrize("cr7", list(range(16)))
+@pytest.mark.parametrize("cr7", range(16))
 @pytest.mark.parametrize("bit", ["gt", "lt", "eq", "so"])
 @pytest.mark.parametrize("cond", [ x for x in VALID_COND_BYTES if x & 4 ])
                          # only conds that do not touch to CTR for bcctr
@@ -500,7 +500,7 @@ def test_branch_bcctr_bclr(tmpdir, cr7, bit, cond, ctr):
     compare(tmpdir, asm, ["r3", "r4", "r5", "r6", "r7", "r8"])
 
 
-@pytest.mark.parametrize("cr7", list(range(16)))
+@pytest.mark.parametrize("cr7", range(16))
 @pytest.mark.parametrize("cond", VALID_COND_BYTES)
 @pytest.mark.parametrize("bit", ["gt", "lt", "eq", "so"])
 def test_branch_cond(tmpdir, cr7, bit, cond):
@@ -678,7 +678,7 @@ def test_load_stmw(tmpdir):
     """.format(**locals())
     compare(tmpdir, asm, ["r3", "r4", "r5", "r6", "r28", "r29", "r30", "r31"])
 
-@pytest.mark.parametrize("op", list(range(1, 33)))
+@pytest.mark.parametrize("op", range(1, 33))
 def test_load_lswi(tmpdir, op):
     asm = """
         xor %r0, %r0, %r0
@@ -704,7 +704,7 @@ def test_load_lswi(tmpdir, op):
     """.format(**locals())
     compare(tmpdir, asm, ["r0", "r1", "r2", "r3", "r4", "r28", "r29", "r30", "r31"])
 
-@pytest.mark.parametrize("op", list(range(1, 33)))
+@pytest.mark.parametrize("op", range(1, 33))
 def test_store_stswi(tmpdir, op):
     initreg = ["    lis %r{num}, 0xaa{num:02d}\n    ori %r{num}, %r{num}, 0x55{num:02d}".format(num=i)
                for i in [28, 29, 30, 31, 0, 1, 2, 3, 4]]
diff --git a/test/util.py b/test/util.py
index 0a26ece8..a511c66e 100644
--- a/test/util.py
+++ b/test/util.py
@@ -22,7 +22,7 @@ def getReg(my_node, name):
     try:
         return my_node.unrels["0"][v][0]
     except KeyError:
-        return my_node.unrels[list(my_node.unrels.keys())[0]][v][0]
+        return my_node.unrels[my_node.unrels.keys()[0]][v][0]
         
 
 
@@ -43,7 +43,6 @@ class Bincat:
         outf = tmpdir.join('end.ini')
         logf = tmpdir.join('log.txt')
         inif = tmpdir.join('init.ini')
-
         inif.write(initfile)
 
         self.inif = str(inif)
@@ -51,7 +50,10 @@ class Bincat:
         self.outf = str(outf)
 
         self.cfa = cfa.CFA.from_filenames(str(inif), str(outf), str(logf))
-        self.last_node = getLastNode(self.cfa)
+
+    @property
+    def last_node(self):
+        return getLastNode(self.cfa)
 
     def last_reg(self, regname):
         return getReg(self.last_node, regname)
@@ -81,15 +83,15 @@ class InitFile:
         if "code_length" not in v:
             fstat = os.stat(v["filepath"])
             v["code_length"] = fstat.st_size
-        v["regmem"] = ("\n".join("mem[%#x]=|%s|" % (addr, val.hex())
-                                 for (addr, val) in self.mem.items())
+        v["regmem"] = ("\n".join("mem[%#x]=|%s|" % (addr, val.encode("hex"))
+                                 for (addr, val) in self.mem.iteritems())
                        + "\n".join("reg[%s]=%s" % (regname, val)
-                                 for (regname, val) in self.reg.items())
+                                 for (regname, val) in self.reg.iteritems())
                        )
         v["analyzer_section"] = "\n".join(self.analyzer_entries)
         v["program_section"] = "\n".join(self.program_entries)
         conf = self.template.format(**v)
-        print(self.conf_edits)
+        print self.conf_edits
         for before, after in self.conf_edits:
             conf = conf.replace(before, after)
         return conf
@@ -97,7 +99,7 @@ class InitFile:
     def set_directives(self, directives):
         overrides = directives.get("overrides", {})
         self["overrides"] = "\n".join(
-            "%#010x=%s" % (addr, val) for addr, val in overrides.items())
+            "%#010x=%s" % (addr, val) for addr, val in overrides.iteritems())
 
     def set_mem(self, addr, val):
         self.mem[addr] = val
@@ -181,7 +183,9 @@ class Arch:
     def run_bc_test(self, bctest, testname):
         try:
             bctest.run()
-        except Exception as e:  # hack to add test name in the exception
+        except Exception, e:  # hack to add test name in the exception
+            import traceback
+            traceback.print_exc()
             pytest.fail("%s: %r\n%s" % (testname, e, bctest.listing))
         return {reg: getReg(bctest.result.last_node, reg) for reg in self.ALL_REGS}
 
@@ -197,7 +201,7 @@ class Arch:
         diff = []
         same = []
         diff_summary = []
-        for r, v in regs.items():
+        for r, v in regs.iteritems():
             if type(v) is tuple:
                 v = list(v)
             else:
@@ -250,17 +254,17 @@ class Arch:
         bctest = self.make_bc_test(tmpdir, asm)
         try:
             cpu = self.cpu_run(tmpdir, bctest.filename)
-        except subprocess.CalledProcessError as e:
+        except subprocess.CalledProcessError, e:
             pytest.fail("%s: %s\n%s" % (testname, e, bctest.listing))
 
-        print(hline)
-        print(bctest.listing)
-        print()
+        print hline
+        print bctest.listing
+        print
         for reg in regs:
             regspec = reg.split(":")
             reg = regspec[0]
             bitfield = regspec[1:]
-            print("%6s = %08x" % (reg, cpu[reg]))
+            print "%6s = %08x" % (reg, cpu[reg])
 
     def compare(self, tmpdir, asm, regs=None, reg_taints={}, top_allowed={}):
         testname = inspect.stack()[1][3]
@@ -273,7 +277,7 @@ class Arch:
 
         try:
             cpu = self.cpu_run(tmpdir, bctest.filename)
-        except subprocess.CalledProcessError as e:
+        except subprocess.CalledProcessError, e:
             pytest.fail("%s: %s\n%s" % (testname, e, bctest.listing))
 
         diff = []
@@ -293,8 +297,8 @@ class Arch:
                 diff_summary.append(r)
             else:
                 same.append("  both  :  %s = %08x  %r%s" % (r, value, bincat[r], maskstring))
-            allow_top = top_allowed.get(r, 0)
-            if vtop & ~allow_top & mask:
+            allow_top = top_allowed.get(r, 0) != 0
+            if allow_top and vtop & mask:
                 diff.append("+ top allowed:  %s = %08x ? %08x" % (r, cpu[r], allow_top))
                 diff.append("+ bincat     :  %s = %08x ? %08x  %r" % (r, value, vtop, bincat[r]))
                 diff_summary.append("%s(top)" % r)
@@ -307,7 +311,7 @@ class Arch:
                           + "\n".join(same))
         diff = []
         diff_summary = []
-        for r, t in reg_taints.items():
+        for r, t in reg_taints.iteritems():
             if bincat[r].taint != t:
                 diff.append("- expected :  %s = %08x ! %08x" % (r, cpu[r], t))
                 diff.append("+ bincat   :  %s = %08x ! %08x  %r" % (r, bincat[r].value, bincat[r].taint, bincat[r]))
@@ -319,26 +323,28 @@ class Arch:
                           + "\n".join(diff)+"\n=========================\n"+"\n".join(same))
 
     def assemble(self, tmpdir, asm):
-        d = tmpdir.mkdir(next(self.AS_TMP_DIR))
+        d = tmpdir.mkdir(self.AS_TMP_DIR.next())
         inf = d.join("asm.S")
         obj = d.join("asm.o")
         outf = d.join("opcodes")
         inf.write(".text\n.globl _start\n_start:\n" + asm)
         subprocess.check_call(self.AS + ["-o", str(obj), str(inf)])
         subprocess.check_call(self.OBJCOPY + ["-O", "binary", str(obj), str(outf)])
-        lst = subprocess.check_output(self.OBJDUMP + ["-b", "binary", "-D",  str(outf)]).decode("ascii", "replace")
+        lst = subprocess.check_output(self.OBJDUMP + ["-b", "binary", "-D",  str(outf)])
         s = [l for l in lst.splitlines() if l.startswith(" ")]
         listing = "\n".join(s)
-        opcodes = open(str(outf),"rb").read()
+        opcodes = open(str(outf)).read()
         return listing, str(outf), opcodes
+
     def cpu_run(self, tmpdir, opcodesfname):
         eggloader = os.path.join(os.path.dirname(os.path.realpath(__file__)), self.EGGLOADER)
         cmd = [eggloader, opcodesfname]
         if self.QEMU:
             cmd = self.QEMU + cmd
         out = subprocess.check_output(cmd)
-        regs = {reg.decode("ascii"): int(val, 16) for reg, val in
-                (l.strip().split(b"=") for l in out.splitlines())}
+
+        regs = {reg: int(val, 16) for reg, val in
+                (l.strip().split("=") for l in out.splitlines())}
         self.extract_flags(regs)
         return regs
 
@@ -357,12 +363,12 @@ class X86(Arch):
     EGGLOADER = 'eggloader_x86'
 
     def assemble(self, tmpdir, asm):
-        d = tmpdir.mkdir(next(self.NASM_TMP_DIR))
+        d = tmpdir.mkdir(self.NASM_TMP_DIR.next())
         inf = d.join("asm.S")
         outf = d.join("opcodes")
         inf.write("BITS 32\n"+asm)
-        listing = subprocess.check_output(["nasm", "-l", "/dev/stdout", "-o", str(outf), str(inf)]).decode("ascii", "replace")
-        opcodes = open(str(outf), "rb").read()
+        listing = subprocess.check_output(["nasm", "-l", "/dev/stdout", "-o", str(outf), str(inf)])
+        opcodes = open(str(outf)).read()
         return listing, str(outf), opcodes
 
     def extract_flags(self, regs):
@@ -399,12 +405,12 @@ class X64(Arch):
     EGGLOADER = 'eggloader_x64'
 
     def assemble(self, tmpdir, asm):
-        d = tmpdir.mkdir(next(self.NASM_TMP_DIR))
+        d = tmpdir.mkdir(self.NASM_TMP_DIR.next())
         inf = d.join("asm.S")
         outf = d.join("opcodes")
         inf.write("BITS 64\n"+asm)
-        listing = subprocess.check_output(["nasm", "-l", "/dev/stdout", "-o", str(outf), str(inf)]).decode("ascii", "replace")
-        opcodes = open(str(outf), "rb").read()
+        listing = subprocess.check_output(["nasm", "-l", "/dev/stdout", "-o", str(outf), str(inf)])
+        opcodes = open(str(outf)).read()
         return listing, str(outf), opcodes
 
     def extract_flags(self, regs):
@@ -460,6 +466,7 @@ class Thumb(ARM):
     def assemble(self, tmpdir, asm):
         asm = """
            .code 16
+           .syntax unified
            .thumb_func
         """ + asm
         return ARM.assemble(self, tmpdir, asm)
@@ -512,3 +519,5 @@ class PowerPC(Arch):
         regs["ca"] = (xer >> 29) & 1
         regs["tbc"] = (xer >> 0) & 0x7f
 
+def get_cov():
+    return {x._name: x for x in conftest.COVERAGES}[pytest.config.option.coverage]
